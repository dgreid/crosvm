<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Architecture - Book of crosvm</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="building_crosvm/index.html"><strong aria-hidden="true">2.</strong> Building Crosvm</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="building_crosvm/linux.html"><strong aria-hidden="true">2.1.</strong> For Linux</a></li><li class="chapter-item expanded "><a href="building_crosvm/chromium_os.html"><strong aria-hidden="true">2.2.</strong> For Chromium OS</a></li></ol></li><li class="chapter-item expanded "><a href="running_crosvm/index.html"><strong aria-hidden="true">3.</strong> Running Crosvm</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="running_crosvm/basic_usage.html"><strong aria-hidden="true">3.1.</strong> Basic Usage</a></li><li class="chapter-item expanded "><a href="running_crosvm/usage.html"><strong aria-hidden="true">3.2.</strong> Command Line Options</a></li><li class="chapter-item expanded "><a href="running_crosvm/requirements.html"><strong aria-hidden="true">3.3.</strong> System Requirements</a></li><li class="chapter-item expanded "><a href="running_crosvm/features.html"><strong aria-hidden="true">3.4.</strong> Features</a></li><li class="chapter-item expanded "><a href="running_crosvm/devices.html"><strong aria-hidden="true">3.5.</strong> Devices</a></li></ol></li><li class="chapter-item expanded "><a href="architecture.html" class="active"><strong aria-hidden="true">4.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="contributing.html"><strong aria-hidden="true">5.</strong> Contributing</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="onboarding.html"><strong aria-hidden="true">6.</strong> Onboarding Resources</a></li><li class="chapter-item expanded "><a href="appendix/index.html"><strong aria-hidden="true">7.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix/example_usage.html"><strong aria-hidden="true">7.1.</strong> Example Usage (Outdated)</a></li><li class="chapter-item expanded "><a href="appendix/sandboxing.html"><strong aria-hidden="true">7.2.</strong> Sandboxing</a></li><li class="chapter-item expanded "><a href="appendix/seccomp.html"><strong aria-hidden="true">7.3.</strong> Seccomp</a></li><li class="chapter-item expanded "><a href="appendix/minijail.html"><strong aria-hidden="true">7.4.</strong> Minijail</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="api.html">API Documentation</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Book of crosvm</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>The principle characteristics of crosvm are:</p>
<ul>
<li>A process per virtual device, made using fork</li>
<li>Each process is sandboxed using <a href="https://android.googlesource.com/platform/external/minijail">minijail</a></li>
<li>Takes full advantage of KVM and low-level Linux syscalls, and so only runs
on Linux</li>
<li>Written in Rust for security and safety</li>
</ul>
<p>A typical session of crosvm starts in <code>main.rs</code> where command line parsing is
done to build up a <code>Config</code> structure. The <code>Config</code> is used by <code>run_config</code> in
<code>linux.rs</code> to setup and execute a VM. Broken down into rough steps:</p>
<ol>
<li>Load the linux kernel from an ELF file.</li>
<li>Create a handful of control sockets used by the virtual devices.</li>
<li>Invoke the architecture specific VM builder <code>Arch::build_vm</code> (located in
<code>x86_64/src/lib.rs</code> or <code>aarch64/src/lib.rs</code>).</li>
<li><code>Arch::build_vm</code> will itself invoke the provided <code>create_devices</code> function
from <code>linux.rs</code></li>
<li><code>create_devices</code> creates every PCI device, including the virtio devices,
that were configured in <code>Config</code>, along with matching <a href="https://android.googlesource.com/platform/external/minijail">minijail</a> configs for
each.</li>
<li><code>Arch::generate_pci_root</code>, using a list of every PCI device with optional
<code>Minijail</code>, will finally jail the PCI devices and construct a <code>PciRoot</code> that
communicates with them.</li>
<li>Once the VM has been built, it's contained within a <code>RunnableLinuxVm</code> object
that is used by the VCPUs and control loop to service requests until
shutdown.</li>
</ol>
<h2 id="forking"><a class="header" href="#forking">Forking</a></h2>
<p>During the device creation routine, each device will be created and then wrapped
in a <code>ProxyDevice</code> which will internally <code>fork</code> (but not <code>exec</code>) and <a href="https://android.googlesource.com/platform/external/minijail">minijail</a>
the device, while dropping it for the main process. The only interaction that
the device is capable of having with the main process is via the proxied trait
methods of <code>BusDevice</code>, shared memory mappings such as the guest memory, and
file descriptors that were specifically allowed by that device's security
policy. This can lead to some surprising behavior to be aware of such as why
some file descriptors which were once valid are now invalid.</p>
<h2 id="sandboxing-policy"><a class="header" href="#sandboxing-policy">Sandboxing Policy</a></h2>
<p>Every sandbox is made with <a href="https://android.googlesource.com/platform/external/minijail">minijail</a> and starts with <code>create_base_minijail</code> in
<code>linux.rs</code> which set some very restrictive settings. Linux namespaces and
seccomp filters are used extensively. Each seccomp policy can be found under
<code>seccomp/{arch}/{device}.policy</code> and should start by <code>@include</code>-ing the
<code>common_device.policy</code>. With the exception of architecture specific devices
(such as <code>Pl030</code> on ARM or <code>I8042</code> on x86_64), every device will need a
different policy for each supported architecture.</p>
<h2 id="the-vm-control-sockets"><a class="header" href="#the-vm-control-sockets">The VM Control Sockets</a></h2>
<p>For the operations that devices need to perform on the global VM state, such as
mapping into guest memory address space, there are the vm control sockets. There
are a few kinds, split by the type of request and response that the socket will
process. This also proves basic security privilege separation in case a device
becomes compromised by a malicious guest. For example, a rogue device that is
able to allocate MSI routes would not be able to use the same socket to
(de)register guest memory. During the device initialization stage, each device
that requires some aspect of VM control will have a constructor that requires
the corresponding control socket. The control socket will get preserved when the
device is sandboxed and and the other side of the socket will be waited on in
the main process's control loop.</p>
<p>The socket exposed by crosvm with the <code>--socket</code> command line argument is
another form of the VM control socket. Because the protocol of the control
socket is internal and unstable, the only supported way of using that resulting
named unix domain socket is via crosvm command line subcommands such as <code>crosvm stop</code>.</p>
<h2 id="guestmemory"><a class="header" href="#guestmemory">GuestMemory</a></h2>
<p><code>GuestMemory</code> and its friends <code>VolatileMemory</code>, <code>VolatileSlice</code>,
<code>MemoryMapping</code>, and <code>SharedMemory</code>, are common types used throughout crosvm to
interact with guest memory. Know which one to use in what place using some
guidelines</p>
<ul>
<li><code>GuestMemory</code> is for sending around references to all of the guest memory.
It can be cloned freely, but the underlying guest memory is always the same.
Internally, it's implemented using <code>MemoryMapping</code> and <code>SharedMemory</code>. Note
that <code>GuestMemory</code> is mapped into the host address space, but it is
non-contiguous. Device memory, such as mapped DMA-Bufs, are not present in
<code>GuestMemory</code>.</li>
<li><code>SharedMemory</code> wraps a <code>memfd</code> and can be mapped using <code>MemoryMapping</code> to
access its data. <code>SharedMemory</code> can't be cloned.</li>
<li><code>VolatileMemory</code> is a trait that exposes generic access to non-contiguous
memory. <code>GuestMemory</code> implements this trait. Use this trait for functions
that operate on a memory space but don't necessarily need it to be guest
memory.</li>
<li><code>VolatileSlice</code> is analogous to a Rust slice, but unlike those, a
<code>VolatileSlice</code> has data that changes asynchronously by all those that
reference it. Exclusive mutability and data synchronization are not
available when it comes to a <code>VolatileSlice</code>. This type is useful for
functions that operate on contiguous shared memory, such as a single entry
from a scatter gather table, or for safe wrappers around functions which
operate on pointers, such as a <code>read</code> or <code>write</code> syscall.</li>
<li><code>MemoryMapping</code> is a safe wrapper around anonymous and file
mappings. Provides RAII and does munmap after use. Access via Rust
references is forbidden, but indirect reading and writing is available via
<code>VolatileSlice</code> and several convenience functions. This type is most useful
for mapping memory unrelated to <code>GuestMemory</code>.</li>
</ul>
<h3 id="device-model"><a class="header" href="#device-model">Device Model</a></h3>
<h3 id="busbusdevice"><a class="header" href="#busbusdevice"><code>Bus</code>/<code>BusDevice</code></a></h3>
<p>The root of the crosvm device model is the <code>Bus</code> structure and its friend the
<code>BusDevice</code> trait. The <code>Bus</code> structure is a virtual computer bus used to emulate
the memory-mapped I/O bus and also I/O ports for x86 VMs. On a read or write to
an address on a VM's bus, the corresponding <code>Bus</code> object is queried for a
<code>BusDevice</code> that occupies that address. <code>Bus</code> will then forward the read/write
to the <code>BusDevice</code>. Because of this behavior, only one <code>BusDevice</code> may exist at
any given address. However, a <code>BusDevice</code> may be placed at more than one address
range. Depending on how a <code>BusDevice</code> was inserted into the <code>Bus</code>, the forwarded
read/write will be relative to 0 or to the start of the address range that the
<code>BusDevice</code> occupies (which would be ambiguous if the <code>BusDevice</code> occupied more
than one range).</p>
<p>Only the base address of a multi-byte read/write is used to search for a device,
so a device implementation should be aware that the last address of a single
read/write may be outside its address range. For example, if a <code>BusDevice</code> was
inserted at base address 0x1000 with a length of 0x40, a 4-byte read by a VCPU
at 0x39 would be forwarded to that <code>BusDevice</code>.</p>
<p>Each <code>BusDevice</code> is reference counted and wrapped in a mutex, so implementations
of <code>BusDevice</code> need not worry about synchronizing their access across multiple
VCPUs and threads. Each VCPU will get a complete copy of the <code>Bus</code>, so there is
no contention for querying the <code>Bus</code> about an address. Once the <code>BusDevice</code> is
found, the <code>Bus</code> will acquire an exclusive lock to the device and forward the
VCPU's read/write. The implementation of the <code>BusDevice</code> will block execution of
the VCPU that invoked it, as well as any other VCPU attempting access, until it
returns from its method.</p>
<p>Most devices in crosvm do not implement <code>BusDevice</code> directly, but some are
examples are <code>i8042</code> and <code>Serial</code>. With the exception of PCI devices, all
devices are inserted by architecture specific code (which may call into the
architecture-neutral <code>arch</code> crate). A <code>BusDevice</code> can be proxied to a sandboxed
process using <code>ProxyDevice</code>, which will create the second process using a fork,
with no exec.</p>
<h3 id="pciconfigiopciconfigmmio"><a class="header" href="#pciconfigiopciconfigmmio"><code>PciConfigIo</code>/<code>PciConfigMmio</code></a></h3>
<p>In order to use the more complex PCI bus, there are a couple adapters that
implement <code>BusDevice</code> and call into a <code>PciRoot</code> with higher level calls to
<code>config_space_read</code>/<code>config_space_write</code>. The <code>PciConfigMmio</code> is a <code>BusDevice</code>
for insertion into the MMIO <code>Bus</code> for ARM devices. For x86_64, <code>PciConfigIo</code> is
inserted into the I/O port <code>Bus</code>. There is only one implementation of <code>PciRoot</code>
that is used by either of the <code>PciConfig*</code> structures. Because these devices are
very simple, they have very little code or state. They aren't sandboxed and are
run as part of the main process.</p>
<h3 id="pcirootpcidevicevirtiopcidevice"><a class="header" href="#pcirootpcidevicevirtiopcidevice"><code>PciRoot</code>/<code>PciDevice</code>/<code>VirtioPciDevice</code></a></h3>
<p>The <code>PciRoot</code>, analogous to <code>BusDevice</code> for <code>Bus</code>s, contains all the <code>PciDevice</code>
trait objects. Because of a shortcut (or hack), the <code>ProxyDevice</code> only supports
jailing <code>BusDevice</code> traits. Therefore, <code>PciRoot</code> only contains <code>BusDevice</code>s,
even though they also implement <code>PciDevice</code>. In fact, every <code>PciDevice</code> also
implements <code>BusDevice</code> because of a blanket implementation (<code>impl&lt;T: PciDevice&gt; BusDevice for T { … }</code>). There are a few PCI related methods in <code>BusDevice</code> to
allow the <code>PciRoot</code> to still communicate with the underlying <code>PciDevice</code> (yes,
this abstraction is very leaky). Most devices will not implement <code>PciDevice</code>
directly, instead using the <code>VirtioPciDevice</code> implementation for virtio devices,
but the xHCI (USB) controller is an example that implements <code>PciDevice</code>
directly. The <code>VirtioPciDevice</code> is an implementation of <code>PciDevice</code> that wraps a
<code>VirtioDevice</code>, which is how the virtio specified PCI transport is adapted to a
transport agnostic <code>VirtioDevice</code> implementation.</p>
<h3 id="virtiodevice"><a class="header" href="#virtiodevice"><code>VirtioDevice</code></a></h3>
<p>The <code>VirtioDevice</code> is the most widely implemented trait among the device traits.
Each of the different virtio devices (block, rng, net, etc.) implement this
trait directly and they follow a similar pattern. Most of the trait methods are
easily filled in with basic information about the specific device, but
<code>activate</code> will be the heart of the implementation. It's called by the virtio
transport after the guest's driver has indicated the device has been configured
and is ready to run. The virtio device implementation will receive the run time
related resources (<code>GuestMemory</code>, <code>Interrupt</code>, etc.) for processing virtio
queues and associated interrupts via the arguments to <code>activate</code>, but <code>activate</code>
can't spend its time actually processing the queues. A VCPU will be blocked as
long as <code>activate</code> is running. Every device uses <code>activate</code> to launch a worker
thread that takes ownership of run time resources to do the actual processing.
There is some subtlety in dealing with virtio queues, so the smart thing to do
is copy a simpler device and adapt it, such as the rng device (<code>rng.rs</code>).</p>
<h2 id="communication-framework"><a class="header" href="#communication-framework">Communication Framework</a></h2>
<p>Because of the multi-process nature of crosvm, communication is done over
several IPC primitives. The common ones are shared memory pages, unix sockets,
anonymous pipes, and various other file descriptor variants (DMA-buf, eventfd,
etc.). Standard methods (<code>read</code>/<code>write</code>) of using these primitives may be used,
but crosvm has developed some helpers which should be used where applicable.</p>
<h3 id="pollcontextepollcontext"><a class="header" href="#pollcontextepollcontext"><code>PollContext</code>/<code>EpollContext</code></a></h3>
<p>Most threads in crosvm will have a wait loop using a <code>PollContext</code>, which is a
wrapper around Linux's <code>epoll</code> primitive for selecting over file descriptors.
<code>EpollContext</code> is very similar but has slightly fewer features, but is usable by
multiple threads at once. In either case, each FD is added to the context along
with an associated token, whose type is the type parameter of <code>PollContext</code>.
This token must be convertible to and from a <code>u64</code>, which is a limitation
imposed by how <code>epoll</code> works. There is a custom derive <code>#[derive(PollToken)]</code>
which can be applied to an <code>enum</code> declaration that makes it easy to use your own
enum in a <code>PollContext</code>.</p>
<p>Note that the limitations of <code>PollContext</code> are the same as the limitations of
<code>epoll</code>. The same FD can not be inserted more than once, and the FD will be
automatically removed if the process runs out of references to that FD. A
<code>dup</code>/<code>fork</code> call will increment that reference count, so closing the original
FD will not actually remove it from the <code>PollContext</code>. It is possible to receive
tokens from <code>PollContext</code> for an FD that was closed because of a race condition
in which an event was registered in the background before the <code>close</code> happened.
Best practice is to remove an FD before closing it so that events associated
with it can be reliably eliminated.</p>
<h3 id="serde-with-descriptors"><a class="header" href="#serde-with-descriptors"><code>serde</code> with Descriptors.</a></h3>
<p>Using raw sockets and pipes to communicate is very inconvenient for rich data
types. To help make this easier and less error prone, crosvm uses the <code>serde</code>
crate. To allow transmitting types with embedded descriptors (FDs on Linux or
HANDLEs on Windows), a module is provided for sending and receiving descriptors
alongside the plain old bytes that serde consumes.</p>
<h2 id="code-map"><a class="header" href="#code-map">Code Map</a></h2>
<p>Source code is organized into crates, each with their own unit tests.</p>
<ul>
<li><code>./src/</code> - The top-level binary front-end for using crosvm.</li>
<li><code>aarch64</code> - Support code specific to 64 bit ARM architectures.</li>
<li><code>base</code> - Safe wrappers for small system facilities which provides
cross-platform-compatible interfaces. For Linux, this is basically a thin
wrapper of <code>sys_util</code>.</li>
<li><code>bin</code> - Scripts for code health such as wrappers of <code>rustfmt</code> and <code>clippy</code>.</li>
<li><code>ci</code> - Scripts for continuous integration.</li>
<li><code>cros_async</code> - Runtime for async/await programming. This crate provides a
<code>Future</code> executor based on <code>io_uring</code> and one based on <code>epoll</code>.</li>
<li><code>devices</code> - Virtual devices exposed to the guest OS.</li>
<li><code>disk</code> - Library to create and manipulate several types of disks such as raw
disk, <a href="https://en.wikipedia.org/wiki/Qcow">qcow</a>, etc.</li>
<li><code>hypervisor</code> - Abstract layer to interact with hypervisors. For Linux, this
crate is a wrapper of <code>kvm</code>.</li>
<li><code>integration_tests</code> - End-to-end tests that run a crosvm VM.</li>
<li><code>kernel_loader</code> - Loads elf64 kernel files to a slice of memory.</li>
<li><code>kvm_sys</code> - Low-level (mostly) auto-generated structures and constants for
using KVM.</li>
<li><code>kvm</code> - Unsafe, low-level wrapper code for using <code>kvm_sys</code>.</li>
<li><code>libvda</code> - Safe wrapper of <a href="https://chromium.googlesource.com/chromiumos/platform2/+/refs/heads/main/arc/vm/libvda/">libvda</a>, a Chrome OS HW-accelerated video
decoding/encoding library.</li>
<li><code>net_sys</code> - Low-level (mostly) auto-generated structures and constants for
creating TUN/TAP devices.</li>
<li><code>net_util</code> - Wrapper for creating TUN/TAP devices.</li>
<li><code>qcow_util</code> - A library and a binary to manipulate <a href="https://en.wikipedia.org/wiki/Qcow">qcow</a> disks.</li>
<li><code>seccomp</code> - Contains minijail seccomp policy files for each sandboxed
device. Because some syscalls vary by architecture, the seccomp policies are
split by architecture.</li>
<li><code>sync</code> - Our version of <code>std::sync::Mutex</code> and <code>std::sync::Condvar</code>.</li>
<li><code>sys_util</code> - Mostly safe wrappers for small system facilities such as
<code>eventfd</code> or <code>syslog</code>.</li>
<li><code>third_party</code> - Third-party libraries which we are maintaining on the Chrome
OS tree or the AOSP tree.</li>
<li><code>vfio_sys</code> - Low-level (mostly) auto-generated structures, constants and
ioctls for <a href="https://www.kernel.org/doc/html/latest/driver-api/vfio.html">VFIO</a>.</li>
<li><code>vhost</code> - Wrappers for creating vhost based devices.</li>
<li><code>virtio_sys</code> - Low-level (mostly) auto-generated structures and constants
for interfacing with kernel vhost support.</li>
<li><code>vm_control</code> - IPC for the VM.</li>
<li><code>vm_memory</code> - Vm-specific memory objects.</li>
<li><code>x86_64</code> - Support code specific to 64 bit intel machines.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="running_crosvm/devices.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="contributing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="running_crosvm/devices.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="contributing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="mermaid.min.js"></script>
        <script type="text/javascript" src="mermaid-init.js"></script>
    </body>
</html>
