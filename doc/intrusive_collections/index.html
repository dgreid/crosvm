<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Intrusive collections for Rust."><meta name="keywords" content="rust, rustlang, rust-lang, intrusive_collections"><title>intrusive_collections - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../intrusive_collections/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><h2 class="location">Crate intrusive_collections</h2><div class="block version"><div class="narrow-helper"></div><p>Version 0.9.3</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all intrusive_collections's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></div><div id="sidebar-vars" data-name="intrusive_collections" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">intrusive_collections</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/intrusive_collections/lib.rs.html#9-320" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Intrusive collections for Rust.</p>
<p>This library provides a set of high-performance intrusive collections which
can offer better performance and more flexibility than standard collections.</p>
<p>The main difference between an intrusive collection and a normal one is that
while normal collections allocate memory behind your back to keep track of a
set of <em>values</em>, intrusive collections never allocate memory themselves and
instead keep track of a set of <em>objects</em>. Such collections are called
intrusive because they requires explicit support in objects to allow them to
be inserted into a collection.</p>
<h1 id="example" class="section-header"><a href="#example">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">intrusive_collections::intrusive_adapter</span>;
<span class="kw">use</span> <span class="ident">intrusive_collections</span>::{<span class="ident">LinkedList</span>, <span class="ident">LinkedListLink</span>};
<span class="kw">use</span> <span class="ident">std::cell::Cell</span>;

<span class="comment">// A simple struct containing an instrusive link and a value</span>
<span class="kw">struct</span> <span class="ident">Test</span> {
    <span class="ident">link</span>: <span class="ident">LinkedListLink</span>,
    <span class="ident">value</span>: <span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>,
}

<span class="comment">// The adapter describes how an object can be inserted into an intrusive</span>
<span class="comment">// collection. This is automatically generated using a macro.</span>
<span class="macro">intrusive_adapter!</span>(<span class="ident">TestAdapter</span> <span class="op">=</span> <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Test</span><span class="op">&gt;</span>: <span class="ident">Test</span> { <span class="ident">link</span>: <span class="ident">LinkedListLink</span> });

<span class="comment">// Create a list and some objects</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">list</span> <span class="op">=</span> <span class="ident">LinkedList::new</span>(<span class="ident">TestAdapter::new</span>());
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">Box::new</span>(<span class="ident">Test</span> {
    <span class="ident">link</span>: <span class="ident">LinkedListLink::new</span>(),
    <span class="ident">value</span>: <span class="ident">Cell::new</span>(<span class="number">1</span>),
});
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">Box::new</span>(<span class="ident">Test</span> {
    <span class="ident">link</span>: <span class="ident">LinkedListLink::new</span>(),
    <span class="ident">value</span>: <span class="ident">Cell::new</span>(<span class="number">2</span>),
});
<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">Box::new</span>(<span class="ident">Test</span> {
    <span class="ident">link</span>: <span class="ident">LinkedListLink::new</span>(),
    <span class="ident">value</span>: <span class="ident">Cell::new</span>(<span class="number">3</span>),
});

<span class="comment">// Insert the objects at the front of the list</span>
<span class="ident">list</span>.<span class="ident">push_front</span>(<span class="ident">a</span>);
<span class="ident">list</span>.<span class="ident">push_front</span>(<span class="ident">b</span>);
<span class="ident">list</span>.<span class="ident">push_front</span>(<span class="ident">c</span>);
<span class="macro">assert_eq!</span>(<span class="ident">list</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span>.<span class="ident">value</span>.<span class="ident">get</span>()).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>(), [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]);

<span class="comment">// At this point, the objects are owned by the list, and we can modify</span>
<span class="comment">// them through the list.</span>
<span class="ident">list</span>.<span class="ident">front</span>().<span class="ident">get</span>().<span class="ident">unwrap</span>().<span class="ident">value</span>.<span class="ident">set</span>(<span class="number">4</span>);
<span class="macro">assert_eq!</span>(<span class="ident">list</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span>.<span class="ident">value</span>.<span class="ident">get</span>()).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>(), [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]);

<span class="comment">// Removing an object from an instrusive collection gives us back the</span>
<span class="comment">// Box&lt;Test&gt; that we originally inserted into it.</span>
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">list</span>.<span class="ident">pop_front</span>().<span class="ident">unwrap</span>();
<span class="macro">assert_eq!</span>(<span class="ident">a</span>.<span class="ident">value</span>.<span class="ident">get</span>(), <span class="number">4</span>);
<span class="macro">assert_eq!</span>(<span class="ident">list</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span>.<span class="ident">value</span>.<span class="ident">get</span>()).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>(), [<span class="number">2</span>, <span class="number">1</span>]);

<span class="comment">// Dropping the collection will automatically free b and c by</span>
<span class="comment">// transforming them back into Box&lt;Test&gt; and dropping them.</span>
<span class="ident">drop</span>(<span class="ident">list</span>);</code></pre></div>
<h1 id="links-and-adapters" class="section-header"><a href="#links-and-adapters">Links and adapters</a></h1>
<p>Intrusive collections track objects through links which are embedded within
the objects themselves. It also allows a single object to be part of
multiple intrusive collections at once by having multiple links in it.</p>
<p>The relationship between an object and a link inside it is described by the
<code>Adapter</code> trait. Intrusive collections use an implementation of this trait
to determine which link in an object should be used by the collection. In
most cases you do not need to write an implementation manually: the
<code>intrusive_adapter!</code> macro will automatically generate the necessary code.</p>
<p>For red-black trees, the adapter must also implement the <code>KeyAdapter</code> trait
which allows a key to be extracted from an object. This key is then used to
keep all elements in the tree in ascending order.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">intrusive_collections::intrusive_adapter</span>;
<span class="kw">use</span> <span class="ident">intrusive_collections</span>::{<span class="ident">SinglyLinkedListLink</span>, <span class="ident">SinglyLinkedList</span>};
<span class="kw">use</span> <span class="ident">intrusive_collections</span>::{<span class="ident">LinkedListLink</span>, <span class="ident">LinkedList</span>};
<span class="kw">use</span> <span class="ident">intrusive_collections</span>::{<span class="ident">XorLinkedList</span>, <span class="ident">XorLinkedListLink</span>};
<span class="kw">use</span> <span class="ident">intrusive_collections</span>::{<span class="ident">RBTreeLink</span>, <span class="ident">RBTree</span>, <span class="ident">KeyAdapter</span>};
<span class="kw">use</span> <span class="ident">std::rc::Rc</span>;

<span class="comment">// This struct can be inside three lists and one tree simultaneously</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Default</span>)]</span>
<span class="kw">struct</span> <span class="ident">Test</span> {
    <span class="ident">link</span>: <span class="ident">LinkedListLink</span>,
    <span class="ident">link2</span>: <span class="ident">SinglyLinkedListLink</span>,
    <span class="ident">link3</span>: <span class="ident">XorLinkedListLink</span>,
    <span class="ident">link4</span>: <span class="ident">RBTreeLink</span>,
    <span class="ident">value</span>: <span class="ident">i32</span>,
}

<span class="macro">intrusive_adapter!</span>(<span class="ident">MyAdapter</span> <span class="op">=</span> <span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Test</span><span class="op">&gt;</span>: <span class="ident">Test</span> { <span class="ident">link</span>: <span class="ident">LinkedListLink</span> });
<span class="macro">intrusive_adapter!</span>(<span class="ident">MyAdapter2</span> <span class="op">=</span> <span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Test</span><span class="op">&gt;</span>: <span class="ident">Test</span> { <span class="ident">link2</span>: <span class="ident">SinglyLinkedListLink</span> });
<span class="macro">intrusive_adapter!</span>(<span class="ident">MyAdapter3</span> <span class="op">=</span> <span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Test</span><span class="op">&gt;</span>: <span class="ident">Test</span> { <span class="ident">link3</span>: <span class="ident">XorLinkedListLink</span> });
<span class="macro">intrusive_adapter!</span>(<span class="ident">MyAdapter4</span> <span class="op">=</span> <span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Test</span><span class="op">&gt;</span>: <span class="ident">Test</span> { <span class="ident">link4</span>: <span class="ident">RBTreeLink</span> });
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">KeyAdapter</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">MyAdapter4</span> {
    <span class="kw">type</span> <span class="ident">Key</span> <span class="op">=</span> <span class="ident">i32</span>;
    <span class="kw">fn</span> <span class="ident">get_key</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">Test</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">i32</span> { <span class="ident">x</span>.<span class="ident">value</span> }
}

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">LinkedList::new</span>(<span class="ident">MyAdapter::new</span>());
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">SinglyLinkedList::new</span>(<span class="ident">MyAdapter2::new</span>());
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">XorLinkedList::new</span>(<span class="ident">MyAdapter3::new</span>());
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">d</span> <span class="op">=</span> <span class="ident">RBTree::new</span>(<span class="ident">MyAdapter4::new</span>());

<span class="kw">let</span> <span class="ident">test</span> <span class="op">=</span> <span class="ident">Rc::new</span>(<span class="ident">Test::default</span>());
<span class="ident">a</span>.<span class="ident">push_front</span>(<span class="ident">test</span>.<span class="ident">clone</span>());
<span class="ident">b</span>.<span class="ident">push_front</span>(<span class="ident">test</span>.<span class="ident">clone</span>());
<span class="ident">c</span>.<span class="ident">push_front</span>(<span class="ident">test</span>.<span class="ident">clone</span>());
<span class="ident">d</span>.<span class="ident">insert</span>(<span class="ident">test</span>);</code></pre></div>
<h1 id="cursors" class="section-header"><a href="#cursors">Cursors</a></h1>
<p>Intrusive collections are manipulated using cursors. A cursor is similar to
an iterator, except that it can freely seek back-and-forth, and can safely
mutate the list during iteration. This is similar to how a C++ iterator
works.</p>
<p>A cursor views an intrusive collection as a circular list, with a special
null object between the last and first elements of the collection. A cursor
will either point to a valid object in the collection or to this special
null object.</p>
<p>Cursors come in two forms: <code>Cursor</code> and <code>CursorMut</code>. A <code>Cursor</code> gives a
read-only view of a collection, but you are allowed to use multiple <code>Cursor</code>
objects simultaneously on the same collection. On the other hand,
<code>CursorMut</code> can be used to mutate the collection, but you may only use one
of them at a time.</p>
<p>Cursors are a very powerful abstraction since they allow a collection to be
mutated safely while it is being iterated on. For example, here is a
function which removes all values within a given range from a <code>RBTree</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">intrusive_collections::intrusive_adapter</span>;
<span class="kw">use</span> <span class="ident">intrusive_collections</span>::{<span class="ident">RBTreeLink</span>, <span class="ident">RBTree</span>, <span class="ident">KeyAdapter</span>, <span class="ident">Bound</span>};

<span class="kw">struct</span> <span class="ident">Element</span> {
    <span class="ident">link</span>: <span class="ident">RBTreeLink</span>,
    <span class="ident">value</span>: <span class="ident">i32</span>,
}

<span class="macro">intrusive_adapter!</span>(<span class="ident">ElementAdapter</span> <span class="op">=</span> <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Element</span><span class="op">&gt;</span>: <span class="ident">Element</span> { <span class="ident">link</span>: <span class="ident">RBTreeLink</span> });
<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">KeyAdapter</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">ElementAdapter</span> {
    <span class="kw">type</span> <span class="ident">Key</span> <span class="op">=</span> <span class="ident">i32</span>;
    <span class="kw">fn</span> <span class="ident">get_key</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">e</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">Element</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">i32</span> { <span class="ident">e</span>.<span class="ident">value</span> }
}

<span class="kw">fn</span> <span class="ident">remove_range</span>(<span class="ident">tree</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">RBTree</span><span class="op">&lt;</span><span class="ident">ElementAdapter</span><span class="op">&gt;</span>, <span class="ident">min</span>: <span class="ident">i32</span>, <span class="ident">max</span>: <span class="ident">i32</span>) {
    <span class="comment">// Find the first element which is greater than or equal to min</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cursor</span> <span class="op">=</span> <span class="ident">tree</span>.<span class="ident">lower_bound_mut</span>(<span class="ident">Bound::Included</span>(<span class="kw-2">&amp;</span><span class="ident">min</span>));

    <span class="comment">// Iterate over all elements in the range [min, max]</span>
    <span class="kw">while</span> <span class="ident">cursor</span>.<span class="ident">get</span>().<span class="ident">map_or</span>(<span class="bool-val">false</span>, <span class="op">|</span><span class="ident">e</span><span class="op">|</span> <span class="ident">e</span>.<span class="ident">value</span> <span class="op">&lt;</span><span class="op">=</span> <span class="ident">max</span>) {
        <span class="comment">// CursorMut::remove will return a Some(&lt;Box&lt;Element&gt;), which we</span>
        <span class="comment">// simply drop here. This will also advance the cursor to the next</span>
        <span class="comment">// element.</span>
        <span class="ident">cursor</span>.<span class="ident">remove</span>();
    }
}</code></pre></div>
<h1 id="scoped-collections" class="section-header"><a href="#scoped-collections">Scoped collections</a></h1>
<p>Instead of taking ownership of objects inserted into them, intrusive
collections can also work with borrowed values. This works by using
lifetimes and the borrow checker to ensure that any objects inserted into an
intrusive collection will outlive the collection itself.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">intrusive_collections::intrusive_adapter</span>;
<span class="kw">use</span> <span class="ident">intrusive_collections</span>::{<span class="ident">LinkedListLink</span>, <span class="ident">LinkedList</span>};
<span class="kw">use</span> <span class="ident">typed_arena::Arena</span>;
<span class="kw">use</span> <span class="ident">std::cell::Cell</span>;

<span class="kw">struct</span> <span class="ident">Value</span> {
    <span class="ident">link</span>: <span class="ident">LinkedListLink</span>,
    <span class="ident">value</span>: <span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>,
}

<span class="comment">// Note that we use a plain reference as the pointer type for the collection.</span>
<span class="macro">intrusive_adapter!</span>(<span class="ident">ValueAdapter</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">Value</span>: <span class="ident">Value</span> { <span class="ident">link</span>: <span class="ident">LinkedListLink</span> });

<span class="comment">// Create an arena and a list. Note that since stack objects are dropped in</span>
<span class="comment">// reverse order, the Arena must be created before the LinkedList. This</span>
<span class="comment">// ensures that the list is dropped before the values are freed by the</span>
<span class="comment">// arena. This is enforced by the Rust lifetime system.</span>
<span class="kw">let</span> <span class="ident">arena</span> <span class="op">=</span> <span class="ident">Arena::new</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">list</span> <span class="op">=</span> <span class="ident">LinkedList::new</span>(<span class="ident">ValueAdapter::new</span>());

<span class="comment">// We can now insert values allocated from the arena into the linked list</span>
<span class="ident">list</span>.<span class="ident">push_back</span>(<span class="ident">arena</span>.<span class="ident">alloc</span>(<span class="ident">Value</span> {
    <span class="ident">link</span>: <span class="ident">LinkedListLink::new</span>(),
    <span class="ident">value</span>: <span class="ident">Cell::new</span>(<span class="number">1</span>),
}));
<span class="ident">list</span>.<span class="ident">push_back</span>(<span class="ident">arena</span>.<span class="ident">alloc</span>(<span class="ident">Value</span> {
    <span class="ident">link</span>: <span class="ident">LinkedListLink::new</span>(),
    <span class="ident">value</span>: <span class="ident">Cell::new</span>(<span class="number">2</span>),
}));
<span class="ident">list</span>.<span class="ident">push_back</span>(<span class="ident">arena</span>.<span class="ident">alloc</span>(<span class="ident">Value</span> {
    <span class="ident">link</span>: <span class="ident">LinkedListLink::new</span>(),
    <span class="ident">value</span>: <span class="ident">Cell::new</span>(<span class="number">3</span>),
}));
<span class="macro">assert_eq!</span>(<span class="ident">list</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span>.<span class="ident">value</span>.<span class="ident">get</span>()).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>(), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);

<span class="comment">// We can also insert stack allocated values into an intrusive list.</span>
<span class="comment">// Again, the values must outlive the LinkedList.</span>
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">Value</span> {
    <span class="ident">link</span>: <span class="ident">LinkedListLink::new</span>(),
    <span class="ident">value</span>: <span class="ident">Cell::new</span>(<span class="number">4</span>),
};
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">Value</span> {
    <span class="ident">link</span>: <span class="ident">LinkedListLink::new</span>(),
    <span class="ident">value</span>: <span class="ident">Cell::new</span>(<span class="number">5</span>),
};
<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">Value</span> {
    <span class="ident">link</span>: <span class="ident">LinkedListLink::new</span>(),
    <span class="ident">value</span>: <span class="ident">Cell::new</span>(<span class="number">6</span>),
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">list2</span> <span class="op">=</span> <span class="ident">LinkedList::new</span>(<span class="ident">ValueAdapter::new</span>());
<span class="ident">list2</span>.<span class="ident">push_back</span>(<span class="kw-2">&amp;</span><span class="ident">a</span>);
<span class="ident">list2</span>.<span class="ident">push_back</span>(<span class="kw-2">&amp;</span><span class="ident">b</span>);
<span class="ident">list2</span>.<span class="ident">push_back</span>(<span class="kw-2">&amp;</span><span class="ident">c</span>);
<span class="macro">assert_eq!</span>(<span class="ident">list2</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span>.<span class="ident">value</span>.<span class="ident">get</span>()).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>(), [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);

<span class="comment">// Since these are shared references, any changes in the values are reflected in</span>
<span class="comment">// the list.</span>
<span class="ident">a</span>.<span class="ident">value</span>.<span class="ident">set</span>(<span class="number">7</span>);
<span class="macro">assert_eq!</span>(<span class="ident">list2</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span>.<span class="ident">value</span>.<span class="ident">get</span>()).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>(), [<span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>]);</code></pre></div>
<h1 id="safety" class="section-header"><a href="#safety">Safety</a></h1>
<p>While it is possible to use intrusive collections without any unsafe code,
this crate also exposes a few unsafe features.</p>
<p>The <code>cursor_from_ptr</code> and <code>cursor_mut_from_ptr</code> allow you to create a
cursor pointing to a specific element in the collection from a pointer to
that element. This is unsafe because it assumes that the objected pointed to
is currently inserted in the collection.</p>
<p>The <code>UnsafeRef</code> type acts like <code>Rc</code>, except without the reference count.
Instead, you are responsible for keeping track of the number of active
references to an object and for freeing it once the last reference is
dropped. The advantage of <code>UnsafeRef</code> over <code>Rc</code> is that it reduces the size
of the allocation by two <code>usize</code> and avoids the overhead of maintaining
reference counts.</p>
</div></details><h2 id="reexports" class="section-header"><a href="#reexports">Re-exports</a></h2>
<div class="item-table"><div class="item-left import-item"><code>pub use crate::linked_list::<a class="struct" href="linked_list/struct.AtomicLink.html" title="struct intrusive_collections::linked_list::AtomicLink">AtomicLink</a> as LinkedListAtomicLink;</code></div><div class="item-right docblock-short"></div><div class="item-left import-item"><code>pub use crate::linked_list::<a class="struct" href="linked_list/struct.Link.html" title="struct intrusive_collections::linked_list::Link">Link</a> as LinkedListLink;</code></div><div class="item-right docblock-short"></div><div class="item-left import-item"><code>pub use crate::linked_list::<a class="struct" href="linked_list/struct.LinkedList.html" title="struct intrusive_collections::linked_list::LinkedList">LinkedList</a>;</code></div><div class="item-right docblock-short"></div><div class="item-left import-item"><code>pub use crate::rbtree::<a class="struct" href="rbtree/struct.AtomicLink.html" title="struct intrusive_collections::rbtree::AtomicLink">AtomicLink</a> as RBTreeAtomicLink;</code></div><div class="item-right docblock-short"></div><div class="item-left import-item"><code>pub use crate::rbtree::<a class="struct" href="rbtree/struct.Link.html" title="struct intrusive_collections::rbtree::Link">Link</a> as RBTreeLink;</code></div><div class="item-right docblock-short"></div><div class="item-left import-item"><code>pub use crate::rbtree::<a class="struct" href="rbtree/struct.RBTree.html" title="struct intrusive_collections::rbtree::RBTree">RBTree</a>;</code></div><div class="item-right docblock-short"></div><div class="item-left import-item"><code>pub use crate::singly_linked_list::<a class="struct" href="singly_linked_list/struct.AtomicLink.html" title="struct intrusive_collections::singly_linked_list::AtomicLink">AtomicLink</a> as SinglyLinkedListAtomicLink;</code></div><div class="item-right docblock-short"></div><div class="item-left import-item"><code>pub use crate::singly_linked_list::<a class="struct" href="singly_linked_list/struct.Link.html" title="struct intrusive_collections::singly_linked_list::Link">Link</a> as SinglyLinkedListLink;</code></div><div class="item-right docblock-short"></div><div class="item-left import-item"><code>pub use crate::singly_linked_list::<a class="struct" href="singly_linked_list/struct.SinglyLinkedList.html" title="struct intrusive_collections::singly_linked_list::SinglyLinkedList">SinglyLinkedList</a>;</code></div><div class="item-right docblock-short"></div><div class="item-left import-item"><code>pub use crate::xor_linked_list::<a class="struct" href="xor_linked_list/struct.AtomicLink.html" title="struct intrusive_collections::xor_linked_list::AtomicLink">AtomicLink</a> as XorLinkedListAtomicLink;</code></div><div class="item-right docblock-short"></div><div class="item-left import-item"><code>pub use crate::xor_linked_list::<a class="struct" href="xor_linked_list/struct.Link.html" title="struct intrusive_collections::xor_linked_list::Link">Link</a> as XorLinkedListLink;</code></div><div class="item-right docblock-short"></div><div class="item-left import-item"><code>pub use crate::xor_linked_list::<a class="struct" href="xor_linked_list/struct.XorLinkedList.html" title="struct intrusive_collections::xor_linked_list::XorLinkedList">XorLinkedList</a>;</code></div><div class="item-right docblock-short"></div></div><h2 id="modules" class="section-header"><a href="#modules">Modules</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="mod" href="linked_list/index.html" title="intrusive_collections::linked_list mod">linked_list</a></div><div class="item-right docblock-short"><p>Intrusive doubly-linked list.</p>
</div><div class="item-left module-item"><a class="mod" href="rbtree/index.html" title="intrusive_collections::rbtree mod">rbtree</a></div><div class="item-right docblock-short"><p>Intrusive red-black tree.</p>
</div><div class="item-left module-item"><a class="mod" href="singly_linked_list/index.html" title="intrusive_collections::singly_linked_list mod">singly_linked_list</a></div><div class="item-right docblock-short"><p>Intrusive singly-linked list.</p>
</div><div class="item-left module-item"><a class="mod" href="xor_linked_list/index.html" title="intrusive_collections::xor_linked_list mod">xor_linked_list</a></div><div class="item-right docblock-short"><p>Intrusive xor doubly-linked list which uses less memory than a regular doubly linked list.</p>
</div></div><h2 id="macros" class="section-header"><a href="#macros">Macros</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="macro" href="macro.container_of.html" title="intrusive_collections::container_of macro">container_of</a></div><div class="item-right docblock-short"><p>Unsafe macro to get a raw pointer to an outer object from a pointer to one
of its fields.</p>
</div><div class="item-left module-item"><a class="macro" href="macro.intrusive_adapter.html" title="intrusive_collections::intrusive_adapter macro">intrusive_adapter</a></div><div class="item-right docblock-short"><p>Macro to generate an implementation of <code>Adapter</code> for a given set of types.
In particular this will automatically generate implementations of the
<code>get_value</code> and <code>get_link</code> methods for a given named field in a struct.</p>
</div><div class="item-left module-item"><a class="macro" href="macro.offset_of.html" title="intrusive_collections::offset_of macro">offset_of</a></div><div class="item-right docblock-short"><p>Calculates the offset of the specified field from the start of the struct.</p>
</div></div><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="struct" href="struct.DefaultPointerOps.html" title="intrusive_collections::DefaultPointerOps struct">DefaultPointerOps</a></div><div class="item-right docblock-short"><p>The <code>PointerOps</code> type used by an <code>Adapter</code> generated by <code>intrusive_adapter!</code>.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.UnsafeRef.html" title="intrusive_collections::UnsafeRef struct">UnsafeRef</a></div><div class="item-right docblock-short"><p>Unchecked shared pointer</p>
</div></div><h2 id="enums" class="section-header"><a href="#enums">Enums</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="enum" href="enum.Bound.html" title="intrusive_collections::Bound enum">Bound</a></div><div class="item-right docblock-short"><p>An endpoint of a range of keys.</p>
</div></div><h2 id="traits" class="section-header"><a href="#traits">Traits</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="trait" href="trait.Adapter.html" title="intrusive_collections::Adapter trait">Adapter</a></div><div class="item-right docblock-short"><p>Trait for a adapter which allows a type to be inserted into an intrusive
collection.</p>
</div><div class="item-left module-item"><a class="trait" href="trait.DefaultLinkOps.html" title="intrusive_collections::DefaultLinkOps trait">DefaultLinkOps</a></div><div class="item-right docblock-short"><p>The default implementation of <code>LinkOps</code> associated with a link type.</p>
</div><div class="item-left module-item"><a class="trait" href="trait.KeyAdapter.html" title="intrusive_collections::KeyAdapter trait">KeyAdapter</a></div><div class="item-right docblock-short"><p>Extension of the <code>Adapter</code> trait to provide a way of extracting a key from
an object. This key can then be used as an index in certain intrusive
collections (currently only <code>RBTree</code> uses this).</p>
</div><div class="item-left module-item"><a class="trait" href="trait.LinkOps.html" title="intrusive_collections::LinkOps trait">LinkOps</a></div><div class="item-right docblock-short"><p>Base trait for link operations.</p>
</div><div class="item-left module-item"><a class="trait" href="trait.PointerOps.html" title="intrusive_collections::PointerOps trait">PointerOps</a></div><div class="item-right docblock-short"><p>Trait for pointer conversion operations.</p>
</div></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="intrusive_collections" data-search-index-js="../search-index.js" data-search-js="../search.js"></div>
    <script src="../main.js"></script>
</body></html>