/* automatically generated by rust-bindgen */
/* bindgen --with-derive-default include/uapi/linux/aio_abi.h
 * __kernel_rwf_t had to be replaced with int
 * Then delete everything that isn't needed.
 * TODO(dgreid) - this is x86_64 only, need to do other arches */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

use std::os::unix::io::RawFd;
use std::ptr::null;

use crate::{errno_result, Result};

use libc::{c_long, c_void, syscall, timespec};
use syscall_defines::linux::LinuxSyscall::{
    SYS_io_destroy, SYS_io_getevents, SYS_io_setup, SYS_io_submit,
};

pub type aio_context_t = ::std::os::raw::c_ulong;
pub const IOCB_CMD_PREAD: u32 = 0;
pub const IOCB_CMD_PWRITE: u32 = 1;
pub const IOCB_CMD_FSYNC: u32 = 2;
pub const IOCB_CMD_FDSYNC: u32 = 3;
pub const IOCB_CMD_POLL: u32 = 5;
pub const IOCB_CMD_NOOP: u32 = 6;
pub const IOCB_CMD_PREADV: u32 = 7;
pub const IOCB_CMD_PWRITEV: u32 = 8;

#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct io_event {
    pub data: u64,
    pub obj: u64,
    pub res: i64,
    pub res2: i64,
}

#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct iocb {
    pub aio_data: u64,
    pub aio_key: u32,
    pub aio_rw_flags: ::std::os::raw::c_int,
    pub aio_lio_opcode: u16,
    pub aio_reqprio: i16,
    pub aio_fildes: u32,
    pub aio_buf: u64,
    pub aio_nbytes: u64,
    pub aio_offset: i64,
    pub aio_reserved2: u64,
    pub aio_flags: u32,
    pub aio_resfd: u32,
}

pub fn poll_iocb(token: u64, fd: RawFd, flag_events: u64) -> iocb {
    let mut cb: iocb = Default::default();
    cb.aio_lio_opcode = IOCB_CMD_POLL as u16;
    cb.aio_data = token;
    cb.aio_buf = flag_events;
    cb.aio_fildes = fd as u32;
    cb
}

// Wrapper around the io_setup syscall.
pub fn io_setup(max_events: usize) -> Result<aio_context_t> {
    let context: aio_context_t = Default::default();
    unsafe {
        // Safe because the kernel is trusted to only touch the memory owned by `context`.
        let ret = libc::syscall(
            SYS_io_setup as c_long,
            max_events,
            &context as *const _ as *mut c_void,
        );
        if ret < 0 {
            return errno_result();
        }
    }
    Ok(context)
}

// Wrapper around io_submit syscall.
// To use io_submit safely, the callbacks passed in must write to only areas of memory that they own
// exclusively or memory contained within a volatile slice.
pub unsafe fn io_submit(context: aio_context_t, cbs: &[iocb]) -> Result<()> {
    // TODO MaybeUninit
    let mut cb_ptrs = [null(); 128]; // TODO - don't limit this to 128?.
    for (ptr, cb) in cb_ptrs.iter_mut().zip(cbs.iter()) {
        *ptr = cb as *const _ as *const c_void;
    }
    let ret = libc::syscall(
        SYS_io_submit as c_long,
        context,
        cbs.len() as c_long,
        &cb_ptrs as *const _ as *const *const iocb,
    );
    if ret < 0 {
        return errno_result();
    }
    Ok(())
}

// Wrapper around io_getevents.
// Only support blocking mode, polling is not supported.
pub fn io_getevents(context: aio_context_t, events: &mut [io_event]) -> Result<usize> {
    unsafe {
        // Safe becuase the kernel is trusted to only write within io_events.
        let ret = syscall(
            SYS_io_getevents as c_long,
            context,
            1,
            events.len(),
            events.as_mut_ptr() as *mut io_event,
            null::<timespec>(),
        );
        if ret < 0 {
            return errno_result();
        }
        Ok(ret as usize)
    }
}

// Destroys a context create with `io_submit`.
pub fn io_destroy(context: aio_context_t) {
    unsafe {
        // Safe because the context can't be accessed after drop, making it OK for the kernel to
        // destroy it.
        syscall(SYS_io_destroy as c_long, context);
    }
}
