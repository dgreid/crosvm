// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `plugin.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
pub struct CpuidEntry {
    // message fields
    pub function: u32,
    pub has_index: bool,
    pub index: u32,
    pub eax: u32,
    pub ebx: u32,
    pub ecx: u32,
    pub edx: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CpuidEntry {
    fn default() -> &'a CpuidEntry {
        <CpuidEntry as ::protobuf::Message>::default_instance()
    }
}

impl CpuidEntry {
    pub fn new() -> CpuidEntry {
        ::std::default::Default::default()
    }

    // uint32 function = 1;


    pub fn get_function(&self) -> u32 {
        self.function
    }
    pub fn clear_function(&mut self) {
        self.function = 0;
    }

    // Param is passed by value, moved
    pub fn set_function(&mut self, v: u32) {
        self.function = v;
    }

    // bool has_index = 3;


    pub fn get_has_index(&self) -> bool {
        self.has_index
    }
    pub fn clear_has_index(&mut self) {
        self.has_index = false;
    }

    // Param is passed by value, moved
    pub fn set_has_index(&mut self, v: bool) {
        self.has_index = v;
    }

    // uint32 index = 4;


    pub fn get_index(&self) -> u32 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = v;
    }

    // uint32 eax = 5;


    pub fn get_eax(&self) -> u32 {
        self.eax
    }
    pub fn clear_eax(&mut self) {
        self.eax = 0;
    }

    // Param is passed by value, moved
    pub fn set_eax(&mut self, v: u32) {
        self.eax = v;
    }

    // uint32 ebx = 6;


    pub fn get_ebx(&self) -> u32 {
        self.ebx
    }
    pub fn clear_ebx(&mut self) {
        self.ebx = 0;
    }

    // Param is passed by value, moved
    pub fn set_ebx(&mut self, v: u32) {
        self.ebx = v;
    }

    // uint32 ecx = 7;


    pub fn get_ecx(&self) -> u32 {
        self.ecx
    }
    pub fn clear_ecx(&mut self) {
        self.ecx = 0;
    }

    // Param is passed by value, moved
    pub fn set_ecx(&mut self, v: u32) {
        self.ecx = v;
    }

    // uint32 edx = 8;


    pub fn get_edx(&self) -> u32 {
        self.edx
    }
    pub fn clear_edx(&mut self) {
        self.edx = 0;
    }

    // Param is passed by value, moved
    pub fn set_edx(&mut self, v: u32) {
        self.edx = v;
    }
}

impl ::protobuf::Message for CpuidEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.function = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_index = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.index = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eax = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ebx = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ecx = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.edx = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.function != 0 {
            my_size += ::protobuf::rt::value_size(1, self.function, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.has_index != false {
            my_size += 2;
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(4, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.eax != 0 {
            my_size += ::protobuf::rt::value_size(5, self.eax, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ebx != 0 {
            my_size += ::protobuf::rt::value_size(6, self.ebx, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ecx != 0 {
            my_size += ::protobuf::rt::value_size(7, self.ecx, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.edx != 0 {
            my_size += ::protobuf::rt::value_size(8, self.edx, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.function != 0 {
            os.write_uint32(1, self.function)?;
        }
        if self.has_index != false {
            os.write_bool(3, self.has_index)?;
        }
        if self.index != 0 {
            os.write_uint32(4, self.index)?;
        }
        if self.eax != 0 {
            os.write_uint32(5, self.eax)?;
        }
        if self.ebx != 0 {
            os.write_uint32(6, self.ebx)?;
        }
        if self.ecx != 0 {
            os.write_uint32(7, self.ecx)?;
        }
        if self.edx != 0 {
            os.write_uint32(8, self.edx)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CpuidEntry {
        CpuidEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "function",
                |m: &CpuidEntry| { &m.function },
                |m: &mut CpuidEntry| { &mut m.function },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_index",
                |m: &CpuidEntry| { &m.has_index },
                |m: &mut CpuidEntry| { &mut m.has_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "index",
                |m: &CpuidEntry| { &m.index },
                |m: &mut CpuidEntry| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "eax",
                |m: &CpuidEntry| { &m.eax },
                |m: &mut CpuidEntry| { &mut m.eax },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ebx",
                |m: &CpuidEntry| { &m.ebx },
                |m: &mut CpuidEntry| { &mut m.ebx },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ecx",
                |m: &CpuidEntry| { &m.ecx },
                |m: &mut CpuidEntry| { &mut m.ecx },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "edx",
                |m: &CpuidEntry| { &m.edx },
                |m: &mut CpuidEntry| { &mut m.edx },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CpuidEntry>(
                "CpuidEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CpuidEntry {
        static instance: ::protobuf::rt::LazyV2<CpuidEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CpuidEntry::new)
    }
}

impl ::protobuf::Clear for CpuidEntry {
    fn clear(&mut self) {
        self.function = 0;
        self.has_index = false;
        self.index = 0;
        self.eax = 0;
        self.ebx = 0;
        self.ecx = 0;
        self.edx = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CpuidEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CpuidEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainRequest {
    // message oneof groups
    pub message: ::std::option::Option<MainRequest_oneof_message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainRequest {
    fn default() -> &'a MainRequest {
        <MainRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum MainRequest_oneof_message {
    create(MainRequest_Create),
    destroy(MainRequest_Destroy),
    new_connection(MainRequest_NewConnection),
    get_shutdown_eventfd(MainRequest_GetShutdownEventfd),
    check_extension(MainRequest_CheckExtension),
    get_supported_cpuid(MainRequest_CpuidRequest),
    get_emulated_cpuid(MainRequest_CpuidRequest),
    get_msr_index_list(MainRequest_MsrListRequest),
    get_net_config(MainRequest_GetNetConfig),
    reserve_range(MainRequest_ReserveRange),
    set_irq(MainRequest_SetIrq),
    set_irq_routing(MainRequest_SetIrqRouting),
    get_state(MainRequest_GetState),
    set_state(MainRequest_SetState),
    set_identity_map_addr(MainRequest_SetIdentityMapAddr),
    pause_vcpus(MainRequest_PauseVcpus),
    get_vcpus(MainRequest_GetVcpus),
    start(MainRequest_Start),
    set_call_hint(MainRequest_SetCallHint),
    dirty_log(MainRequest_MemoryDirtyLog),
}

impl MainRequest {
    pub fn new() -> MainRequest {
        ::std::default::Default::default()
    }

    // .MainRequest.Create create = 1;


    pub fn get_create(&self) -> &MainRequest_Create {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::create(ref v)) => v,
            _ => <MainRequest_Create as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_create(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_create(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::create(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create(&mut self, v: MainRequest_Create) {
        self.message = ::std::option::Option::Some(MainRequest_oneof_message::create(v))
    }

    // Mutable pointer to the field.
    pub fn mut_create(&mut self) -> &mut MainRequest_Create {
        if let ::std::option::Option::Some(MainRequest_oneof_message::create(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainRequest_oneof_message::create(MainRequest_Create::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::create(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_create(&mut self) -> MainRequest_Create {
        if self.has_create() {
            match self.message.take() {
                ::std::option::Option::Some(MainRequest_oneof_message::create(v)) => v,
                _ => panic!(),
            }
        } else {
            MainRequest_Create::new()
        }
    }

    // .MainRequest.Destroy destroy = 2;


    pub fn get_destroy(&self) -> &MainRequest_Destroy {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::destroy(ref v)) => v,
            _ => <MainRequest_Destroy as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_destroy(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_destroy(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::destroy(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_destroy(&mut self, v: MainRequest_Destroy) {
        self.message = ::std::option::Option::Some(MainRequest_oneof_message::destroy(v))
    }

    // Mutable pointer to the field.
    pub fn mut_destroy(&mut self) -> &mut MainRequest_Destroy {
        if let ::std::option::Option::Some(MainRequest_oneof_message::destroy(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainRequest_oneof_message::destroy(MainRequest_Destroy::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::destroy(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_destroy(&mut self) -> MainRequest_Destroy {
        if self.has_destroy() {
            match self.message.take() {
                ::std::option::Option::Some(MainRequest_oneof_message::destroy(v)) => v,
                _ => panic!(),
            }
        } else {
            MainRequest_Destroy::new()
        }
    }

    // .MainRequest.NewConnection new_connection = 3;


    pub fn get_new_connection(&self) -> &MainRequest_NewConnection {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::new_connection(ref v)) => v,
            _ => <MainRequest_NewConnection as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_new_connection(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_new_connection(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::new_connection(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_new_connection(&mut self, v: MainRequest_NewConnection) {
        self.message = ::std::option::Option::Some(MainRequest_oneof_message::new_connection(v))
    }

    // Mutable pointer to the field.
    pub fn mut_new_connection(&mut self) -> &mut MainRequest_NewConnection {
        if let ::std::option::Option::Some(MainRequest_oneof_message::new_connection(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainRequest_oneof_message::new_connection(MainRequest_NewConnection::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::new_connection(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_new_connection(&mut self) -> MainRequest_NewConnection {
        if self.has_new_connection() {
            match self.message.take() {
                ::std::option::Option::Some(MainRequest_oneof_message::new_connection(v)) => v,
                _ => panic!(),
            }
        } else {
            MainRequest_NewConnection::new()
        }
    }

    // .MainRequest.GetShutdownEventfd get_shutdown_eventfd = 4;


    pub fn get_get_shutdown_eventfd(&self) -> &MainRequest_GetShutdownEventfd {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::get_shutdown_eventfd(ref v)) => v,
            _ => <MainRequest_GetShutdownEventfd as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_get_shutdown_eventfd(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_shutdown_eventfd(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::get_shutdown_eventfd(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_shutdown_eventfd(&mut self, v: MainRequest_GetShutdownEventfd) {
        self.message = ::std::option::Option::Some(MainRequest_oneof_message::get_shutdown_eventfd(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_shutdown_eventfd(&mut self) -> &mut MainRequest_GetShutdownEventfd {
        if let ::std::option::Option::Some(MainRequest_oneof_message::get_shutdown_eventfd(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainRequest_oneof_message::get_shutdown_eventfd(MainRequest_GetShutdownEventfd::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::get_shutdown_eventfd(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_shutdown_eventfd(&mut self) -> MainRequest_GetShutdownEventfd {
        if self.has_get_shutdown_eventfd() {
            match self.message.take() {
                ::std::option::Option::Some(MainRequest_oneof_message::get_shutdown_eventfd(v)) => v,
                _ => panic!(),
            }
        } else {
            MainRequest_GetShutdownEventfd::new()
        }
    }

    // .MainRequest.CheckExtension check_extension = 5;


    pub fn get_check_extension(&self) -> &MainRequest_CheckExtension {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::check_extension(ref v)) => v,
            _ => <MainRequest_CheckExtension as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_check_extension(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_check_extension(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::check_extension(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_check_extension(&mut self, v: MainRequest_CheckExtension) {
        self.message = ::std::option::Option::Some(MainRequest_oneof_message::check_extension(v))
    }

    // Mutable pointer to the field.
    pub fn mut_check_extension(&mut self) -> &mut MainRequest_CheckExtension {
        if let ::std::option::Option::Some(MainRequest_oneof_message::check_extension(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainRequest_oneof_message::check_extension(MainRequest_CheckExtension::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::check_extension(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_check_extension(&mut self) -> MainRequest_CheckExtension {
        if self.has_check_extension() {
            match self.message.take() {
                ::std::option::Option::Some(MainRequest_oneof_message::check_extension(v)) => v,
                _ => panic!(),
            }
        } else {
            MainRequest_CheckExtension::new()
        }
    }

    // .MainRequest.CpuidRequest get_supported_cpuid = 6;


    pub fn get_get_supported_cpuid(&self) -> &MainRequest_CpuidRequest {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::get_supported_cpuid(ref v)) => v,
            _ => <MainRequest_CpuidRequest as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_get_supported_cpuid(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_supported_cpuid(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::get_supported_cpuid(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_supported_cpuid(&mut self, v: MainRequest_CpuidRequest) {
        self.message = ::std::option::Option::Some(MainRequest_oneof_message::get_supported_cpuid(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_supported_cpuid(&mut self) -> &mut MainRequest_CpuidRequest {
        if let ::std::option::Option::Some(MainRequest_oneof_message::get_supported_cpuid(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainRequest_oneof_message::get_supported_cpuid(MainRequest_CpuidRequest::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::get_supported_cpuid(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_supported_cpuid(&mut self) -> MainRequest_CpuidRequest {
        if self.has_get_supported_cpuid() {
            match self.message.take() {
                ::std::option::Option::Some(MainRequest_oneof_message::get_supported_cpuid(v)) => v,
                _ => panic!(),
            }
        } else {
            MainRequest_CpuidRequest::new()
        }
    }

    // .MainRequest.CpuidRequest get_emulated_cpuid = 7;


    pub fn get_get_emulated_cpuid(&self) -> &MainRequest_CpuidRequest {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::get_emulated_cpuid(ref v)) => v,
            _ => <MainRequest_CpuidRequest as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_get_emulated_cpuid(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_emulated_cpuid(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::get_emulated_cpuid(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_emulated_cpuid(&mut self, v: MainRequest_CpuidRequest) {
        self.message = ::std::option::Option::Some(MainRequest_oneof_message::get_emulated_cpuid(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_emulated_cpuid(&mut self) -> &mut MainRequest_CpuidRequest {
        if let ::std::option::Option::Some(MainRequest_oneof_message::get_emulated_cpuid(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainRequest_oneof_message::get_emulated_cpuid(MainRequest_CpuidRequest::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::get_emulated_cpuid(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_emulated_cpuid(&mut self) -> MainRequest_CpuidRequest {
        if self.has_get_emulated_cpuid() {
            match self.message.take() {
                ::std::option::Option::Some(MainRequest_oneof_message::get_emulated_cpuid(v)) => v,
                _ => panic!(),
            }
        } else {
            MainRequest_CpuidRequest::new()
        }
    }

    // .MainRequest.MsrListRequest get_msr_index_list = 8;


    pub fn get_get_msr_index_list(&self) -> &MainRequest_MsrListRequest {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::get_msr_index_list(ref v)) => v,
            _ => <MainRequest_MsrListRequest as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_get_msr_index_list(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_msr_index_list(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::get_msr_index_list(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_msr_index_list(&mut self, v: MainRequest_MsrListRequest) {
        self.message = ::std::option::Option::Some(MainRequest_oneof_message::get_msr_index_list(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_msr_index_list(&mut self) -> &mut MainRequest_MsrListRequest {
        if let ::std::option::Option::Some(MainRequest_oneof_message::get_msr_index_list(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainRequest_oneof_message::get_msr_index_list(MainRequest_MsrListRequest::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::get_msr_index_list(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_msr_index_list(&mut self) -> MainRequest_MsrListRequest {
        if self.has_get_msr_index_list() {
            match self.message.take() {
                ::std::option::Option::Some(MainRequest_oneof_message::get_msr_index_list(v)) => v,
                _ => panic!(),
            }
        } else {
            MainRequest_MsrListRequest::new()
        }
    }

    // .MainRequest.GetNetConfig get_net_config = 9;


    pub fn get_get_net_config(&self) -> &MainRequest_GetNetConfig {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::get_net_config(ref v)) => v,
            _ => <MainRequest_GetNetConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_get_net_config(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_net_config(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::get_net_config(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_net_config(&mut self, v: MainRequest_GetNetConfig) {
        self.message = ::std::option::Option::Some(MainRequest_oneof_message::get_net_config(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_net_config(&mut self) -> &mut MainRequest_GetNetConfig {
        if let ::std::option::Option::Some(MainRequest_oneof_message::get_net_config(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainRequest_oneof_message::get_net_config(MainRequest_GetNetConfig::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::get_net_config(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_net_config(&mut self) -> MainRequest_GetNetConfig {
        if self.has_get_net_config() {
            match self.message.take() {
                ::std::option::Option::Some(MainRequest_oneof_message::get_net_config(v)) => v,
                _ => panic!(),
            }
        } else {
            MainRequest_GetNetConfig::new()
        }
    }

    // .MainRequest.ReserveRange reserve_range = 10;


    pub fn get_reserve_range(&self) -> &MainRequest_ReserveRange {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::reserve_range(ref v)) => v,
            _ => <MainRequest_ReserveRange as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_reserve_range(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_reserve_range(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::reserve_range(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_reserve_range(&mut self, v: MainRequest_ReserveRange) {
        self.message = ::std::option::Option::Some(MainRequest_oneof_message::reserve_range(v))
    }

    // Mutable pointer to the field.
    pub fn mut_reserve_range(&mut self) -> &mut MainRequest_ReserveRange {
        if let ::std::option::Option::Some(MainRequest_oneof_message::reserve_range(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainRequest_oneof_message::reserve_range(MainRequest_ReserveRange::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::reserve_range(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_reserve_range(&mut self) -> MainRequest_ReserveRange {
        if self.has_reserve_range() {
            match self.message.take() {
                ::std::option::Option::Some(MainRequest_oneof_message::reserve_range(v)) => v,
                _ => panic!(),
            }
        } else {
            MainRequest_ReserveRange::new()
        }
    }

    // .MainRequest.SetIrq set_irq = 11;


    pub fn get_set_irq(&self) -> &MainRequest_SetIrq {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::set_irq(ref v)) => v,
            _ => <MainRequest_SetIrq as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_set_irq(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_set_irq(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::set_irq(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_irq(&mut self, v: MainRequest_SetIrq) {
        self.message = ::std::option::Option::Some(MainRequest_oneof_message::set_irq(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_irq(&mut self) -> &mut MainRequest_SetIrq {
        if let ::std::option::Option::Some(MainRequest_oneof_message::set_irq(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainRequest_oneof_message::set_irq(MainRequest_SetIrq::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::set_irq(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_irq(&mut self) -> MainRequest_SetIrq {
        if self.has_set_irq() {
            match self.message.take() {
                ::std::option::Option::Some(MainRequest_oneof_message::set_irq(v)) => v,
                _ => panic!(),
            }
        } else {
            MainRequest_SetIrq::new()
        }
    }

    // .MainRequest.SetIrqRouting set_irq_routing = 12;


    pub fn get_set_irq_routing(&self) -> &MainRequest_SetIrqRouting {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::set_irq_routing(ref v)) => v,
            _ => <MainRequest_SetIrqRouting as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_set_irq_routing(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_set_irq_routing(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::set_irq_routing(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_irq_routing(&mut self, v: MainRequest_SetIrqRouting) {
        self.message = ::std::option::Option::Some(MainRequest_oneof_message::set_irq_routing(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_irq_routing(&mut self) -> &mut MainRequest_SetIrqRouting {
        if let ::std::option::Option::Some(MainRequest_oneof_message::set_irq_routing(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainRequest_oneof_message::set_irq_routing(MainRequest_SetIrqRouting::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::set_irq_routing(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_irq_routing(&mut self) -> MainRequest_SetIrqRouting {
        if self.has_set_irq_routing() {
            match self.message.take() {
                ::std::option::Option::Some(MainRequest_oneof_message::set_irq_routing(v)) => v,
                _ => panic!(),
            }
        } else {
            MainRequest_SetIrqRouting::new()
        }
    }

    // .MainRequest.GetState get_state = 13;


    pub fn get_get_state(&self) -> &MainRequest_GetState {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::get_state(ref v)) => v,
            _ => <MainRequest_GetState as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_get_state(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_state(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::get_state(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_state(&mut self, v: MainRequest_GetState) {
        self.message = ::std::option::Option::Some(MainRequest_oneof_message::get_state(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_state(&mut self) -> &mut MainRequest_GetState {
        if let ::std::option::Option::Some(MainRequest_oneof_message::get_state(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainRequest_oneof_message::get_state(MainRequest_GetState::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::get_state(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_state(&mut self) -> MainRequest_GetState {
        if self.has_get_state() {
            match self.message.take() {
                ::std::option::Option::Some(MainRequest_oneof_message::get_state(v)) => v,
                _ => panic!(),
            }
        } else {
            MainRequest_GetState::new()
        }
    }

    // .MainRequest.SetState set_state = 14;


    pub fn get_set_state(&self) -> &MainRequest_SetState {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::set_state(ref v)) => v,
            _ => <MainRequest_SetState as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_set_state(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_set_state(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::set_state(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_state(&mut self, v: MainRequest_SetState) {
        self.message = ::std::option::Option::Some(MainRequest_oneof_message::set_state(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_state(&mut self) -> &mut MainRequest_SetState {
        if let ::std::option::Option::Some(MainRequest_oneof_message::set_state(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainRequest_oneof_message::set_state(MainRequest_SetState::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::set_state(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_state(&mut self) -> MainRequest_SetState {
        if self.has_set_state() {
            match self.message.take() {
                ::std::option::Option::Some(MainRequest_oneof_message::set_state(v)) => v,
                _ => panic!(),
            }
        } else {
            MainRequest_SetState::new()
        }
    }

    // .MainRequest.SetIdentityMapAddr set_identity_map_addr = 15;


    pub fn get_set_identity_map_addr(&self) -> &MainRequest_SetIdentityMapAddr {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::set_identity_map_addr(ref v)) => v,
            _ => <MainRequest_SetIdentityMapAddr as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_set_identity_map_addr(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_set_identity_map_addr(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::set_identity_map_addr(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_identity_map_addr(&mut self, v: MainRequest_SetIdentityMapAddr) {
        self.message = ::std::option::Option::Some(MainRequest_oneof_message::set_identity_map_addr(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_identity_map_addr(&mut self) -> &mut MainRequest_SetIdentityMapAddr {
        if let ::std::option::Option::Some(MainRequest_oneof_message::set_identity_map_addr(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainRequest_oneof_message::set_identity_map_addr(MainRequest_SetIdentityMapAddr::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::set_identity_map_addr(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_identity_map_addr(&mut self) -> MainRequest_SetIdentityMapAddr {
        if self.has_set_identity_map_addr() {
            match self.message.take() {
                ::std::option::Option::Some(MainRequest_oneof_message::set_identity_map_addr(v)) => v,
                _ => panic!(),
            }
        } else {
            MainRequest_SetIdentityMapAddr::new()
        }
    }

    // .MainRequest.PauseVcpus pause_vcpus = 16;


    pub fn get_pause_vcpus(&self) -> &MainRequest_PauseVcpus {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::pause_vcpus(ref v)) => v,
            _ => <MainRequest_PauseVcpus as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_pause_vcpus(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_pause_vcpus(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::pause_vcpus(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pause_vcpus(&mut self, v: MainRequest_PauseVcpus) {
        self.message = ::std::option::Option::Some(MainRequest_oneof_message::pause_vcpus(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pause_vcpus(&mut self) -> &mut MainRequest_PauseVcpus {
        if let ::std::option::Option::Some(MainRequest_oneof_message::pause_vcpus(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainRequest_oneof_message::pause_vcpus(MainRequest_PauseVcpus::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::pause_vcpus(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pause_vcpus(&mut self) -> MainRequest_PauseVcpus {
        if self.has_pause_vcpus() {
            match self.message.take() {
                ::std::option::Option::Some(MainRequest_oneof_message::pause_vcpus(v)) => v,
                _ => panic!(),
            }
        } else {
            MainRequest_PauseVcpus::new()
        }
    }

    // .MainRequest.GetVcpus get_vcpus = 17;


    pub fn get_get_vcpus(&self) -> &MainRequest_GetVcpus {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::get_vcpus(ref v)) => v,
            _ => <MainRequest_GetVcpus as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_get_vcpus(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_vcpus(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::get_vcpus(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_vcpus(&mut self, v: MainRequest_GetVcpus) {
        self.message = ::std::option::Option::Some(MainRequest_oneof_message::get_vcpus(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_vcpus(&mut self) -> &mut MainRequest_GetVcpus {
        if let ::std::option::Option::Some(MainRequest_oneof_message::get_vcpus(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainRequest_oneof_message::get_vcpus(MainRequest_GetVcpus::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::get_vcpus(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_vcpus(&mut self) -> MainRequest_GetVcpus {
        if self.has_get_vcpus() {
            match self.message.take() {
                ::std::option::Option::Some(MainRequest_oneof_message::get_vcpus(v)) => v,
                _ => panic!(),
            }
        } else {
            MainRequest_GetVcpus::new()
        }
    }

    // .MainRequest.Start start = 18;


    pub fn get_start(&self) -> &MainRequest_Start {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::start(ref v)) => v,
            _ => <MainRequest_Start as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_start(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::start(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: MainRequest_Start) {
        self.message = ::std::option::Option::Some(MainRequest_oneof_message::start(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start(&mut self) -> &mut MainRequest_Start {
        if let ::std::option::Option::Some(MainRequest_oneof_message::start(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainRequest_oneof_message::start(MainRequest_Start::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::start(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start(&mut self) -> MainRequest_Start {
        if self.has_start() {
            match self.message.take() {
                ::std::option::Option::Some(MainRequest_oneof_message::start(v)) => v,
                _ => panic!(),
            }
        } else {
            MainRequest_Start::new()
        }
    }

    // .MainRequest.SetCallHint set_call_hint = 19;


    pub fn get_set_call_hint(&self) -> &MainRequest_SetCallHint {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::set_call_hint(ref v)) => v,
            _ => <MainRequest_SetCallHint as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_set_call_hint(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_set_call_hint(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::set_call_hint(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_call_hint(&mut self, v: MainRequest_SetCallHint) {
        self.message = ::std::option::Option::Some(MainRequest_oneof_message::set_call_hint(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_call_hint(&mut self) -> &mut MainRequest_SetCallHint {
        if let ::std::option::Option::Some(MainRequest_oneof_message::set_call_hint(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainRequest_oneof_message::set_call_hint(MainRequest_SetCallHint::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::set_call_hint(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_call_hint(&mut self) -> MainRequest_SetCallHint {
        if self.has_set_call_hint() {
            match self.message.take() {
                ::std::option::Option::Some(MainRequest_oneof_message::set_call_hint(v)) => v,
                _ => panic!(),
            }
        } else {
            MainRequest_SetCallHint::new()
        }
    }

    // .MainRequest.MemoryDirtyLog dirty_log = 101;


    pub fn get_dirty_log(&self) -> &MainRequest_MemoryDirtyLog {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::dirty_log(ref v)) => v,
            _ => <MainRequest_MemoryDirtyLog as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_dirty_log(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_dirty_log(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::dirty_log(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dirty_log(&mut self, v: MainRequest_MemoryDirtyLog) {
        self.message = ::std::option::Option::Some(MainRequest_oneof_message::dirty_log(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dirty_log(&mut self) -> &mut MainRequest_MemoryDirtyLog {
        if let ::std::option::Option::Some(MainRequest_oneof_message::dirty_log(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainRequest_oneof_message::dirty_log(MainRequest_MemoryDirtyLog::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainRequest_oneof_message::dirty_log(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dirty_log(&mut self) -> MainRequest_MemoryDirtyLog {
        if self.has_dirty_log() {
            match self.message.take() {
                ::std::option::Option::Some(MainRequest_oneof_message::dirty_log(v)) => v,
                _ => panic!(),
            }
        } else {
            MainRequest_MemoryDirtyLog::new()
        }
    }
}

impl ::protobuf::Message for MainRequest {
    fn is_initialized(&self) -> bool {
        if let Some(MainRequest_oneof_message::create(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainRequest_oneof_message::destroy(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainRequest_oneof_message::new_connection(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainRequest_oneof_message::get_shutdown_eventfd(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainRequest_oneof_message::check_extension(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainRequest_oneof_message::get_supported_cpuid(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainRequest_oneof_message::get_emulated_cpuid(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainRequest_oneof_message::get_msr_index_list(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainRequest_oneof_message::get_net_config(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainRequest_oneof_message::reserve_range(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainRequest_oneof_message::set_irq(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainRequest_oneof_message::set_irq_routing(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainRequest_oneof_message::get_state(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainRequest_oneof_message::set_state(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainRequest_oneof_message::set_identity_map_addr(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainRequest_oneof_message::pause_vcpus(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainRequest_oneof_message::get_vcpus(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainRequest_oneof_message::start(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainRequest_oneof_message::set_call_hint(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainRequest_oneof_message::dirty_log(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainRequest_oneof_message::create(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainRequest_oneof_message::destroy(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainRequest_oneof_message::new_connection(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainRequest_oneof_message::get_shutdown_eventfd(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainRequest_oneof_message::check_extension(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainRequest_oneof_message::get_supported_cpuid(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainRequest_oneof_message::get_emulated_cpuid(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainRequest_oneof_message::get_msr_index_list(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainRequest_oneof_message::get_net_config(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainRequest_oneof_message::reserve_range(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainRequest_oneof_message::set_irq(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainRequest_oneof_message::set_irq_routing(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainRequest_oneof_message::get_state(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainRequest_oneof_message::set_state(is.read_message()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainRequest_oneof_message::set_identity_map_addr(is.read_message()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainRequest_oneof_message::pause_vcpus(is.read_message()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainRequest_oneof_message::get_vcpus(is.read_message()?));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainRequest_oneof_message::start(is.read_message()?));
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainRequest_oneof_message::set_call_hint(is.read_message()?));
                },
                101 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainRequest_oneof_message::dirty_log(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &MainRequest_oneof_message::create(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainRequest_oneof_message::destroy(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainRequest_oneof_message::new_connection(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainRequest_oneof_message::get_shutdown_eventfd(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainRequest_oneof_message::check_extension(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainRequest_oneof_message::get_supported_cpuid(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainRequest_oneof_message::get_emulated_cpuid(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainRequest_oneof_message::get_msr_index_list(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainRequest_oneof_message::get_net_config(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainRequest_oneof_message::reserve_range(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainRequest_oneof_message::set_irq(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainRequest_oneof_message::set_irq_routing(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainRequest_oneof_message::get_state(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainRequest_oneof_message::set_state(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainRequest_oneof_message::set_identity_map_addr(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainRequest_oneof_message::pause_vcpus(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainRequest_oneof_message::get_vcpus(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainRequest_oneof_message::start(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainRequest_oneof_message::set_call_hint(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainRequest_oneof_message::dirty_log(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &MainRequest_oneof_message::create(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainRequest_oneof_message::destroy(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainRequest_oneof_message::new_connection(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainRequest_oneof_message::get_shutdown_eventfd(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainRequest_oneof_message::check_extension(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainRequest_oneof_message::get_supported_cpuid(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainRequest_oneof_message::get_emulated_cpuid(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainRequest_oneof_message::get_msr_index_list(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainRequest_oneof_message::get_net_config(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainRequest_oneof_message::reserve_range(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainRequest_oneof_message::set_irq(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainRequest_oneof_message::set_irq_routing(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainRequest_oneof_message::get_state(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainRequest_oneof_message::set_state(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainRequest_oneof_message::set_identity_map_addr(ref v) => {
                    os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainRequest_oneof_message::pause_vcpus(ref v) => {
                    os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainRequest_oneof_message::get_vcpus(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainRequest_oneof_message::start(ref v) => {
                    os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainRequest_oneof_message::set_call_hint(ref v) => {
                    os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainRequest_oneof_message::dirty_log(ref v) => {
                    os.write_tag(101, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainRequest {
        MainRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainRequest_Create>(
                "create",
                MainRequest::has_create,
                MainRequest::get_create,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainRequest_Destroy>(
                "destroy",
                MainRequest::has_destroy,
                MainRequest::get_destroy,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainRequest_NewConnection>(
                "new_connection",
                MainRequest::has_new_connection,
                MainRequest::get_new_connection,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainRequest_GetShutdownEventfd>(
                "get_shutdown_eventfd",
                MainRequest::has_get_shutdown_eventfd,
                MainRequest::get_get_shutdown_eventfd,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainRequest_CheckExtension>(
                "check_extension",
                MainRequest::has_check_extension,
                MainRequest::get_check_extension,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainRequest_CpuidRequest>(
                "get_supported_cpuid",
                MainRequest::has_get_supported_cpuid,
                MainRequest::get_get_supported_cpuid,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainRequest_CpuidRequest>(
                "get_emulated_cpuid",
                MainRequest::has_get_emulated_cpuid,
                MainRequest::get_get_emulated_cpuid,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainRequest_MsrListRequest>(
                "get_msr_index_list",
                MainRequest::has_get_msr_index_list,
                MainRequest::get_get_msr_index_list,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainRequest_GetNetConfig>(
                "get_net_config",
                MainRequest::has_get_net_config,
                MainRequest::get_get_net_config,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainRequest_ReserveRange>(
                "reserve_range",
                MainRequest::has_reserve_range,
                MainRequest::get_reserve_range,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainRequest_SetIrq>(
                "set_irq",
                MainRequest::has_set_irq,
                MainRequest::get_set_irq,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainRequest_SetIrqRouting>(
                "set_irq_routing",
                MainRequest::has_set_irq_routing,
                MainRequest::get_set_irq_routing,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainRequest_GetState>(
                "get_state",
                MainRequest::has_get_state,
                MainRequest::get_get_state,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainRequest_SetState>(
                "set_state",
                MainRequest::has_set_state,
                MainRequest::get_set_state,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainRequest_SetIdentityMapAddr>(
                "set_identity_map_addr",
                MainRequest::has_set_identity_map_addr,
                MainRequest::get_set_identity_map_addr,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainRequest_PauseVcpus>(
                "pause_vcpus",
                MainRequest::has_pause_vcpus,
                MainRequest::get_pause_vcpus,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainRequest_GetVcpus>(
                "get_vcpus",
                MainRequest::has_get_vcpus,
                MainRequest::get_get_vcpus,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainRequest_Start>(
                "start",
                MainRequest::has_start,
                MainRequest::get_start,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainRequest_SetCallHint>(
                "set_call_hint",
                MainRequest::has_set_call_hint,
                MainRequest::get_set_call_hint,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainRequest_MemoryDirtyLog>(
                "dirty_log",
                MainRequest::has_dirty_log,
                MainRequest::get_dirty_log,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainRequest>(
                "MainRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainRequest {
        static instance: ::protobuf::rt::LazyV2<MainRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainRequest::new)
    }
}

impl ::protobuf::Clear for MainRequest {
    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainRequest_Create {
    // message fields
    pub id: u32,
    // message oneof groups
    pub constructor: ::std::option::Option<MainRequest_Create_oneof_constructor>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainRequest_Create {
    fn default() -> &'a MainRequest_Create {
        <MainRequest_Create as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum MainRequest_Create_oneof_constructor {
    io_event(MainRequest_Create_IoEvent),
    memory(MainRequest_Create_Memory),
    irq_event(MainRequest_Create_IrqEvent),
}

impl MainRequest_Create {
    pub fn new() -> MainRequest_Create {
        ::std::default::Default::default()
    }

    // uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }

    // .MainRequest.Create.IoEvent io_event = 2;


    pub fn get_io_event(&self) -> &MainRequest_Create_IoEvent {
        match self.constructor {
            ::std::option::Option::Some(MainRequest_Create_oneof_constructor::io_event(ref v)) => v,
            _ => <MainRequest_Create_IoEvent as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_io_event(&mut self) {
        self.constructor = ::std::option::Option::None;
    }

    pub fn has_io_event(&self) -> bool {
        match self.constructor {
            ::std::option::Option::Some(MainRequest_Create_oneof_constructor::io_event(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_io_event(&mut self, v: MainRequest_Create_IoEvent) {
        self.constructor = ::std::option::Option::Some(MainRequest_Create_oneof_constructor::io_event(v))
    }

    // Mutable pointer to the field.
    pub fn mut_io_event(&mut self) -> &mut MainRequest_Create_IoEvent {
        if let ::std::option::Option::Some(MainRequest_Create_oneof_constructor::io_event(_)) = self.constructor {
        } else {
            self.constructor = ::std::option::Option::Some(MainRequest_Create_oneof_constructor::io_event(MainRequest_Create_IoEvent::new()));
        }
        match self.constructor {
            ::std::option::Option::Some(MainRequest_Create_oneof_constructor::io_event(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_io_event(&mut self) -> MainRequest_Create_IoEvent {
        if self.has_io_event() {
            match self.constructor.take() {
                ::std::option::Option::Some(MainRequest_Create_oneof_constructor::io_event(v)) => v,
                _ => panic!(),
            }
        } else {
            MainRequest_Create_IoEvent::new()
        }
    }

    // .MainRequest.Create.Memory memory = 3;


    pub fn get_memory(&self) -> &MainRequest_Create_Memory {
        match self.constructor {
            ::std::option::Option::Some(MainRequest_Create_oneof_constructor::memory(ref v)) => v,
            _ => <MainRequest_Create_Memory as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_memory(&mut self) {
        self.constructor = ::std::option::Option::None;
    }

    pub fn has_memory(&self) -> bool {
        match self.constructor {
            ::std::option::Option::Some(MainRequest_Create_oneof_constructor::memory(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_memory(&mut self, v: MainRequest_Create_Memory) {
        self.constructor = ::std::option::Option::Some(MainRequest_Create_oneof_constructor::memory(v))
    }

    // Mutable pointer to the field.
    pub fn mut_memory(&mut self) -> &mut MainRequest_Create_Memory {
        if let ::std::option::Option::Some(MainRequest_Create_oneof_constructor::memory(_)) = self.constructor {
        } else {
            self.constructor = ::std::option::Option::Some(MainRequest_Create_oneof_constructor::memory(MainRequest_Create_Memory::new()));
        }
        match self.constructor {
            ::std::option::Option::Some(MainRequest_Create_oneof_constructor::memory(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_memory(&mut self) -> MainRequest_Create_Memory {
        if self.has_memory() {
            match self.constructor.take() {
                ::std::option::Option::Some(MainRequest_Create_oneof_constructor::memory(v)) => v,
                _ => panic!(),
            }
        } else {
            MainRequest_Create_Memory::new()
        }
    }

    // .MainRequest.Create.IrqEvent irq_event = 4;


    pub fn get_irq_event(&self) -> &MainRequest_Create_IrqEvent {
        match self.constructor {
            ::std::option::Option::Some(MainRequest_Create_oneof_constructor::irq_event(ref v)) => v,
            _ => <MainRequest_Create_IrqEvent as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_irq_event(&mut self) {
        self.constructor = ::std::option::Option::None;
    }

    pub fn has_irq_event(&self) -> bool {
        match self.constructor {
            ::std::option::Option::Some(MainRequest_Create_oneof_constructor::irq_event(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_irq_event(&mut self, v: MainRequest_Create_IrqEvent) {
        self.constructor = ::std::option::Option::Some(MainRequest_Create_oneof_constructor::irq_event(v))
    }

    // Mutable pointer to the field.
    pub fn mut_irq_event(&mut self) -> &mut MainRequest_Create_IrqEvent {
        if let ::std::option::Option::Some(MainRequest_Create_oneof_constructor::irq_event(_)) = self.constructor {
        } else {
            self.constructor = ::std::option::Option::Some(MainRequest_Create_oneof_constructor::irq_event(MainRequest_Create_IrqEvent::new()));
        }
        match self.constructor {
            ::std::option::Option::Some(MainRequest_Create_oneof_constructor::irq_event(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_irq_event(&mut self) -> MainRequest_Create_IrqEvent {
        if self.has_irq_event() {
            match self.constructor.take() {
                ::std::option::Option::Some(MainRequest_Create_oneof_constructor::irq_event(v)) => v,
                _ => panic!(),
            }
        } else {
            MainRequest_Create_IrqEvent::new()
        }
    }
}

impl ::protobuf::Message for MainRequest_Create {
    fn is_initialized(&self) -> bool {
        if let Some(MainRequest_Create_oneof_constructor::io_event(ref v)) = self.constructor {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainRequest_Create_oneof_constructor::memory(ref v)) = self.constructor {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainRequest_Create_oneof_constructor::irq_event(ref v)) = self.constructor {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.constructor = ::std::option::Option::Some(MainRequest_Create_oneof_constructor::io_event(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.constructor = ::std::option::Option::Some(MainRequest_Create_oneof_constructor::memory(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.constructor = ::std::option::Option::Some(MainRequest_Create_oneof_constructor::irq_event(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.constructor {
            match v {
                &MainRequest_Create_oneof_constructor::io_event(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainRequest_Create_oneof_constructor::memory(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainRequest_Create_oneof_constructor::irq_event(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if let ::std::option::Option::Some(ref v) = self.constructor {
            match v {
                &MainRequest_Create_oneof_constructor::io_event(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainRequest_Create_oneof_constructor::memory(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainRequest_Create_oneof_constructor::irq_event(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainRequest_Create {
        MainRequest_Create::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &MainRequest_Create| { &m.id },
                |m: &mut MainRequest_Create| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainRequest_Create_IoEvent>(
                "io_event",
                MainRequest_Create::has_io_event,
                MainRequest_Create::get_io_event,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainRequest_Create_Memory>(
                "memory",
                MainRequest_Create::has_memory,
                MainRequest_Create::get_memory,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainRequest_Create_IrqEvent>(
                "irq_event",
                MainRequest_Create::has_irq_event,
                MainRequest_Create::get_irq_event,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainRequest_Create>(
                "MainRequest.Create",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainRequest_Create {
        static instance: ::protobuf::rt::LazyV2<MainRequest_Create> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainRequest_Create::new)
    }
}

impl ::protobuf::Clear for MainRequest_Create {
    fn clear(&mut self) {
        self.id = 0;
        self.constructor = ::std::option::Option::None;
        self.constructor = ::std::option::Option::None;
        self.constructor = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainRequest_Create {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainRequest_Create {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainRequest_Create_IoEvent {
    // message fields
    pub space: AddressSpace,
    pub address: u64,
    pub length: u32,
    pub datamatch: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainRequest_Create_IoEvent {
    fn default() -> &'a MainRequest_Create_IoEvent {
        <MainRequest_Create_IoEvent as ::protobuf::Message>::default_instance()
    }
}

impl MainRequest_Create_IoEvent {
    pub fn new() -> MainRequest_Create_IoEvent {
        ::std::default::Default::default()
    }

    // .AddressSpace space = 1;


    pub fn get_space(&self) -> AddressSpace {
        self.space
    }
    pub fn clear_space(&mut self) {
        self.space = AddressSpace::IOPORT;
    }

    // Param is passed by value, moved
    pub fn set_space(&mut self, v: AddressSpace) {
        self.space = v;
    }

    // uint64 address = 2;


    pub fn get_address(&self) -> u64 {
        self.address
    }
    pub fn clear_address(&mut self) {
        self.address = 0;
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: u64) {
        self.address = v;
    }

    // uint32 length = 3;


    pub fn get_length(&self) -> u32 {
        self.length
    }
    pub fn clear_length(&mut self) {
        self.length = 0;
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u32) {
        self.length = v;
    }

    // uint64 datamatch = 4;


    pub fn get_datamatch(&self) -> u64 {
        self.datamatch
    }
    pub fn clear_datamatch(&mut self) {
        self.datamatch = 0;
    }

    // Param is passed by value, moved
    pub fn set_datamatch(&mut self, v: u64) {
        self.datamatch = v;
    }
}

impl ::protobuf::Message for MainRequest_Create_IoEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.space, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.address = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.length = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.datamatch = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.space != AddressSpace::IOPORT {
            my_size += ::protobuf::rt::enum_size(1, self.space);
        }
        if self.address != 0 {
            my_size += ::protobuf::rt::value_size(2, self.address, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.length != 0 {
            my_size += ::protobuf::rt::value_size(3, self.length, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.datamatch != 0 {
            my_size += ::protobuf::rt::value_size(4, self.datamatch, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.space != AddressSpace::IOPORT {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.space))?;
        }
        if self.address != 0 {
            os.write_uint64(2, self.address)?;
        }
        if self.length != 0 {
            os.write_uint32(3, self.length)?;
        }
        if self.datamatch != 0 {
            os.write_uint64(4, self.datamatch)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainRequest_Create_IoEvent {
        MainRequest_Create_IoEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AddressSpace>>(
                "space",
                |m: &MainRequest_Create_IoEvent| { &m.space },
                |m: &mut MainRequest_Create_IoEvent| { &mut m.space },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "address",
                |m: &MainRequest_Create_IoEvent| { &m.address },
                |m: &mut MainRequest_Create_IoEvent| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "length",
                |m: &MainRequest_Create_IoEvent| { &m.length },
                |m: &mut MainRequest_Create_IoEvent| { &mut m.length },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "datamatch",
                |m: &MainRequest_Create_IoEvent| { &m.datamatch },
                |m: &mut MainRequest_Create_IoEvent| { &mut m.datamatch },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainRequest_Create_IoEvent>(
                "MainRequest.Create.IoEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainRequest_Create_IoEvent {
        static instance: ::protobuf::rt::LazyV2<MainRequest_Create_IoEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainRequest_Create_IoEvent::new)
    }
}

impl ::protobuf::Clear for MainRequest_Create_IoEvent {
    fn clear(&mut self) {
        self.space = AddressSpace::IOPORT;
        self.address = 0;
        self.length = 0;
        self.datamatch = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainRequest_Create_IoEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainRequest_Create_IoEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainRequest_Create_Memory {
    // message fields
    pub offset: u64,
    pub start: u64,
    pub length: u64,
    pub read_only: bool,
    pub dirty_log: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainRequest_Create_Memory {
    fn default() -> &'a MainRequest_Create_Memory {
        <MainRequest_Create_Memory as ::protobuf::Message>::default_instance()
    }
}

impl MainRequest_Create_Memory {
    pub fn new() -> MainRequest_Create_Memory {
        ::std::default::Default::default()
    }

    // uint64 offset = 1;


    pub fn get_offset(&self) -> u64 {
        self.offset
    }
    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = v;
    }

    // uint64 start = 2;


    pub fn get_start(&self) -> u64 {
        self.start
    }
    pub fn clear_start(&mut self) {
        self.start = 0;
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: u64) {
        self.start = v;
    }

    // uint64 length = 3;


    pub fn get_length(&self) -> u64 {
        self.length
    }
    pub fn clear_length(&mut self) {
        self.length = 0;
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u64) {
        self.length = v;
    }

    // bool read_only = 4;


    pub fn get_read_only(&self) -> bool {
        self.read_only
    }
    pub fn clear_read_only(&mut self) {
        self.read_only = false;
    }

    // Param is passed by value, moved
    pub fn set_read_only(&mut self, v: bool) {
        self.read_only = v;
    }

    // bool dirty_log = 5;


    pub fn get_dirty_log(&self) -> bool {
        self.dirty_log
    }
    pub fn clear_dirty_log(&mut self) {
        self.dirty_log = false;
    }

    // Param is passed by value, moved
    pub fn set_dirty_log(&mut self, v: bool) {
        self.dirty_log = v;
    }
}

impl ::protobuf::Message for MainRequest_Create_Memory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.offset = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.length = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.read_only = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.dirty_log = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.offset != 0 {
            my_size += ::protobuf::rt::value_size(1, self.offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.start != 0 {
            my_size += ::protobuf::rt::value_size(2, self.start, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.length != 0 {
            my_size += ::protobuf::rt::value_size(3, self.length, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.read_only != false {
            my_size += 2;
        }
        if self.dirty_log != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.offset != 0 {
            os.write_uint64(1, self.offset)?;
        }
        if self.start != 0 {
            os.write_uint64(2, self.start)?;
        }
        if self.length != 0 {
            os.write_uint64(3, self.length)?;
        }
        if self.read_only != false {
            os.write_bool(4, self.read_only)?;
        }
        if self.dirty_log != false {
            os.write_bool(5, self.dirty_log)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainRequest_Create_Memory {
        MainRequest_Create_Memory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "offset",
                |m: &MainRequest_Create_Memory| { &m.offset },
                |m: &mut MainRequest_Create_Memory| { &mut m.offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "start",
                |m: &MainRequest_Create_Memory| { &m.start },
                |m: &mut MainRequest_Create_Memory| { &mut m.start },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "length",
                |m: &MainRequest_Create_Memory| { &m.length },
                |m: &mut MainRequest_Create_Memory| { &mut m.length },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "read_only",
                |m: &MainRequest_Create_Memory| { &m.read_only },
                |m: &mut MainRequest_Create_Memory| { &mut m.read_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "dirty_log",
                |m: &MainRequest_Create_Memory| { &m.dirty_log },
                |m: &mut MainRequest_Create_Memory| { &mut m.dirty_log },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainRequest_Create_Memory>(
                "MainRequest.Create.Memory",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainRequest_Create_Memory {
        static instance: ::protobuf::rt::LazyV2<MainRequest_Create_Memory> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainRequest_Create_Memory::new)
    }
}

impl ::protobuf::Clear for MainRequest_Create_Memory {
    fn clear(&mut self) {
        self.offset = 0;
        self.start = 0;
        self.length = 0;
        self.read_only = false;
        self.dirty_log = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainRequest_Create_Memory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainRequest_Create_Memory {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainRequest_Create_IrqEvent {
    // message fields
    pub irq_id: u32,
    pub resample: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainRequest_Create_IrqEvent {
    fn default() -> &'a MainRequest_Create_IrqEvent {
        <MainRequest_Create_IrqEvent as ::protobuf::Message>::default_instance()
    }
}

impl MainRequest_Create_IrqEvent {
    pub fn new() -> MainRequest_Create_IrqEvent {
        ::std::default::Default::default()
    }

    // uint32 irq_id = 1;


    pub fn get_irq_id(&self) -> u32 {
        self.irq_id
    }
    pub fn clear_irq_id(&mut self) {
        self.irq_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_irq_id(&mut self, v: u32) {
        self.irq_id = v;
    }

    // bool resample = 2;


    pub fn get_resample(&self) -> bool {
        self.resample
    }
    pub fn clear_resample(&mut self) {
        self.resample = false;
    }

    // Param is passed by value, moved
    pub fn set_resample(&mut self, v: bool) {
        self.resample = v;
    }
}

impl ::protobuf::Message for MainRequest_Create_IrqEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.irq_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.resample = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.irq_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.irq_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.resample != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.irq_id != 0 {
            os.write_uint32(1, self.irq_id)?;
        }
        if self.resample != false {
            os.write_bool(2, self.resample)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainRequest_Create_IrqEvent {
        MainRequest_Create_IrqEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "irq_id",
                |m: &MainRequest_Create_IrqEvent| { &m.irq_id },
                |m: &mut MainRequest_Create_IrqEvent| { &mut m.irq_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "resample",
                |m: &MainRequest_Create_IrqEvent| { &m.resample },
                |m: &mut MainRequest_Create_IrqEvent| { &mut m.resample },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainRequest_Create_IrqEvent>(
                "MainRequest.Create.IrqEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainRequest_Create_IrqEvent {
        static instance: ::protobuf::rt::LazyV2<MainRequest_Create_IrqEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainRequest_Create_IrqEvent::new)
    }
}

impl ::protobuf::Clear for MainRequest_Create_IrqEvent {
    fn clear(&mut self) {
        self.irq_id = 0;
        self.resample = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainRequest_Create_IrqEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainRequest_Create_IrqEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainRequest_Destroy {
    // message fields
    pub id: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainRequest_Destroy {
    fn default() -> &'a MainRequest_Destroy {
        <MainRequest_Destroy as ::protobuf::Message>::default_instance()
    }
}

impl MainRequest_Destroy {
    pub fn new() -> MainRequest_Destroy {
        ::std::default::Default::default()
    }

    // uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }
}

impl ::protobuf::Message for MainRequest_Destroy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainRequest_Destroy {
        MainRequest_Destroy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &MainRequest_Destroy| { &m.id },
                |m: &mut MainRequest_Destroy| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainRequest_Destroy>(
                "MainRequest.Destroy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainRequest_Destroy {
        static instance: ::protobuf::rt::LazyV2<MainRequest_Destroy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainRequest_Destroy::new)
    }
}

impl ::protobuf::Clear for MainRequest_Destroy {
    fn clear(&mut self) {
        self.id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainRequest_Destroy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainRequest_Destroy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainRequest_NewConnection {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainRequest_NewConnection {
    fn default() -> &'a MainRequest_NewConnection {
        <MainRequest_NewConnection as ::protobuf::Message>::default_instance()
    }
}

impl MainRequest_NewConnection {
    pub fn new() -> MainRequest_NewConnection {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MainRequest_NewConnection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainRequest_NewConnection {
        MainRequest_NewConnection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainRequest_NewConnection>(
                "MainRequest.NewConnection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainRequest_NewConnection {
        static instance: ::protobuf::rt::LazyV2<MainRequest_NewConnection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainRequest_NewConnection::new)
    }
}

impl ::protobuf::Clear for MainRequest_NewConnection {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainRequest_NewConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainRequest_NewConnection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainRequest_GetShutdownEventfd {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainRequest_GetShutdownEventfd {
    fn default() -> &'a MainRequest_GetShutdownEventfd {
        <MainRequest_GetShutdownEventfd as ::protobuf::Message>::default_instance()
    }
}

impl MainRequest_GetShutdownEventfd {
    pub fn new() -> MainRequest_GetShutdownEventfd {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MainRequest_GetShutdownEventfd {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainRequest_GetShutdownEventfd {
        MainRequest_GetShutdownEventfd::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainRequest_GetShutdownEventfd>(
                "MainRequest.GetShutdownEventfd",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainRequest_GetShutdownEventfd {
        static instance: ::protobuf::rt::LazyV2<MainRequest_GetShutdownEventfd> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainRequest_GetShutdownEventfd::new)
    }
}

impl ::protobuf::Clear for MainRequest_GetShutdownEventfd {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainRequest_GetShutdownEventfd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainRequest_GetShutdownEventfd {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainRequest_CheckExtension {
    // message fields
    pub extension: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainRequest_CheckExtension {
    fn default() -> &'a MainRequest_CheckExtension {
        <MainRequest_CheckExtension as ::protobuf::Message>::default_instance()
    }
}

impl MainRequest_CheckExtension {
    pub fn new() -> MainRequest_CheckExtension {
        ::std::default::Default::default()
    }

    // uint32 extension = 1;


    pub fn get_extension(&self) -> u32 {
        self.extension
    }
    pub fn clear_extension(&mut self) {
        self.extension = 0;
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: u32) {
        self.extension = v;
    }
}

impl ::protobuf::Message for MainRequest_CheckExtension {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.extension = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.extension != 0 {
            my_size += ::protobuf::rt::value_size(1, self.extension, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.extension != 0 {
            os.write_uint32(1, self.extension)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainRequest_CheckExtension {
        MainRequest_CheckExtension::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "extension",
                |m: &MainRequest_CheckExtension| { &m.extension },
                |m: &mut MainRequest_CheckExtension| { &mut m.extension },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainRequest_CheckExtension>(
                "MainRequest.CheckExtension",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainRequest_CheckExtension {
        static instance: ::protobuf::rt::LazyV2<MainRequest_CheckExtension> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainRequest_CheckExtension::new)
    }
}

impl ::protobuf::Clear for MainRequest_CheckExtension {
    fn clear(&mut self) {
        self.extension = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainRequest_CheckExtension {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainRequest_CheckExtension {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainRequest_CpuidRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainRequest_CpuidRequest {
    fn default() -> &'a MainRequest_CpuidRequest {
        <MainRequest_CpuidRequest as ::protobuf::Message>::default_instance()
    }
}

impl MainRequest_CpuidRequest {
    pub fn new() -> MainRequest_CpuidRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MainRequest_CpuidRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainRequest_CpuidRequest {
        MainRequest_CpuidRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainRequest_CpuidRequest>(
                "MainRequest.CpuidRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainRequest_CpuidRequest {
        static instance: ::protobuf::rt::LazyV2<MainRequest_CpuidRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainRequest_CpuidRequest::new)
    }
}

impl ::protobuf::Clear for MainRequest_CpuidRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainRequest_CpuidRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainRequest_CpuidRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainRequest_MsrListRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainRequest_MsrListRequest {
    fn default() -> &'a MainRequest_MsrListRequest {
        <MainRequest_MsrListRequest as ::protobuf::Message>::default_instance()
    }
}

impl MainRequest_MsrListRequest {
    pub fn new() -> MainRequest_MsrListRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MainRequest_MsrListRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainRequest_MsrListRequest {
        MainRequest_MsrListRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainRequest_MsrListRequest>(
                "MainRequest.MsrListRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainRequest_MsrListRequest {
        static instance: ::protobuf::rt::LazyV2<MainRequest_MsrListRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainRequest_MsrListRequest::new)
    }
}

impl ::protobuf::Clear for MainRequest_MsrListRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainRequest_MsrListRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainRequest_MsrListRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainRequest_GetNetConfig {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainRequest_GetNetConfig {
    fn default() -> &'a MainRequest_GetNetConfig {
        <MainRequest_GetNetConfig as ::protobuf::Message>::default_instance()
    }
}

impl MainRequest_GetNetConfig {
    pub fn new() -> MainRequest_GetNetConfig {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MainRequest_GetNetConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainRequest_GetNetConfig {
        MainRequest_GetNetConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainRequest_GetNetConfig>(
                "MainRequest.GetNetConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainRequest_GetNetConfig {
        static instance: ::protobuf::rt::LazyV2<MainRequest_GetNetConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainRequest_GetNetConfig::new)
    }
}

impl ::protobuf::Clear for MainRequest_GetNetConfig {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainRequest_GetNetConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainRequest_GetNetConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainRequest_ReserveRange {
    // message fields
    pub space: AddressSpace,
    pub start: u64,
    pub length: u64,
    pub async_write: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainRequest_ReserveRange {
    fn default() -> &'a MainRequest_ReserveRange {
        <MainRequest_ReserveRange as ::protobuf::Message>::default_instance()
    }
}

impl MainRequest_ReserveRange {
    pub fn new() -> MainRequest_ReserveRange {
        ::std::default::Default::default()
    }

    // .AddressSpace space = 1;


    pub fn get_space(&self) -> AddressSpace {
        self.space
    }
    pub fn clear_space(&mut self) {
        self.space = AddressSpace::IOPORT;
    }

    // Param is passed by value, moved
    pub fn set_space(&mut self, v: AddressSpace) {
        self.space = v;
    }

    // uint64 start = 2;


    pub fn get_start(&self) -> u64 {
        self.start
    }
    pub fn clear_start(&mut self) {
        self.start = 0;
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: u64) {
        self.start = v;
    }

    // uint64 length = 3;


    pub fn get_length(&self) -> u64 {
        self.length
    }
    pub fn clear_length(&mut self) {
        self.length = 0;
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u64) {
        self.length = v;
    }

    // bool async_write = 4;


    pub fn get_async_write(&self) -> bool {
        self.async_write
    }
    pub fn clear_async_write(&mut self) {
        self.async_write = false;
    }

    // Param is passed by value, moved
    pub fn set_async_write(&mut self, v: bool) {
        self.async_write = v;
    }
}

impl ::protobuf::Message for MainRequest_ReserveRange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.space, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.length = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.async_write = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.space != AddressSpace::IOPORT {
            my_size += ::protobuf::rt::enum_size(1, self.space);
        }
        if self.start != 0 {
            my_size += ::protobuf::rt::value_size(2, self.start, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.length != 0 {
            my_size += ::protobuf::rt::value_size(3, self.length, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.async_write != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.space != AddressSpace::IOPORT {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.space))?;
        }
        if self.start != 0 {
            os.write_uint64(2, self.start)?;
        }
        if self.length != 0 {
            os.write_uint64(3, self.length)?;
        }
        if self.async_write != false {
            os.write_bool(4, self.async_write)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainRequest_ReserveRange {
        MainRequest_ReserveRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AddressSpace>>(
                "space",
                |m: &MainRequest_ReserveRange| { &m.space },
                |m: &mut MainRequest_ReserveRange| { &mut m.space },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "start",
                |m: &MainRequest_ReserveRange| { &m.start },
                |m: &mut MainRequest_ReserveRange| { &mut m.start },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "length",
                |m: &MainRequest_ReserveRange| { &m.length },
                |m: &mut MainRequest_ReserveRange| { &mut m.length },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "async_write",
                |m: &MainRequest_ReserveRange| { &m.async_write },
                |m: &mut MainRequest_ReserveRange| { &mut m.async_write },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainRequest_ReserveRange>(
                "MainRequest.ReserveRange",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainRequest_ReserveRange {
        static instance: ::protobuf::rt::LazyV2<MainRequest_ReserveRange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainRequest_ReserveRange::new)
    }
}

impl ::protobuf::Clear for MainRequest_ReserveRange {
    fn clear(&mut self) {
        self.space = AddressSpace::IOPORT;
        self.start = 0;
        self.length = 0;
        self.async_write = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainRequest_ReserveRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainRequest_ReserveRange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainRequest_SetIrq {
    // message fields
    pub irq_id: u32,
    pub active: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainRequest_SetIrq {
    fn default() -> &'a MainRequest_SetIrq {
        <MainRequest_SetIrq as ::protobuf::Message>::default_instance()
    }
}

impl MainRequest_SetIrq {
    pub fn new() -> MainRequest_SetIrq {
        ::std::default::Default::default()
    }

    // uint32 irq_id = 1;


    pub fn get_irq_id(&self) -> u32 {
        self.irq_id
    }
    pub fn clear_irq_id(&mut self) {
        self.irq_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_irq_id(&mut self, v: u32) {
        self.irq_id = v;
    }

    // bool active = 2;


    pub fn get_active(&self) -> bool {
        self.active
    }
    pub fn clear_active(&mut self) {
        self.active = false;
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: bool) {
        self.active = v;
    }
}

impl ::protobuf::Message for MainRequest_SetIrq {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.irq_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.active = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.irq_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.irq_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.active != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.irq_id != 0 {
            os.write_uint32(1, self.irq_id)?;
        }
        if self.active != false {
            os.write_bool(2, self.active)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainRequest_SetIrq {
        MainRequest_SetIrq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "irq_id",
                |m: &MainRequest_SetIrq| { &m.irq_id },
                |m: &mut MainRequest_SetIrq| { &mut m.irq_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "active",
                |m: &MainRequest_SetIrq| { &m.active },
                |m: &mut MainRequest_SetIrq| { &mut m.active },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainRequest_SetIrq>(
                "MainRequest.SetIrq",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainRequest_SetIrq {
        static instance: ::protobuf::rt::LazyV2<MainRequest_SetIrq> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainRequest_SetIrq::new)
    }
}

impl ::protobuf::Clear for MainRequest_SetIrq {
    fn clear(&mut self) {
        self.irq_id = 0;
        self.active = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainRequest_SetIrq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainRequest_SetIrq {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainRequest_SetIrqRouting {
    // message fields
    pub routes: ::protobuf::RepeatedField<MainRequest_SetIrqRouting_Route>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainRequest_SetIrqRouting {
    fn default() -> &'a MainRequest_SetIrqRouting {
        <MainRequest_SetIrqRouting as ::protobuf::Message>::default_instance()
    }
}

impl MainRequest_SetIrqRouting {
    pub fn new() -> MainRequest_SetIrqRouting {
        ::std::default::Default::default()
    }

    // repeated .MainRequest.SetIrqRouting.Route routes = 1;


    pub fn get_routes(&self) -> &[MainRequest_SetIrqRouting_Route] {
        &self.routes
    }
    pub fn clear_routes(&mut self) {
        self.routes.clear();
    }

    // Param is passed by value, moved
    pub fn set_routes(&mut self, v: ::protobuf::RepeatedField<MainRequest_SetIrqRouting_Route>) {
        self.routes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_routes(&mut self) -> &mut ::protobuf::RepeatedField<MainRequest_SetIrqRouting_Route> {
        &mut self.routes
    }

    // Take field
    pub fn take_routes(&mut self) -> ::protobuf::RepeatedField<MainRequest_SetIrqRouting_Route> {
        ::std::mem::replace(&mut self.routes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MainRequest_SetIrqRouting {
    fn is_initialized(&self) -> bool {
        for v in &self.routes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.routes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.routes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.routes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainRequest_SetIrqRouting {
        MainRequest_SetIrqRouting::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MainRequest_SetIrqRouting_Route>>(
                "routes",
                |m: &MainRequest_SetIrqRouting| { &m.routes },
                |m: &mut MainRequest_SetIrqRouting| { &mut m.routes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainRequest_SetIrqRouting>(
                "MainRequest.SetIrqRouting",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainRequest_SetIrqRouting {
        static instance: ::protobuf::rt::LazyV2<MainRequest_SetIrqRouting> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainRequest_SetIrqRouting::new)
    }
}

impl ::protobuf::Clear for MainRequest_SetIrqRouting {
    fn clear(&mut self) {
        self.routes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainRequest_SetIrqRouting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainRequest_SetIrqRouting {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainRequest_SetIrqRouting_Route {
    // message fields
    pub irq_id: u32,
    // message oneof groups
    pub route: ::std::option::Option<MainRequest_SetIrqRouting_Route_oneof_route>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainRequest_SetIrqRouting_Route {
    fn default() -> &'a MainRequest_SetIrqRouting_Route {
        <MainRequest_SetIrqRouting_Route as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum MainRequest_SetIrqRouting_Route_oneof_route {
    irqchip(MainRequest_SetIrqRouting_Route_Irqchip),
    msi(MainRequest_SetIrqRouting_Route_Msi),
}

impl MainRequest_SetIrqRouting_Route {
    pub fn new() -> MainRequest_SetIrqRouting_Route {
        ::std::default::Default::default()
    }

    // uint32 irq_id = 1;


    pub fn get_irq_id(&self) -> u32 {
        self.irq_id
    }
    pub fn clear_irq_id(&mut self) {
        self.irq_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_irq_id(&mut self, v: u32) {
        self.irq_id = v;
    }

    // .MainRequest.SetIrqRouting.Route.Irqchip irqchip = 2;


    pub fn get_irqchip(&self) -> &MainRequest_SetIrqRouting_Route_Irqchip {
        match self.route {
            ::std::option::Option::Some(MainRequest_SetIrqRouting_Route_oneof_route::irqchip(ref v)) => v,
            _ => <MainRequest_SetIrqRouting_Route_Irqchip as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_irqchip(&mut self) {
        self.route = ::std::option::Option::None;
    }

    pub fn has_irqchip(&self) -> bool {
        match self.route {
            ::std::option::Option::Some(MainRequest_SetIrqRouting_Route_oneof_route::irqchip(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_irqchip(&mut self, v: MainRequest_SetIrqRouting_Route_Irqchip) {
        self.route = ::std::option::Option::Some(MainRequest_SetIrqRouting_Route_oneof_route::irqchip(v))
    }

    // Mutable pointer to the field.
    pub fn mut_irqchip(&mut self) -> &mut MainRequest_SetIrqRouting_Route_Irqchip {
        if let ::std::option::Option::Some(MainRequest_SetIrqRouting_Route_oneof_route::irqchip(_)) = self.route {
        } else {
            self.route = ::std::option::Option::Some(MainRequest_SetIrqRouting_Route_oneof_route::irqchip(MainRequest_SetIrqRouting_Route_Irqchip::new()));
        }
        match self.route {
            ::std::option::Option::Some(MainRequest_SetIrqRouting_Route_oneof_route::irqchip(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_irqchip(&mut self) -> MainRequest_SetIrqRouting_Route_Irqchip {
        if self.has_irqchip() {
            match self.route.take() {
                ::std::option::Option::Some(MainRequest_SetIrqRouting_Route_oneof_route::irqchip(v)) => v,
                _ => panic!(),
            }
        } else {
            MainRequest_SetIrqRouting_Route_Irqchip::new()
        }
    }

    // .MainRequest.SetIrqRouting.Route.Msi msi = 3;


    pub fn get_msi(&self) -> &MainRequest_SetIrqRouting_Route_Msi {
        match self.route {
            ::std::option::Option::Some(MainRequest_SetIrqRouting_Route_oneof_route::msi(ref v)) => v,
            _ => <MainRequest_SetIrqRouting_Route_Msi as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_msi(&mut self) {
        self.route = ::std::option::Option::None;
    }

    pub fn has_msi(&self) -> bool {
        match self.route {
            ::std::option::Option::Some(MainRequest_SetIrqRouting_Route_oneof_route::msi(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_msi(&mut self, v: MainRequest_SetIrqRouting_Route_Msi) {
        self.route = ::std::option::Option::Some(MainRequest_SetIrqRouting_Route_oneof_route::msi(v))
    }

    // Mutable pointer to the field.
    pub fn mut_msi(&mut self) -> &mut MainRequest_SetIrqRouting_Route_Msi {
        if let ::std::option::Option::Some(MainRequest_SetIrqRouting_Route_oneof_route::msi(_)) = self.route {
        } else {
            self.route = ::std::option::Option::Some(MainRequest_SetIrqRouting_Route_oneof_route::msi(MainRequest_SetIrqRouting_Route_Msi::new()));
        }
        match self.route {
            ::std::option::Option::Some(MainRequest_SetIrqRouting_Route_oneof_route::msi(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_msi(&mut self) -> MainRequest_SetIrqRouting_Route_Msi {
        if self.has_msi() {
            match self.route.take() {
                ::std::option::Option::Some(MainRequest_SetIrqRouting_Route_oneof_route::msi(v)) => v,
                _ => panic!(),
            }
        } else {
            MainRequest_SetIrqRouting_Route_Msi::new()
        }
    }
}

impl ::protobuf::Message for MainRequest_SetIrqRouting_Route {
    fn is_initialized(&self) -> bool {
        if let Some(MainRequest_SetIrqRouting_Route_oneof_route::irqchip(ref v)) = self.route {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainRequest_SetIrqRouting_Route_oneof_route::msi(ref v)) = self.route {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.irq_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.route = ::std::option::Option::Some(MainRequest_SetIrqRouting_Route_oneof_route::irqchip(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.route = ::std::option::Option::Some(MainRequest_SetIrqRouting_Route_oneof_route::msi(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.irq_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.irq_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.route {
            match v {
                &MainRequest_SetIrqRouting_Route_oneof_route::irqchip(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainRequest_SetIrqRouting_Route_oneof_route::msi(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.irq_id != 0 {
            os.write_uint32(1, self.irq_id)?;
        }
        if let ::std::option::Option::Some(ref v) = self.route {
            match v {
                &MainRequest_SetIrqRouting_Route_oneof_route::irqchip(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainRequest_SetIrqRouting_Route_oneof_route::msi(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainRequest_SetIrqRouting_Route {
        MainRequest_SetIrqRouting_Route::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "irq_id",
                |m: &MainRequest_SetIrqRouting_Route| { &m.irq_id },
                |m: &mut MainRequest_SetIrqRouting_Route| { &mut m.irq_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainRequest_SetIrqRouting_Route_Irqchip>(
                "irqchip",
                MainRequest_SetIrqRouting_Route::has_irqchip,
                MainRequest_SetIrqRouting_Route::get_irqchip,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainRequest_SetIrqRouting_Route_Msi>(
                "msi",
                MainRequest_SetIrqRouting_Route::has_msi,
                MainRequest_SetIrqRouting_Route::get_msi,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainRequest_SetIrqRouting_Route>(
                "MainRequest.SetIrqRouting.Route",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainRequest_SetIrqRouting_Route {
        static instance: ::protobuf::rt::LazyV2<MainRequest_SetIrqRouting_Route> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainRequest_SetIrqRouting_Route::new)
    }
}

impl ::protobuf::Clear for MainRequest_SetIrqRouting_Route {
    fn clear(&mut self) {
        self.irq_id = 0;
        self.route = ::std::option::Option::None;
        self.route = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainRequest_SetIrqRouting_Route {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainRequest_SetIrqRouting_Route {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainRequest_SetIrqRouting_Route_Irqchip {
    // message fields
    pub irqchip: u32,
    pub pin: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainRequest_SetIrqRouting_Route_Irqchip {
    fn default() -> &'a MainRequest_SetIrqRouting_Route_Irqchip {
        <MainRequest_SetIrqRouting_Route_Irqchip as ::protobuf::Message>::default_instance()
    }
}

impl MainRequest_SetIrqRouting_Route_Irqchip {
    pub fn new() -> MainRequest_SetIrqRouting_Route_Irqchip {
        ::std::default::Default::default()
    }

    // uint32 irqchip = 1;


    pub fn get_irqchip(&self) -> u32 {
        self.irqchip
    }
    pub fn clear_irqchip(&mut self) {
        self.irqchip = 0;
    }

    // Param is passed by value, moved
    pub fn set_irqchip(&mut self, v: u32) {
        self.irqchip = v;
    }

    // uint32 pin = 2;


    pub fn get_pin(&self) -> u32 {
        self.pin
    }
    pub fn clear_pin(&mut self) {
        self.pin = 0;
    }

    // Param is passed by value, moved
    pub fn set_pin(&mut self, v: u32) {
        self.pin = v;
    }
}

impl ::protobuf::Message for MainRequest_SetIrqRouting_Route_Irqchip {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.irqchip = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pin = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.irqchip != 0 {
            my_size += ::protobuf::rt::value_size(1, self.irqchip, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.pin != 0 {
            my_size += ::protobuf::rt::value_size(2, self.pin, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.irqchip != 0 {
            os.write_uint32(1, self.irqchip)?;
        }
        if self.pin != 0 {
            os.write_uint32(2, self.pin)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainRequest_SetIrqRouting_Route_Irqchip {
        MainRequest_SetIrqRouting_Route_Irqchip::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "irqchip",
                |m: &MainRequest_SetIrqRouting_Route_Irqchip| { &m.irqchip },
                |m: &mut MainRequest_SetIrqRouting_Route_Irqchip| { &mut m.irqchip },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "pin",
                |m: &MainRequest_SetIrqRouting_Route_Irqchip| { &m.pin },
                |m: &mut MainRequest_SetIrqRouting_Route_Irqchip| { &mut m.pin },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainRequest_SetIrqRouting_Route_Irqchip>(
                "MainRequest.SetIrqRouting.Route.Irqchip",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainRequest_SetIrqRouting_Route_Irqchip {
        static instance: ::protobuf::rt::LazyV2<MainRequest_SetIrqRouting_Route_Irqchip> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainRequest_SetIrqRouting_Route_Irqchip::new)
    }
}

impl ::protobuf::Clear for MainRequest_SetIrqRouting_Route_Irqchip {
    fn clear(&mut self) {
        self.irqchip = 0;
        self.pin = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainRequest_SetIrqRouting_Route_Irqchip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainRequest_SetIrqRouting_Route_Irqchip {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainRequest_SetIrqRouting_Route_Msi {
    // message fields
    pub address: u64,
    pub data: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainRequest_SetIrqRouting_Route_Msi {
    fn default() -> &'a MainRequest_SetIrqRouting_Route_Msi {
        <MainRequest_SetIrqRouting_Route_Msi as ::protobuf::Message>::default_instance()
    }
}

impl MainRequest_SetIrqRouting_Route_Msi {
    pub fn new() -> MainRequest_SetIrqRouting_Route_Msi {
        ::std::default::Default::default()
    }

    // uint64 address = 1;


    pub fn get_address(&self) -> u64 {
        self.address
    }
    pub fn clear_address(&mut self) {
        self.address = 0;
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: u64) {
        self.address = v;
    }

    // uint32 data = 2;


    pub fn get_data(&self) -> u32 {
        self.data
    }
    pub fn clear_data(&mut self) {
        self.data = 0;
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: u32) {
        self.data = v;
    }
}

impl ::protobuf::Message for MainRequest_SetIrqRouting_Route_Msi {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.address = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.data = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::value_size(1, self.address, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.data != 0 {
            my_size += ::protobuf::rt::value_size(2, self.data, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.data != 0 {
            os.write_uint32(2, self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainRequest_SetIrqRouting_Route_Msi {
        MainRequest_SetIrqRouting_Route_Msi::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "address",
                |m: &MainRequest_SetIrqRouting_Route_Msi| { &m.address },
                |m: &mut MainRequest_SetIrqRouting_Route_Msi| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "data",
                |m: &MainRequest_SetIrqRouting_Route_Msi| { &m.data },
                |m: &mut MainRequest_SetIrqRouting_Route_Msi| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainRequest_SetIrqRouting_Route_Msi>(
                "MainRequest.SetIrqRouting.Route.Msi",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainRequest_SetIrqRouting_Route_Msi {
        static instance: ::protobuf::rt::LazyV2<MainRequest_SetIrqRouting_Route_Msi> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainRequest_SetIrqRouting_Route_Msi::new)
    }
}

impl ::protobuf::Clear for MainRequest_SetIrqRouting_Route_Msi {
    fn clear(&mut self) {
        self.address = 0;
        self.data = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainRequest_SetIrqRouting_Route_Msi {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainRequest_SetIrqRouting_Route_Msi {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainRequest_GetState {
    // message fields
    pub set: MainRequest_StateSet,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainRequest_GetState {
    fn default() -> &'a MainRequest_GetState {
        <MainRequest_GetState as ::protobuf::Message>::default_instance()
    }
}

impl MainRequest_GetState {
    pub fn new() -> MainRequest_GetState {
        ::std::default::Default::default()
    }

    // .MainRequest.StateSet set = 1;


    pub fn get_set(&self) -> MainRequest_StateSet {
        self.set
    }
    pub fn clear_set(&mut self) {
        self.set = MainRequest_StateSet::PIC0;
    }

    // Param is passed by value, moved
    pub fn set_set(&mut self, v: MainRequest_StateSet) {
        self.set = v;
    }
}

impl ::protobuf::Message for MainRequest_GetState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.set, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.set != MainRequest_StateSet::PIC0 {
            my_size += ::protobuf::rt::enum_size(1, self.set);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.set != MainRequest_StateSet::PIC0 {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.set))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainRequest_GetState {
        MainRequest_GetState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MainRequest_StateSet>>(
                "set",
                |m: &MainRequest_GetState| { &m.set },
                |m: &mut MainRequest_GetState| { &mut m.set },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainRequest_GetState>(
                "MainRequest.GetState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainRequest_GetState {
        static instance: ::protobuf::rt::LazyV2<MainRequest_GetState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainRequest_GetState::new)
    }
}

impl ::protobuf::Clear for MainRequest_GetState {
    fn clear(&mut self) {
        self.set = MainRequest_StateSet::PIC0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainRequest_GetState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainRequest_GetState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainRequest_SetState {
    // message fields
    pub set: MainRequest_StateSet,
    pub state: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainRequest_SetState {
    fn default() -> &'a MainRequest_SetState {
        <MainRequest_SetState as ::protobuf::Message>::default_instance()
    }
}

impl MainRequest_SetState {
    pub fn new() -> MainRequest_SetState {
        ::std::default::Default::default()
    }

    // .MainRequest.StateSet set = 1;


    pub fn get_set(&self) -> MainRequest_StateSet {
        self.set
    }
    pub fn clear_set(&mut self) {
        self.set = MainRequest_StateSet::PIC0;
    }

    // Param is passed by value, moved
    pub fn set_set(&mut self, v: MainRequest_StateSet) {
        self.set = v;
    }

    // bytes state = 2;


    pub fn get_state(&self) -> &[u8] {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::vec::Vec<u8>) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.state, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MainRequest_SetState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.set, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.set != MainRequest_StateSet::PIC0 {
            my_size += ::protobuf::rt::enum_size(1, self.set);
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.state);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.set != MainRequest_StateSet::PIC0 {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.set))?;
        }
        if !self.state.is_empty() {
            os.write_bytes(2, &self.state)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainRequest_SetState {
        MainRequest_SetState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MainRequest_StateSet>>(
                "set",
                |m: &MainRequest_SetState| { &m.set },
                |m: &mut MainRequest_SetState| { &mut m.set },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "state",
                |m: &MainRequest_SetState| { &m.state },
                |m: &mut MainRequest_SetState| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainRequest_SetState>(
                "MainRequest.SetState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainRequest_SetState {
        static instance: ::protobuf::rt::LazyV2<MainRequest_SetState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainRequest_SetState::new)
    }
}

impl ::protobuf::Clear for MainRequest_SetState {
    fn clear(&mut self) {
        self.set = MainRequest_StateSet::PIC0;
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainRequest_SetState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainRequest_SetState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainRequest_SetIdentityMapAddr {
    // message fields
    pub address: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainRequest_SetIdentityMapAddr {
    fn default() -> &'a MainRequest_SetIdentityMapAddr {
        <MainRequest_SetIdentityMapAddr as ::protobuf::Message>::default_instance()
    }
}

impl MainRequest_SetIdentityMapAddr {
    pub fn new() -> MainRequest_SetIdentityMapAddr {
        ::std::default::Default::default()
    }

    // uint32 address = 1;


    pub fn get_address(&self) -> u32 {
        self.address
    }
    pub fn clear_address(&mut self) {
        self.address = 0;
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: u32) {
        self.address = v;
    }
}

impl ::protobuf::Message for MainRequest_SetIdentityMapAddr {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.address = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::value_size(1, self.address, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.address != 0 {
            os.write_uint32(1, self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainRequest_SetIdentityMapAddr {
        MainRequest_SetIdentityMapAddr::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "address",
                |m: &MainRequest_SetIdentityMapAddr| { &m.address },
                |m: &mut MainRequest_SetIdentityMapAddr| { &mut m.address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainRequest_SetIdentityMapAddr>(
                "MainRequest.SetIdentityMapAddr",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainRequest_SetIdentityMapAddr {
        static instance: ::protobuf::rt::LazyV2<MainRequest_SetIdentityMapAddr> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainRequest_SetIdentityMapAddr::new)
    }
}

impl ::protobuf::Clear for MainRequest_SetIdentityMapAddr {
    fn clear(&mut self) {
        self.address = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainRequest_SetIdentityMapAddr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainRequest_SetIdentityMapAddr {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainRequest_PauseVcpus {
    // message fields
    pub cpu_mask: u64,
    pub user: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainRequest_PauseVcpus {
    fn default() -> &'a MainRequest_PauseVcpus {
        <MainRequest_PauseVcpus as ::protobuf::Message>::default_instance()
    }
}

impl MainRequest_PauseVcpus {
    pub fn new() -> MainRequest_PauseVcpus {
        ::std::default::Default::default()
    }

    // uint64 cpu_mask = 1;


    pub fn get_cpu_mask(&self) -> u64 {
        self.cpu_mask
    }
    pub fn clear_cpu_mask(&mut self) {
        self.cpu_mask = 0;
    }

    // Param is passed by value, moved
    pub fn set_cpu_mask(&mut self, v: u64) {
        self.cpu_mask = v;
    }

    // uint64 user = 2;


    pub fn get_user(&self) -> u64 {
        self.user
    }
    pub fn clear_user(&mut self) {
        self.user = 0;
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: u64) {
        self.user = v;
    }
}

impl ::protobuf::Message for MainRequest_PauseVcpus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cpu_mask = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.user = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cpu_mask != 0 {
            my_size += ::protobuf::rt::value_size(1, self.cpu_mask, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.user != 0 {
            my_size += ::protobuf::rt::value_size(2, self.user, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.cpu_mask != 0 {
            os.write_uint64(1, self.cpu_mask)?;
        }
        if self.user != 0 {
            os.write_uint64(2, self.user)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainRequest_PauseVcpus {
        MainRequest_PauseVcpus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "cpu_mask",
                |m: &MainRequest_PauseVcpus| { &m.cpu_mask },
                |m: &mut MainRequest_PauseVcpus| { &mut m.cpu_mask },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "user",
                |m: &MainRequest_PauseVcpus| { &m.user },
                |m: &mut MainRequest_PauseVcpus| { &mut m.user },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainRequest_PauseVcpus>(
                "MainRequest.PauseVcpus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainRequest_PauseVcpus {
        static instance: ::protobuf::rt::LazyV2<MainRequest_PauseVcpus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainRequest_PauseVcpus::new)
    }
}

impl ::protobuf::Clear for MainRequest_PauseVcpus {
    fn clear(&mut self) {
        self.cpu_mask = 0;
        self.user = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainRequest_PauseVcpus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainRequest_PauseVcpus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainRequest_GetVcpus {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainRequest_GetVcpus {
    fn default() -> &'a MainRequest_GetVcpus {
        <MainRequest_GetVcpus as ::protobuf::Message>::default_instance()
    }
}

impl MainRequest_GetVcpus {
    pub fn new() -> MainRequest_GetVcpus {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MainRequest_GetVcpus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainRequest_GetVcpus {
        MainRequest_GetVcpus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainRequest_GetVcpus>(
                "MainRequest.GetVcpus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainRequest_GetVcpus {
        static instance: ::protobuf::rt::LazyV2<MainRequest_GetVcpus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainRequest_GetVcpus::new)
    }
}

impl ::protobuf::Clear for MainRequest_GetVcpus {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainRequest_GetVcpus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainRequest_GetVcpus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainRequest_Start {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainRequest_Start {
    fn default() -> &'a MainRequest_Start {
        <MainRequest_Start as ::protobuf::Message>::default_instance()
    }
}

impl MainRequest_Start {
    pub fn new() -> MainRequest_Start {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MainRequest_Start {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainRequest_Start {
        MainRequest_Start::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainRequest_Start>(
                "MainRequest.Start",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainRequest_Start {
        static instance: ::protobuf::rt::LazyV2<MainRequest_Start> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainRequest_Start::new)
    }
}

impl ::protobuf::Clear for MainRequest_Start {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainRequest_Start {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainRequest_Start {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainRequest_SetCallHint {
    // message fields
    pub space: AddressSpace,
    pub address: u64,
    pub on_write: bool,
    pub hints: ::protobuf::RepeatedField<MainRequest_SetCallHint_RegHint>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainRequest_SetCallHint {
    fn default() -> &'a MainRequest_SetCallHint {
        <MainRequest_SetCallHint as ::protobuf::Message>::default_instance()
    }
}

impl MainRequest_SetCallHint {
    pub fn new() -> MainRequest_SetCallHint {
        ::std::default::Default::default()
    }

    // .AddressSpace space = 1;


    pub fn get_space(&self) -> AddressSpace {
        self.space
    }
    pub fn clear_space(&mut self) {
        self.space = AddressSpace::IOPORT;
    }

    // Param is passed by value, moved
    pub fn set_space(&mut self, v: AddressSpace) {
        self.space = v;
    }

    // uint64 address = 2;


    pub fn get_address(&self) -> u64 {
        self.address
    }
    pub fn clear_address(&mut self) {
        self.address = 0;
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: u64) {
        self.address = v;
    }

    // bool on_write = 3;


    pub fn get_on_write(&self) -> bool {
        self.on_write
    }
    pub fn clear_on_write(&mut self) {
        self.on_write = false;
    }

    // Param is passed by value, moved
    pub fn set_on_write(&mut self, v: bool) {
        self.on_write = v;
    }

    // repeated .MainRequest.SetCallHint.RegHint hints = 4;


    pub fn get_hints(&self) -> &[MainRequest_SetCallHint_RegHint] {
        &self.hints
    }
    pub fn clear_hints(&mut self) {
        self.hints.clear();
    }

    // Param is passed by value, moved
    pub fn set_hints(&mut self, v: ::protobuf::RepeatedField<MainRequest_SetCallHint_RegHint>) {
        self.hints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hints(&mut self) -> &mut ::protobuf::RepeatedField<MainRequest_SetCallHint_RegHint> {
        &mut self.hints
    }

    // Take field
    pub fn take_hints(&mut self) -> ::protobuf::RepeatedField<MainRequest_SetCallHint_RegHint> {
        ::std::mem::replace(&mut self.hints, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MainRequest_SetCallHint {
    fn is_initialized(&self) -> bool {
        for v in &self.hints {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.space, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.address = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.on_write = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hints)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.space != AddressSpace::IOPORT {
            my_size += ::protobuf::rt::enum_size(1, self.space);
        }
        if self.address != 0 {
            my_size += ::protobuf::rt::value_size(2, self.address, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.on_write != false {
            my_size += 2;
        }
        for value in &self.hints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.space != AddressSpace::IOPORT {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.space))?;
        }
        if self.address != 0 {
            os.write_uint64(2, self.address)?;
        }
        if self.on_write != false {
            os.write_bool(3, self.on_write)?;
        }
        for v in &self.hints {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainRequest_SetCallHint {
        MainRequest_SetCallHint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AddressSpace>>(
                "space",
                |m: &MainRequest_SetCallHint| { &m.space },
                |m: &mut MainRequest_SetCallHint| { &mut m.space },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "address",
                |m: &MainRequest_SetCallHint| { &m.address },
                |m: &mut MainRequest_SetCallHint| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "on_write",
                |m: &MainRequest_SetCallHint| { &m.on_write },
                |m: &mut MainRequest_SetCallHint| { &mut m.on_write },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MainRequest_SetCallHint_RegHint>>(
                "hints",
                |m: &MainRequest_SetCallHint| { &m.hints },
                |m: &mut MainRequest_SetCallHint| { &mut m.hints },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainRequest_SetCallHint>(
                "MainRequest.SetCallHint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainRequest_SetCallHint {
        static instance: ::protobuf::rt::LazyV2<MainRequest_SetCallHint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainRequest_SetCallHint::new)
    }
}

impl ::protobuf::Clear for MainRequest_SetCallHint {
    fn clear(&mut self) {
        self.space = AddressSpace::IOPORT;
        self.address = 0;
        self.on_write = false;
        self.hints.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainRequest_SetCallHint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainRequest_SetCallHint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainRequest_SetCallHint_RegHint {
    // message fields
    pub match_rax: bool,
    pub match_rbx: bool,
    pub match_rcx: bool,
    pub match_rdx: bool,
    pub rax: u64,
    pub rbx: u64,
    pub rcx: u64,
    pub rdx: u64,
    pub send_sregs: bool,
    pub send_debugregs: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainRequest_SetCallHint_RegHint {
    fn default() -> &'a MainRequest_SetCallHint_RegHint {
        <MainRequest_SetCallHint_RegHint as ::protobuf::Message>::default_instance()
    }
}

impl MainRequest_SetCallHint_RegHint {
    pub fn new() -> MainRequest_SetCallHint_RegHint {
        ::std::default::Default::default()
    }

    // bool match_rax = 1;


    pub fn get_match_rax(&self) -> bool {
        self.match_rax
    }
    pub fn clear_match_rax(&mut self) {
        self.match_rax = false;
    }

    // Param is passed by value, moved
    pub fn set_match_rax(&mut self, v: bool) {
        self.match_rax = v;
    }

    // bool match_rbx = 2;


    pub fn get_match_rbx(&self) -> bool {
        self.match_rbx
    }
    pub fn clear_match_rbx(&mut self) {
        self.match_rbx = false;
    }

    // Param is passed by value, moved
    pub fn set_match_rbx(&mut self, v: bool) {
        self.match_rbx = v;
    }

    // bool match_rcx = 3;


    pub fn get_match_rcx(&self) -> bool {
        self.match_rcx
    }
    pub fn clear_match_rcx(&mut self) {
        self.match_rcx = false;
    }

    // Param is passed by value, moved
    pub fn set_match_rcx(&mut self, v: bool) {
        self.match_rcx = v;
    }

    // bool match_rdx = 4;


    pub fn get_match_rdx(&self) -> bool {
        self.match_rdx
    }
    pub fn clear_match_rdx(&mut self) {
        self.match_rdx = false;
    }

    // Param is passed by value, moved
    pub fn set_match_rdx(&mut self, v: bool) {
        self.match_rdx = v;
    }

    // uint64 rax = 5;


    pub fn get_rax(&self) -> u64 {
        self.rax
    }
    pub fn clear_rax(&mut self) {
        self.rax = 0;
    }

    // Param is passed by value, moved
    pub fn set_rax(&mut self, v: u64) {
        self.rax = v;
    }

    // uint64 rbx = 6;


    pub fn get_rbx(&self) -> u64 {
        self.rbx
    }
    pub fn clear_rbx(&mut self) {
        self.rbx = 0;
    }

    // Param is passed by value, moved
    pub fn set_rbx(&mut self, v: u64) {
        self.rbx = v;
    }

    // uint64 rcx = 7;


    pub fn get_rcx(&self) -> u64 {
        self.rcx
    }
    pub fn clear_rcx(&mut self) {
        self.rcx = 0;
    }

    // Param is passed by value, moved
    pub fn set_rcx(&mut self, v: u64) {
        self.rcx = v;
    }

    // uint64 rdx = 8;


    pub fn get_rdx(&self) -> u64 {
        self.rdx
    }
    pub fn clear_rdx(&mut self) {
        self.rdx = 0;
    }

    // Param is passed by value, moved
    pub fn set_rdx(&mut self, v: u64) {
        self.rdx = v;
    }

    // bool send_sregs = 9;


    pub fn get_send_sregs(&self) -> bool {
        self.send_sregs
    }
    pub fn clear_send_sregs(&mut self) {
        self.send_sregs = false;
    }

    // Param is passed by value, moved
    pub fn set_send_sregs(&mut self, v: bool) {
        self.send_sregs = v;
    }

    // bool send_debugregs = 10;


    pub fn get_send_debugregs(&self) -> bool {
        self.send_debugregs
    }
    pub fn clear_send_debugregs(&mut self) {
        self.send_debugregs = false;
    }

    // Param is passed by value, moved
    pub fn set_send_debugregs(&mut self, v: bool) {
        self.send_debugregs = v;
    }
}

impl ::protobuf::Message for MainRequest_SetCallHint_RegHint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.match_rax = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.match_rbx = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.match_rcx = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.match_rdx = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rax = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rbx = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rcx = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rdx = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.send_sregs = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.send_debugregs = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.match_rax != false {
            my_size += 2;
        }
        if self.match_rbx != false {
            my_size += 2;
        }
        if self.match_rcx != false {
            my_size += 2;
        }
        if self.match_rdx != false {
            my_size += 2;
        }
        if self.rax != 0 {
            my_size += ::protobuf::rt::value_size(5, self.rax, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rbx != 0 {
            my_size += ::protobuf::rt::value_size(6, self.rbx, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rcx != 0 {
            my_size += ::protobuf::rt::value_size(7, self.rcx, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rdx != 0 {
            my_size += ::protobuf::rt::value_size(8, self.rdx, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.send_sregs != false {
            my_size += 2;
        }
        if self.send_debugregs != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.match_rax != false {
            os.write_bool(1, self.match_rax)?;
        }
        if self.match_rbx != false {
            os.write_bool(2, self.match_rbx)?;
        }
        if self.match_rcx != false {
            os.write_bool(3, self.match_rcx)?;
        }
        if self.match_rdx != false {
            os.write_bool(4, self.match_rdx)?;
        }
        if self.rax != 0 {
            os.write_uint64(5, self.rax)?;
        }
        if self.rbx != 0 {
            os.write_uint64(6, self.rbx)?;
        }
        if self.rcx != 0 {
            os.write_uint64(7, self.rcx)?;
        }
        if self.rdx != 0 {
            os.write_uint64(8, self.rdx)?;
        }
        if self.send_sregs != false {
            os.write_bool(9, self.send_sregs)?;
        }
        if self.send_debugregs != false {
            os.write_bool(10, self.send_debugregs)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainRequest_SetCallHint_RegHint {
        MainRequest_SetCallHint_RegHint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "match_rax",
                |m: &MainRequest_SetCallHint_RegHint| { &m.match_rax },
                |m: &mut MainRequest_SetCallHint_RegHint| { &mut m.match_rax },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "match_rbx",
                |m: &MainRequest_SetCallHint_RegHint| { &m.match_rbx },
                |m: &mut MainRequest_SetCallHint_RegHint| { &mut m.match_rbx },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "match_rcx",
                |m: &MainRequest_SetCallHint_RegHint| { &m.match_rcx },
                |m: &mut MainRequest_SetCallHint_RegHint| { &mut m.match_rcx },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "match_rdx",
                |m: &MainRequest_SetCallHint_RegHint| { &m.match_rdx },
                |m: &mut MainRequest_SetCallHint_RegHint| { &mut m.match_rdx },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "rax",
                |m: &MainRequest_SetCallHint_RegHint| { &m.rax },
                |m: &mut MainRequest_SetCallHint_RegHint| { &mut m.rax },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "rbx",
                |m: &MainRequest_SetCallHint_RegHint| { &m.rbx },
                |m: &mut MainRequest_SetCallHint_RegHint| { &mut m.rbx },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "rcx",
                |m: &MainRequest_SetCallHint_RegHint| { &m.rcx },
                |m: &mut MainRequest_SetCallHint_RegHint| { &mut m.rcx },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "rdx",
                |m: &MainRequest_SetCallHint_RegHint| { &m.rdx },
                |m: &mut MainRequest_SetCallHint_RegHint| { &mut m.rdx },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "send_sregs",
                |m: &MainRequest_SetCallHint_RegHint| { &m.send_sregs },
                |m: &mut MainRequest_SetCallHint_RegHint| { &mut m.send_sregs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "send_debugregs",
                |m: &MainRequest_SetCallHint_RegHint| { &m.send_debugregs },
                |m: &mut MainRequest_SetCallHint_RegHint| { &mut m.send_debugregs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainRequest_SetCallHint_RegHint>(
                "MainRequest.SetCallHint.RegHint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainRequest_SetCallHint_RegHint {
        static instance: ::protobuf::rt::LazyV2<MainRequest_SetCallHint_RegHint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainRequest_SetCallHint_RegHint::new)
    }
}

impl ::protobuf::Clear for MainRequest_SetCallHint_RegHint {
    fn clear(&mut self) {
        self.match_rax = false;
        self.match_rbx = false;
        self.match_rcx = false;
        self.match_rdx = false;
        self.rax = 0;
        self.rbx = 0;
        self.rcx = 0;
        self.rdx = 0;
        self.send_sregs = false;
        self.send_debugregs = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainRequest_SetCallHint_RegHint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainRequest_SetCallHint_RegHint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainRequest_MemoryDirtyLog {
    // message fields
    pub id: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainRequest_MemoryDirtyLog {
    fn default() -> &'a MainRequest_MemoryDirtyLog {
        <MainRequest_MemoryDirtyLog as ::protobuf::Message>::default_instance()
    }
}

impl MainRequest_MemoryDirtyLog {
    pub fn new() -> MainRequest_MemoryDirtyLog {
        ::std::default::Default::default()
    }

    // uint32 id = 1;


    pub fn get_id(&self) -> u32 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }
}

impl ::protobuf::Message for MainRequest_MemoryDirtyLog {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainRequest_MemoryDirtyLog {
        MainRequest_MemoryDirtyLog::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "id",
                |m: &MainRequest_MemoryDirtyLog| { &m.id },
                |m: &mut MainRequest_MemoryDirtyLog| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainRequest_MemoryDirtyLog>(
                "MainRequest.MemoryDirtyLog",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainRequest_MemoryDirtyLog {
        static instance: ::protobuf::rt::LazyV2<MainRequest_MemoryDirtyLog> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainRequest_MemoryDirtyLog::new)
    }
}

impl ::protobuf::Clear for MainRequest_MemoryDirtyLog {
    fn clear(&mut self) {
        self.id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainRequest_MemoryDirtyLog {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainRequest_MemoryDirtyLog {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MainRequest_StateSet {
    PIC0 = 0,
    PIC1 = 1,
    IOAPIC = 2,
    PIT = 3,
    CLOCK = 4,
}

impl ::protobuf::ProtobufEnum for MainRequest_StateSet {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MainRequest_StateSet> {
        match value {
            0 => ::std::option::Option::Some(MainRequest_StateSet::PIC0),
            1 => ::std::option::Option::Some(MainRequest_StateSet::PIC1),
            2 => ::std::option::Option::Some(MainRequest_StateSet::IOAPIC),
            3 => ::std::option::Option::Some(MainRequest_StateSet::PIT),
            4 => ::std::option::Option::Some(MainRequest_StateSet::CLOCK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MainRequest_StateSet] = &[
            MainRequest_StateSet::PIC0,
            MainRequest_StateSet::PIC1,
            MainRequest_StateSet::IOAPIC,
            MainRequest_StateSet::PIT,
            MainRequest_StateSet::CLOCK,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<MainRequest_StateSet>("MainRequest.StateSet", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for MainRequest_StateSet {
}

impl ::std::default::Default for MainRequest_StateSet {
    fn default() -> Self {
        MainRequest_StateSet::PIC0
    }
}

impl ::protobuf::reflect::ProtobufValue for MainRequest_StateSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainResponse {
    // message fields
    pub errno: i32,
    // message oneof groups
    pub message: ::std::option::Option<MainResponse_oneof_message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainResponse {
    fn default() -> &'a MainResponse {
        <MainResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum MainResponse_oneof_message {
    create(MainResponse_Create),
    destroy(MainResponse_Destroy),
    new_connection(MainResponse_NewConnection),
    get_shutdown_eventfd(MainResponse_GetShutdownEventfd),
    check_extension(MainResponse_CheckExtension),
    get_supported_cpuid(MainResponse_CpuidResponse),
    get_emulated_cpuid(MainResponse_CpuidResponse),
    get_msr_index_list(MainResponse_MsrListResponse),
    get_net_config(MainResponse_GetNetConfig),
    reserve_range(MainResponse_ReserveRange),
    set_irq(MainResponse_SetIrq),
    set_irq_routing(MainResponse_SetIrqRouting),
    get_state(MainResponse_GetState),
    set_state(MainResponse_SetState),
    set_identity_map_addr(MainResponse_SetIdentityMapAddr),
    pause_vcpus(MainResponse_PauseVcpus),
    get_vcpus(MainResponse_GetVcpus),
    start(MainResponse_Start),
    set_call_hint(MainResponse_SetCallHint),
    dirty_log(MainResponse_MemoryDirtyLog),
}

impl MainResponse {
    pub fn new() -> MainResponse {
        ::std::default::Default::default()
    }

    // sint32 errno = 1;


    pub fn get_errno(&self) -> i32 {
        self.errno
    }
    pub fn clear_errno(&mut self) {
        self.errno = 0;
    }

    // Param is passed by value, moved
    pub fn set_errno(&mut self, v: i32) {
        self.errno = v;
    }

    // .MainResponse.Create create = 2;


    pub fn get_create(&self) -> &MainResponse_Create {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::create(ref v)) => v,
            _ => <MainResponse_Create as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_create(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_create(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::create(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create(&mut self, v: MainResponse_Create) {
        self.message = ::std::option::Option::Some(MainResponse_oneof_message::create(v))
    }

    // Mutable pointer to the field.
    pub fn mut_create(&mut self) -> &mut MainResponse_Create {
        if let ::std::option::Option::Some(MainResponse_oneof_message::create(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainResponse_oneof_message::create(MainResponse_Create::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::create(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_create(&mut self) -> MainResponse_Create {
        if self.has_create() {
            match self.message.take() {
                ::std::option::Option::Some(MainResponse_oneof_message::create(v)) => v,
                _ => panic!(),
            }
        } else {
            MainResponse_Create::new()
        }
    }

    // .MainResponse.Destroy destroy = 3;


    pub fn get_destroy(&self) -> &MainResponse_Destroy {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::destroy(ref v)) => v,
            _ => <MainResponse_Destroy as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_destroy(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_destroy(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::destroy(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_destroy(&mut self, v: MainResponse_Destroy) {
        self.message = ::std::option::Option::Some(MainResponse_oneof_message::destroy(v))
    }

    // Mutable pointer to the field.
    pub fn mut_destroy(&mut self) -> &mut MainResponse_Destroy {
        if let ::std::option::Option::Some(MainResponse_oneof_message::destroy(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainResponse_oneof_message::destroy(MainResponse_Destroy::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::destroy(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_destroy(&mut self) -> MainResponse_Destroy {
        if self.has_destroy() {
            match self.message.take() {
                ::std::option::Option::Some(MainResponse_oneof_message::destroy(v)) => v,
                _ => panic!(),
            }
        } else {
            MainResponse_Destroy::new()
        }
    }

    // .MainResponse.NewConnection new_connection = 4;


    pub fn get_new_connection(&self) -> &MainResponse_NewConnection {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::new_connection(ref v)) => v,
            _ => <MainResponse_NewConnection as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_new_connection(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_new_connection(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::new_connection(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_new_connection(&mut self, v: MainResponse_NewConnection) {
        self.message = ::std::option::Option::Some(MainResponse_oneof_message::new_connection(v))
    }

    // Mutable pointer to the field.
    pub fn mut_new_connection(&mut self) -> &mut MainResponse_NewConnection {
        if let ::std::option::Option::Some(MainResponse_oneof_message::new_connection(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainResponse_oneof_message::new_connection(MainResponse_NewConnection::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::new_connection(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_new_connection(&mut self) -> MainResponse_NewConnection {
        if self.has_new_connection() {
            match self.message.take() {
                ::std::option::Option::Some(MainResponse_oneof_message::new_connection(v)) => v,
                _ => panic!(),
            }
        } else {
            MainResponse_NewConnection::new()
        }
    }

    // .MainResponse.GetShutdownEventfd get_shutdown_eventfd = 5;


    pub fn get_get_shutdown_eventfd(&self) -> &MainResponse_GetShutdownEventfd {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::get_shutdown_eventfd(ref v)) => v,
            _ => <MainResponse_GetShutdownEventfd as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_get_shutdown_eventfd(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_shutdown_eventfd(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::get_shutdown_eventfd(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_shutdown_eventfd(&mut self, v: MainResponse_GetShutdownEventfd) {
        self.message = ::std::option::Option::Some(MainResponse_oneof_message::get_shutdown_eventfd(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_shutdown_eventfd(&mut self) -> &mut MainResponse_GetShutdownEventfd {
        if let ::std::option::Option::Some(MainResponse_oneof_message::get_shutdown_eventfd(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainResponse_oneof_message::get_shutdown_eventfd(MainResponse_GetShutdownEventfd::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::get_shutdown_eventfd(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_shutdown_eventfd(&mut self) -> MainResponse_GetShutdownEventfd {
        if self.has_get_shutdown_eventfd() {
            match self.message.take() {
                ::std::option::Option::Some(MainResponse_oneof_message::get_shutdown_eventfd(v)) => v,
                _ => panic!(),
            }
        } else {
            MainResponse_GetShutdownEventfd::new()
        }
    }

    // .MainResponse.CheckExtension check_extension = 6;


    pub fn get_check_extension(&self) -> &MainResponse_CheckExtension {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::check_extension(ref v)) => v,
            _ => <MainResponse_CheckExtension as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_check_extension(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_check_extension(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::check_extension(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_check_extension(&mut self, v: MainResponse_CheckExtension) {
        self.message = ::std::option::Option::Some(MainResponse_oneof_message::check_extension(v))
    }

    // Mutable pointer to the field.
    pub fn mut_check_extension(&mut self) -> &mut MainResponse_CheckExtension {
        if let ::std::option::Option::Some(MainResponse_oneof_message::check_extension(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainResponse_oneof_message::check_extension(MainResponse_CheckExtension::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::check_extension(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_check_extension(&mut self) -> MainResponse_CheckExtension {
        if self.has_check_extension() {
            match self.message.take() {
                ::std::option::Option::Some(MainResponse_oneof_message::check_extension(v)) => v,
                _ => panic!(),
            }
        } else {
            MainResponse_CheckExtension::new()
        }
    }

    // .MainResponse.CpuidResponse get_supported_cpuid = 7;


    pub fn get_get_supported_cpuid(&self) -> &MainResponse_CpuidResponse {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::get_supported_cpuid(ref v)) => v,
            _ => <MainResponse_CpuidResponse as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_get_supported_cpuid(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_supported_cpuid(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::get_supported_cpuid(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_supported_cpuid(&mut self, v: MainResponse_CpuidResponse) {
        self.message = ::std::option::Option::Some(MainResponse_oneof_message::get_supported_cpuid(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_supported_cpuid(&mut self) -> &mut MainResponse_CpuidResponse {
        if let ::std::option::Option::Some(MainResponse_oneof_message::get_supported_cpuid(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainResponse_oneof_message::get_supported_cpuid(MainResponse_CpuidResponse::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::get_supported_cpuid(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_supported_cpuid(&mut self) -> MainResponse_CpuidResponse {
        if self.has_get_supported_cpuid() {
            match self.message.take() {
                ::std::option::Option::Some(MainResponse_oneof_message::get_supported_cpuid(v)) => v,
                _ => panic!(),
            }
        } else {
            MainResponse_CpuidResponse::new()
        }
    }

    // .MainResponse.CpuidResponse get_emulated_cpuid = 8;


    pub fn get_get_emulated_cpuid(&self) -> &MainResponse_CpuidResponse {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::get_emulated_cpuid(ref v)) => v,
            _ => <MainResponse_CpuidResponse as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_get_emulated_cpuid(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_emulated_cpuid(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::get_emulated_cpuid(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_emulated_cpuid(&mut self, v: MainResponse_CpuidResponse) {
        self.message = ::std::option::Option::Some(MainResponse_oneof_message::get_emulated_cpuid(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_emulated_cpuid(&mut self) -> &mut MainResponse_CpuidResponse {
        if let ::std::option::Option::Some(MainResponse_oneof_message::get_emulated_cpuid(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainResponse_oneof_message::get_emulated_cpuid(MainResponse_CpuidResponse::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::get_emulated_cpuid(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_emulated_cpuid(&mut self) -> MainResponse_CpuidResponse {
        if self.has_get_emulated_cpuid() {
            match self.message.take() {
                ::std::option::Option::Some(MainResponse_oneof_message::get_emulated_cpuid(v)) => v,
                _ => panic!(),
            }
        } else {
            MainResponse_CpuidResponse::new()
        }
    }

    // .MainResponse.MsrListResponse get_msr_index_list = 9;


    pub fn get_get_msr_index_list(&self) -> &MainResponse_MsrListResponse {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::get_msr_index_list(ref v)) => v,
            _ => <MainResponse_MsrListResponse as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_get_msr_index_list(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_msr_index_list(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::get_msr_index_list(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_msr_index_list(&mut self, v: MainResponse_MsrListResponse) {
        self.message = ::std::option::Option::Some(MainResponse_oneof_message::get_msr_index_list(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_msr_index_list(&mut self) -> &mut MainResponse_MsrListResponse {
        if let ::std::option::Option::Some(MainResponse_oneof_message::get_msr_index_list(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainResponse_oneof_message::get_msr_index_list(MainResponse_MsrListResponse::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::get_msr_index_list(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_msr_index_list(&mut self) -> MainResponse_MsrListResponse {
        if self.has_get_msr_index_list() {
            match self.message.take() {
                ::std::option::Option::Some(MainResponse_oneof_message::get_msr_index_list(v)) => v,
                _ => panic!(),
            }
        } else {
            MainResponse_MsrListResponse::new()
        }
    }

    // .MainResponse.GetNetConfig get_net_config = 10;


    pub fn get_get_net_config(&self) -> &MainResponse_GetNetConfig {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::get_net_config(ref v)) => v,
            _ => <MainResponse_GetNetConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_get_net_config(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_net_config(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::get_net_config(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_net_config(&mut self, v: MainResponse_GetNetConfig) {
        self.message = ::std::option::Option::Some(MainResponse_oneof_message::get_net_config(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_net_config(&mut self) -> &mut MainResponse_GetNetConfig {
        if let ::std::option::Option::Some(MainResponse_oneof_message::get_net_config(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainResponse_oneof_message::get_net_config(MainResponse_GetNetConfig::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::get_net_config(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_net_config(&mut self) -> MainResponse_GetNetConfig {
        if self.has_get_net_config() {
            match self.message.take() {
                ::std::option::Option::Some(MainResponse_oneof_message::get_net_config(v)) => v,
                _ => panic!(),
            }
        } else {
            MainResponse_GetNetConfig::new()
        }
    }

    // .MainResponse.ReserveRange reserve_range = 11;


    pub fn get_reserve_range(&self) -> &MainResponse_ReserveRange {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::reserve_range(ref v)) => v,
            _ => <MainResponse_ReserveRange as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_reserve_range(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_reserve_range(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::reserve_range(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_reserve_range(&mut self, v: MainResponse_ReserveRange) {
        self.message = ::std::option::Option::Some(MainResponse_oneof_message::reserve_range(v))
    }

    // Mutable pointer to the field.
    pub fn mut_reserve_range(&mut self) -> &mut MainResponse_ReserveRange {
        if let ::std::option::Option::Some(MainResponse_oneof_message::reserve_range(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainResponse_oneof_message::reserve_range(MainResponse_ReserveRange::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::reserve_range(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_reserve_range(&mut self) -> MainResponse_ReserveRange {
        if self.has_reserve_range() {
            match self.message.take() {
                ::std::option::Option::Some(MainResponse_oneof_message::reserve_range(v)) => v,
                _ => panic!(),
            }
        } else {
            MainResponse_ReserveRange::new()
        }
    }

    // .MainResponse.SetIrq set_irq = 12;


    pub fn get_set_irq(&self) -> &MainResponse_SetIrq {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::set_irq(ref v)) => v,
            _ => <MainResponse_SetIrq as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_set_irq(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_set_irq(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::set_irq(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_irq(&mut self, v: MainResponse_SetIrq) {
        self.message = ::std::option::Option::Some(MainResponse_oneof_message::set_irq(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_irq(&mut self) -> &mut MainResponse_SetIrq {
        if let ::std::option::Option::Some(MainResponse_oneof_message::set_irq(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainResponse_oneof_message::set_irq(MainResponse_SetIrq::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::set_irq(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_irq(&mut self) -> MainResponse_SetIrq {
        if self.has_set_irq() {
            match self.message.take() {
                ::std::option::Option::Some(MainResponse_oneof_message::set_irq(v)) => v,
                _ => panic!(),
            }
        } else {
            MainResponse_SetIrq::new()
        }
    }

    // .MainResponse.SetIrqRouting set_irq_routing = 13;


    pub fn get_set_irq_routing(&self) -> &MainResponse_SetIrqRouting {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::set_irq_routing(ref v)) => v,
            _ => <MainResponse_SetIrqRouting as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_set_irq_routing(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_set_irq_routing(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::set_irq_routing(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_irq_routing(&mut self, v: MainResponse_SetIrqRouting) {
        self.message = ::std::option::Option::Some(MainResponse_oneof_message::set_irq_routing(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_irq_routing(&mut self) -> &mut MainResponse_SetIrqRouting {
        if let ::std::option::Option::Some(MainResponse_oneof_message::set_irq_routing(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainResponse_oneof_message::set_irq_routing(MainResponse_SetIrqRouting::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::set_irq_routing(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_irq_routing(&mut self) -> MainResponse_SetIrqRouting {
        if self.has_set_irq_routing() {
            match self.message.take() {
                ::std::option::Option::Some(MainResponse_oneof_message::set_irq_routing(v)) => v,
                _ => panic!(),
            }
        } else {
            MainResponse_SetIrqRouting::new()
        }
    }

    // .MainResponse.GetState get_state = 14;


    pub fn get_get_state(&self) -> &MainResponse_GetState {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::get_state(ref v)) => v,
            _ => <MainResponse_GetState as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_get_state(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_state(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::get_state(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_state(&mut self, v: MainResponse_GetState) {
        self.message = ::std::option::Option::Some(MainResponse_oneof_message::get_state(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_state(&mut self) -> &mut MainResponse_GetState {
        if let ::std::option::Option::Some(MainResponse_oneof_message::get_state(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainResponse_oneof_message::get_state(MainResponse_GetState::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::get_state(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_state(&mut self) -> MainResponse_GetState {
        if self.has_get_state() {
            match self.message.take() {
                ::std::option::Option::Some(MainResponse_oneof_message::get_state(v)) => v,
                _ => panic!(),
            }
        } else {
            MainResponse_GetState::new()
        }
    }

    // .MainResponse.SetState set_state = 15;


    pub fn get_set_state(&self) -> &MainResponse_SetState {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::set_state(ref v)) => v,
            _ => <MainResponse_SetState as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_set_state(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_set_state(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::set_state(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_state(&mut self, v: MainResponse_SetState) {
        self.message = ::std::option::Option::Some(MainResponse_oneof_message::set_state(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_state(&mut self) -> &mut MainResponse_SetState {
        if let ::std::option::Option::Some(MainResponse_oneof_message::set_state(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainResponse_oneof_message::set_state(MainResponse_SetState::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::set_state(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_state(&mut self) -> MainResponse_SetState {
        if self.has_set_state() {
            match self.message.take() {
                ::std::option::Option::Some(MainResponse_oneof_message::set_state(v)) => v,
                _ => panic!(),
            }
        } else {
            MainResponse_SetState::new()
        }
    }

    // .MainResponse.SetIdentityMapAddr set_identity_map_addr = 16;


    pub fn get_set_identity_map_addr(&self) -> &MainResponse_SetIdentityMapAddr {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::set_identity_map_addr(ref v)) => v,
            _ => <MainResponse_SetIdentityMapAddr as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_set_identity_map_addr(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_set_identity_map_addr(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::set_identity_map_addr(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_identity_map_addr(&mut self, v: MainResponse_SetIdentityMapAddr) {
        self.message = ::std::option::Option::Some(MainResponse_oneof_message::set_identity_map_addr(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_identity_map_addr(&mut self) -> &mut MainResponse_SetIdentityMapAddr {
        if let ::std::option::Option::Some(MainResponse_oneof_message::set_identity_map_addr(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainResponse_oneof_message::set_identity_map_addr(MainResponse_SetIdentityMapAddr::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::set_identity_map_addr(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_identity_map_addr(&mut self) -> MainResponse_SetIdentityMapAddr {
        if self.has_set_identity_map_addr() {
            match self.message.take() {
                ::std::option::Option::Some(MainResponse_oneof_message::set_identity_map_addr(v)) => v,
                _ => panic!(),
            }
        } else {
            MainResponse_SetIdentityMapAddr::new()
        }
    }

    // .MainResponse.PauseVcpus pause_vcpus = 17;


    pub fn get_pause_vcpus(&self) -> &MainResponse_PauseVcpus {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::pause_vcpus(ref v)) => v,
            _ => <MainResponse_PauseVcpus as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_pause_vcpus(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_pause_vcpus(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::pause_vcpus(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pause_vcpus(&mut self, v: MainResponse_PauseVcpus) {
        self.message = ::std::option::Option::Some(MainResponse_oneof_message::pause_vcpus(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pause_vcpus(&mut self) -> &mut MainResponse_PauseVcpus {
        if let ::std::option::Option::Some(MainResponse_oneof_message::pause_vcpus(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainResponse_oneof_message::pause_vcpus(MainResponse_PauseVcpus::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::pause_vcpus(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pause_vcpus(&mut self) -> MainResponse_PauseVcpus {
        if self.has_pause_vcpus() {
            match self.message.take() {
                ::std::option::Option::Some(MainResponse_oneof_message::pause_vcpus(v)) => v,
                _ => panic!(),
            }
        } else {
            MainResponse_PauseVcpus::new()
        }
    }

    // .MainResponse.GetVcpus get_vcpus = 18;


    pub fn get_get_vcpus(&self) -> &MainResponse_GetVcpus {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::get_vcpus(ref v)) => v,
            _ => <MainResponse_GetVcpus as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_get_vcpus(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_vcpus(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::get_vcpus(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_vcpus(&mut self, v: MainResponse_GetVcpus) {
        self.message = ::std::option::Option::Some(MainResponse_oneof_message::get_vcpus(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_vcpus(&mut self) -> &mut MainResponse_GetVcpus {
        if let ::std::option::Option::Some(MainResponse_oneof_message::get_vcpus(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainResponse_oneof_message::get_vcpus(MainResponse_GetVcpus::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::get_vcpus(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_vcpus(&mut self) -> MainResponse_GetVcpus {
        if self.has_get_vcpus() {
            match self.message.take() {
                ::std::option::Option::Some(MainResponse_oneof_message::get_vcpus(v)) => v,
                _ => panic!(),
            }
        } else {
            MainResponse_GetVcpus::new()
        }
    }

    // .MainResponse.Start start = 19;


    pub fn get_start(&self) -> &MainResponse_Start {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::start(ref v)) => v,
            _ => <MainResponse_Start as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_start(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::start(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: MainResponse_Start) {
        self.message = ::std::option::Option::Some(MainResponse_oneof_message::start(v))
    }

    // Mutable pointer to the field.
    pub fn mut_start(&mut self) -> &mut MainResponse_Start {
        if let ::std::option::Option::Some(MainResponse_oneof_message::start(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainResponse_oneof_message::start(MainResponse_Start::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::start(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_start(&mut self) -> MainResponse_Start {
        if self.has_start() {
            match self.message.take() {
                ::std::option::Option::Some(MainResponse_oneof_message::start(v)) => v,
                _ => panic!(),
            }
        } else {
            MainResponse_Start::new()
        }
    }

    // .MainResponse.SetCallHint set_call_hint = 20;


    pub fn get_set_call_hint(&self) -> &MainResponse_SetCallHint {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::set_call_hint(ref v)) => v,
            _ => <MainResponse_SetCallHint as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_set_call_hint(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_set_call_hint(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::set_call_hint(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_call_hint(&mut self, v: MainResponse_SetCallHint) {
        self.message = ::std::option::Option::Some(MainResponse_oneof_message::set_call_hint(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_call_hint(&mut self) -> &mut MainResponse_SetCallHint {
        if let ::std::option::Option::Some(MainResponse_oneof_message::set_call_hint(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainResponse_oneof_message::set_call_hint(MainResponse_SetCallHint::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::set_call_hint(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_call_hint(&mut self) -> MainResponse_SetCallHint {
        if self.has_set_call_hint() {
            match self.message.take() {
                ::std::option::Option::Some(MainResponse_oneof_message::set_call_hint(v)) => v,
                _ => panic!(),
            }
        } else {
            MainResponse_SetCallHint::new()
        }
    }

    // .MainResponse.MemoryDirtyLog dirty_log = 101;


    pub fn get_dirty_log(&self) -> &MainResponse_MemoryDirtyLog {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::dirty_log(ref v)) => v,
            _ => <MainResponse_MemoryDirtyLog as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_dirty_log(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_dirty_log(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::dirty_log(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dirty_log(&mut self, v: MainResponse_MemoryDirtyLog) {
        self.message = ::std::option::Option::Some(MainResponse_oneof_message::dirty_log(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dirty_log(&mut self) -> &mut MainResponse_MemoryDirtyLog {
        if let ::std::option::Option::Some(MainResponse_oneof_message::dirty_log(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(MainResponse_oneof_message::dirty_log(MainResponse_MemoryDirtyLog::new()));
        }
        match self.message {
            ::std::option::Option::Some(MainResponse_oneof_message::dirty_log(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dirty_log(&mut self) -> MainResponse_MemoryDirtyLog {
        if self.has_dirty_log() {
            match self.message.take() {
                ::std::option::Option::Some(MainResponse_oneof_message::dirty_log(v)) => v,
                _ => panic!(),
            }
        } else {
            MainResponse_MemoryDirtyLog::new()
        }
    }
}

impl ::protobuf::Message for MainResponse {
    fn is_initialized(&self) -> bool {
        if let Some(MainResponse_oneof_message::create(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainResponse_oneof_message::destroy(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainResponse_oneof_message::new_connection(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainResponse_oneof_message::get_shutdown_eventfd(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainResponse_oneof_message::check_extension(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainResponse_oneof_message::get_supported_cpuid(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainResponse_oneof_message::get_emulated_cpuid(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainResponse_oneof_message::get_msr_index_list(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainResponse_oneof_message::get_net_config(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainResponse_oneof_message::reserve_range(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainResponse_oneof_message::set_irq(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainResponse_oneof_message::set_irq_routing(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainResponse_oneof_message::get_state(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainResponse_oneof_message::set_state(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainResponse_oneof_message::set_identity_map_addr(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainResponse_oneof_message::pause_vcpus(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainResponse_oneof_message::get_vcpus(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainResponse_oneof_message::start(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainResponse_oneof_message::set_call_hint(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MainResponse_oneof_message::dirty_log(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.errno = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainResponse_oneof_message::create(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainResponse_oneof_message::destroy(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainResponse_oneof_message::new_connection(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainResponse_oneof_message::get_shutdown_eventfd(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainResponse_oneof_message::check_extension(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainResponse_oneof_message::get_supported_cpuid(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainResponse_oneof_message::get_emulated_cpuid(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainResponse_oneof_message::get_msr_index_list(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainResponse_oneof_message::get_net_config(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainResponse_oneof_message::reserve_range(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainResponse_oneof_message::set_irq(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainResponse_oneof_message::set_irq_routing(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainResponse_oneof_message::get_state(is.read_message()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainResponse_oneof_message::set_state(is.read_message()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainResponse_oneof_message::set_identity_map_addr(is.read_message()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainResponse_oneof_message::pause_vcpus(is.read_message()?));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainResponse_oneof_message::get_vcpus(is.read_message()?));
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainResponse_oneof_message::start(is.read_message()?));
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainResponse_oneof_message::set_call_hint(is.read_message()?));
                },
                101 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(MainResponse_oneof_message::dirty_log(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.errno != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, self.errno);
        }
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &MainResponse_oneof_message::create(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainResponse_oneof_message::destroy(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainResponse_oneof_message::new_connection(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainResponse_oneof_message::get_shutdown_eventfd(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainResponse_oneof_message::check_extension(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainResponse_oneof_message::get_supported_cpuid(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainResponse_oneof_message::get_emulated_cpuid(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainResponse_oneof_message::get_msr_index_list(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainResponse_oneof_message::get_net_config(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainResponse_oneof_message::reserve_range(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainResponse_oneof_message::set_irq(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainResponse_oneof_message::set_irq_routing(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainResponse_oneof_message::get_state(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainResponse_oneof_message::set_state(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainResponse_oneof_message::set_identity_map_addr(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainResponse_oneof_message::pause_vcpus(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainResponse_oneof_message::get_vcpus(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainResponse_oneof_message::start(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainResponse_oneof_message::set_call_hint(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MainResponse_oneof_message::dirty_log(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.errno != 0 {
            os.write_sint32(1, self.errno)?;
        }
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &MainResponse_oneof_message::create(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainResponse_oneof_message::destroy(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainResponse_oneof_message::new_connection(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainResponse_oneof_message::get_shutdown_eventfd(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainResponse_oneof_message::check_extension(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainResponse_oneof_message::get_supported_cpuid(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainResponse_oneof_message::get_emulated_cpuid(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainResponse_oneof_message::get_msr_index_list(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainResponse_oneof_message::get_net_config(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainResponse_oneof_message::reserve_range(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainResponse_oneof_message::set_irq(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainResponse_oneof_message::set_irq_routing(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainResponse_oneof_message::get_state(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainResponse_oneof_message::set_state(ref v) => {
                    os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainResponse_oneof_message::set_identity_map_addr(ref v) => {
                    os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainResponse_oneof_message::pause_vcpus(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainResponse_oneof_message::get_vcpus(ref v) => {
                    os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainResponse_oneof_message::start(ref v) => {
                    os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainResponse_oneof_message::set_call_hint(ref v) => {
                    os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MainResponse_oneof_message::dirty_log(ref v) => {
                    os.write_tag(101, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainResponse {
        MainResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "errno",
                |m: &MainResponse| { &m.errno },
                |m: &mut MainResponse| { &mut m.errno },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainResponse_Create>(
                "create",
                MainResponse::has_create,
                MainResponse::get_create,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainResponse_Destroy>(
                "destroy",
                MainResponse::has_destroy,
                MainResponse::get_destroy,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainResponse_NewConnection>(
                "new_connection",
                MainResponse::has_new_connection,
                MainResponse::get_new_connection,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainResponse_GetShutdownEventfd>(
                "get_shutdown_eventfd",
                MainResponse::has_get_shutdown_eventfd,
                MainResponse::get_get_shutdown_eventfd,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainResponse_CheckExtension>(
                "check_extension",
                MainResponse::has_check_extension,
                MainResponse::get_check_extension,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainResponse_CpuidResponse>(
                "get_supported_cpuid",
                MainResponse::has_get_supported_cpuid,
                MainResponse::get_get_supported_cpuid,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainResponse_CpuidResponse>(
                "get_emulated_cpuid",
                MainResponse::has_get_emulated_cpuid,
                MainResponse::get_get_emulated_cpuid,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainResponse_MsrListResponse>(
                "get_msr_index_list",
                MainResponse::has_get_msr_index_list,
                MainResponse::get_get_msr_index_list,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainResponse_GetNetConfig>(
                "get_net_config",
                MainResponse::has_get_net_config,
                MainResponse::get_get_net_config,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainResponse_ReserveRange>(
                "reserve_range",
                MainResponse::has_reserve_range,
                MainResponse::get_reserve_range,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainResponse_SetIrq>(
                "set_irq",
                MainResponse::has_set_irq,
                MainResponse::get_set_irq,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainResponse_SetIrqRouting>(
                "set_irq_routing",
                MainResponse::has_set_irq_routing,
                MainResponse::get_set_irq_routing,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainResponse_GetState>(
                "get_state",
                MainResponse::has_get_state,
                MainResponse::get_get_state,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainResponse_SetState>(
                "set_state",
                MainResponse::has_set_state,
                MainResponse::get_set_state,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainResponse_SetIdentityMapAddr>(
                "set_identity_map_addr",
                MainResponse::has_set_identity_map_addr,
                MainResponse::get_set_identity_map_addr,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainResponse_PauseVcpus>(
                "pause_vcpus",
                MainResponse::has_pause_vcpus,
                MainResponse::get_pause_vcpus,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainResponse_GetVcpus>(
                "get_vcpus",
                MainResponse::has_get_vcpus,
                MainResponse::get_get_vcpus,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainResponse_Start>(
                "start",
                MainResponse::has_start,
                MainResponse::get_start,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainResponse_SetCallHint>(
                "set_call_hint",
                MainResponse::has_set_call_hint,
                MainResponse::get_set_call_hint,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MainResponse_MemoryDirtyLog>(
                "dirty_log",
                MainResponse::has_dirty_log,
                MainResponse::get_dirty_log,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainResponse>(
                "MainResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainResponse {
        static instance: ::protobuf::rt::LazyV2<MainResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainResponse::new)
    }
}

impl ::protobuf::Clear for MainResponse {
    fn clear(&mut self) {
        self.errno = 0;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainResponse_Create {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainResponse_Create {
    fn default() -> &'a MainResponse_Create {
        <MainResponse_Create as ::protobuf::Message>::default_instance()
    }
}

impl MainResponse_Create {
    pub fn new() -> MainResponse_Create {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MainResponse_Create {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainResponse_Create {
        MainResponse_Create::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainResponse_Create>(
                "MainResponse.Create",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainResponse_Create {
        static instance: ::protobuf::rt::LazyV2<MainResponse_Create> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainResponse_Create::new)
    }
}

impl ::protobuf::Clear for MainResponse_Create {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainResponse_Create {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainResponse_Create {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainResponse_Destroy {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainResponse_Destroy {
    fn default() -> &'a MainResponse_Destroy {
        <MainResponse_Destroy as ::protobuf::Message>::default_instance()
    }
}

impl MainResponse_Destroy {
    pub fn new() -> MainResponse_Destroy {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MainResponse_Destroy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainResponse_Destroy {
        MainResponse_Destroy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainResponse_Destroy>(
                "MainResponse.Destroy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainResponse_Destroy {
        static instance: ::protobuf::rt::LazyV2<MainResponse_Destroy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainResponse_Destroy::new)
    }
}

impl ::protobuf::Clear for MainResponse_Destroy {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainResponse_Destroy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainResponse_Destroy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainResponse_NewConnection {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainResponse_NewConnection {
    fn default() -> &'a MainResponse_NewConnection {
        <MainResponse_NewConnection as ::protobuf::Message>::default_instance()
    }
}

impl MainResponse_NewConnection {
    pub fn new() -> MainResponse_NewConnection {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MainResponse_NewConnection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainResponse_NewConnection {
        MainResponse_NewConnection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainResponse_NewConnection>(
                "MainResponse.NewConnection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainResponse_NewConnection {
        static instance: ::protobuf::rt::LazyV2<MainResponse_NewConnection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainResponse_NewConnection::new)
    }
}

impl ::protobuf::Clear for MainResponse_NewConnection {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainResponse_NewConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainResponse_NewConnection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainResponse_GetShutdownEventfd {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainResponse_GetShutdownEventfd {
    fn default() -> &'a MainResponse_GetShutdownEventfd {
        <MainResponse_GetShutdownEventfd as ::protobuf::Message>::default_instance()
    }
}

impl MainResponse_GetShutdownEventfd {
    pub fn new() -> MainResponse_GetShutdownEventfd {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MainResponse_GetShutdownEventfd {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainResponse_GetShutdownEventfd {
        MainResponse_GetShutdownEventfd::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainResponse_GetShutdownEventfd>(
                "MainResponse.GetShutdownEventfd",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainResponse_GetShutdownEventfd {
        static instance: ::protobuf::rt::LazyV2<MainResponse_GetShutdownEventfd> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainResponse_GetShutdownEventfd::new)
    }
}

impl ::protobuf::Clear for MainResponse_GetShutdownEventfd {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainResponse_GetShutdownEventfd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainResponse_GetShutdownEventfd {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainResponse_CheckExtension {
    // message fields
    pub has_extension: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainResponse_CheckExtension {
    fn default() -> &'a MainResponse_CheckExtension {
        <MainResponse_CheckExtension as ::protobuf::Message>::default_instance()
    }
}

impl MainResponse_CheckExtension {
    pub fn new() -> MainResponse_CheckExtension {
        ::std::default::Default::default()
    }

    // bool has_extension = 1;


    pub fn get_has_extension(&self) -> bool {
        self.has_extension
    }
    pub fn clear_has_extension(&mut self) {
        self.has_extension = false;
    }

    // Param is passed by value, moved
    pub fn set_has_extension(&mut self, v: bool) {
        self.has_extension = v;
    }
}

impl ::protobuf::Message for MainResponse_CheckExtension {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_extension = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.has_extension != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.has_extension != false {
            os.write_bool(1, self.has_extension)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainResponse_CheckExtension {
        MainResponse_CheckExtension::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_extension",
                |m: &MainResponse_CheckExtension| { &m.has_extension },
                |m: &mut MainResponse_CheckExtension| { &mut m.has_extension },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainResponse_CheckExtension>(
                "MainResponse.CheckExtension",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainResponse_CheckExtension {
        static instance: ::protobuf::rt::LazyV2<MainResponse_CheckExtension> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainResponse_CheckExtension::new)
    }
}

impl ::protobuf::Clear for MainResponse_CheckExtension {
    fn clear(&mut self) {
        self.has_extension = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainResponse_CheckExtension {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainResponse_CheckExtension {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainResponse_CpuidResponse {
    // message fields
    pub entries: ::protobuf::RepeatedField<CpuidEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainResponse_CpuidResponse {
    fn default() -> &'a MainResponse_CpuidResponse {
        <MainResponse_CpuidResponse as ::protobuf::Message>::default_instance()
    }
}

impl MainResponse_CpuidResponse {
    pub fn new() -> MainResponse_CpuidResponse {
        ::std::default::Default::default()
    }

    // repeated .CpuidEntry entries = 1;


    pub fn get_entries(&self) -> &[CpuidEntry] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<CpuidEntry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<CpuidEntry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<CpuidEntry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MainResponse_CpuidResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainResponse_CpuidResponse {
        MainResponse_CpuidResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CpuidEntry>>(
                "entries",
                |m: &MainResponse_CpuidResponse| { &m.entries },
                |m: &mut MainResponse_CpuidResponse| { &mut m.entries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainResponse_CpuidResponse>(
                "MainResponse.CpuidResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainResponse_CpuidResponse {
        static instance: ::protobuf::rt::LazyV2<MainResponse_CpuidResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainResponse_CpuidResponse::new)
    }
}

impl ::protobuf::Clear for MainResponse_CpuidResponse {
    fn clear(&mut self) {
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainResponse_CpuidResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainResponse_CpuidResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainResponse_MsrListResponse {
    // message fields
    pub indices: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainResponse_MsrListResponse {
    fn default() -> &'a MainResponse_MsrListResponse {
        <MainResponse_MsrListResponse as ::protobuf::Message>::default_instance()
    }
}

impl MainResponse_MsrListResponse {
    pub fn new() -> MainResponse_MsrListResponse {
        ::std::default::Default::default()
    }

    // repeated uint32 indices = 1;


    pub fn get_indices(&self) -> &[u32] {
        &self.indices
    }
    pub fn clear_indices(&mut self) {
        self.indices.clear();
    }

    // Param is passed by value, moved
    pub fn set_indices(&mut self, v: ::std::vec::Vec<u32>) {
        self.indices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_indices(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.indices
    }

    // Take field
    pub fn take_indices(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.indices, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MainResponse_MsrListResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.indices)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.indices {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.indices {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainResponse_MsrListResponse {
        MainResponse_MsrListResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "indices",
                |m: &MainResponse_MsrListResponse| { &m.indices },
                |m: &mut MainResponse_MsrListResponse| { &mut m.indices },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainResponse_MsrListResponse>(
                "MainResponse.MsrListResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainResponse_MsrListResponse {
        static instance: ::protobuf::rt::LazyV2<MainResponse_MsrListResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainResponse_MsrListResponse::new)
    }
}

impl ::protobuf::Clear for MainResponse_MsrListResponse {
    fn clear(&mut self) {
        self.indices.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainResponse_MsrListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainResponse_MsrListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainResponse_GetNetConfig {
    // message fields
    pub host_mac_address: ::std::vec::Vec<u8>,
    pub host_ipv4_address: u32,
    pub netmask: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainResponse_GetNetConfig {
    fn default() -> &'a MainResponse_GetNetConfig {
        <MainResponse_GetNetConfig as ::protobuf::Message>::default_instance()
    }
}

impl MainResponse_GetNetConfig {
    pub fn new() -> MainResponse_GetNetConfig {
        ::std::default::Default::default()
    }

    // bytes host_mac_address = 1;


    pub fn get_host_mac_address(&self) -> &[u8] {
        &self.host_mac_address
    }
    pub fn clear_host_mac_address(&mut self) {
        self.host_mac_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_host_mac_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.host_mac_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_mac_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.host_mac_address
    }

    // Take field
    pub fn take_host_mac_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.host_mac_address, ::std::vec::Vec::new())
    }

    // fixed32 host_ipv4_address = 2;


    pub fn get_host_ipv4_address(&self) -> u32 {
        self.host_ipv4_address
    }
    pub fn clear_host_ipv4_address(&mut self) {
        self.host_ipv4_address = 0;
    }

    // Param is passed by value, moved
    pub fn set_host_ipv4_address(&mut self, v: u32) {
        self.host_ipv4_address = v;
    }

    // fixed32 netmask = 3;


    pub fn get_netmask(&self) -> u32 {
        self.netmask
    }
    pub fn clear_netmask(&mut self) {
        self.netmask = 0;
    }

    // Param is passed by value, moved
    pub fn set_netmask(&mut self, v: u32) {
        self.netmask = v;
    }
}

impl ::protobuf::Message for MainResponse_GetNetConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.host_mac_address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.host_ipv4_address = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.netmask = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.host_mac_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.host_mac_address);
        }
        if self.host_ipv4_address != 0 {
            my_size += 5;
        }
        if self.netmask != 0 {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.host_mac_address.is_empty() {
            os.write_bytes(1, &self.host_mac_address)?;
        }
        if self.host_ipv4_address != 0 {
            os.write_fixed32(2, self.host_ipv4_address)?;
        }
        if self.netmask != 0 {
            os.write_fixed32(3, self.netmask)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainResponse_GetNetConfig {
        MainResponse_GetNetConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "host_mac_address",
                |m: &MainResponse_GetNetConfig| { &m.host_mac_address },
                |m: &mut MainResponse_GetNetConfig| { &mut m.host_mac_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "host_ipv4_address",
                |m: &MainResponse_GetNetConfig| { &m.host_ipv4_address },
                |m: &mut MainResponse_GetNetConfig| { &mut m.host_ipv4_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "netmask",
                |m: &MainResponse_GetNetConfig| { &m.netmask },
                |m: &mut MainResponse_GetNetConfig| { &mut m.netmask },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainResponse_GetNetConfig>(
                "MainResponse.GetNetConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainResponse_GetNetConfig {
        static instance: ::protobuf::rt::LazyV2<MainResponse_GetNetConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainResponse_GetNetConfig::new)
    }
}

impl ::protobuf::Clear for MainResponse_GetNetConfig {
    fn clear(&mut self) {
        self.host_mac_address.clear();
        self.host_ipv4_address = 0;
        self.netmask = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainResponse_GetNetConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainResponse_GetNetConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainResponse_ReserveRange {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainResponse_ReserveRange {
    fn default() -> &'a MainResponse_ReserveRange {
        <MainResponse_ReserveRange as ::protobuf::Message>::default_instance()
    }
}

impl MainResponse_ReserveRange {
    pub fn new() -> MainResponse_ReserveRange {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MainResponse_ReserveRange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainResponse_ReserveRange {
        MainResponse_ReserveRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainResponse_ReserveRange>(
                "MainResponse.ReserveRange",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainResponse_ReserveRange {
        static instance: ::protobuf::rt::LazyV2<MainResponse_ReserveRange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainResponse_ReserveRange::new)
    }
}

impl ::protobuf::Clear for MainResponse_ReserveRange {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainResponse_ReserveRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainResponse_ReserveRange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainResponse_SetIrq {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainResponse_SetIrq {
    fn default() -> &'a MainResponse_SetIrq {
        <MainResponse_SetIrq as ::protobuf::Message>::default_instance()
    }
}

impl MainResponse_SetIrq {
    pub fn new() -> MainResponse_SetIrq {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MainResponse_SetIrq {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainResponse_SetIrq {
        MainResponse_SetIrq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainResponse_SetIrq>(
                "MainResponse.SetIrq",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainResponse_SetIrq {
        static instance: ::protobuf::rt::LazyV2<MainResponse_SetIrq> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainResponse_SetIrq::new)
    }
}

impl ::protobuf::Clear for MainResponse_SetIrq {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainResponse_SetIrq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainResponse_SetIrq {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainResponse_SetIrqRouting {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainResponse_SetIrqRouting {
    fn default() -> &'a MainResponse_SetIrqRouting {
        <MainResponse_SetIrqRouting as ::protobuf::Message>::default_instance()
    }
}

impl MainResponse_SetIrqRouting {
    pub fn new() -> MainResponse_SetIrqRouting {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MainResponse_SetIrqRouting {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainResponse_SetIrqRouting {
        MainResponse_SetIrqRouting::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainResponse_SetIrqRouting>(
                "MainResponse.SetIrqRouting",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainResponse_SetIrqRouting {
        static instance: ::protobuf::rt::LazyV2<MainResponse_SetIrqRouting> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainResponse_SetIrqRouting::new)
    }
}

impl ::protobuf::Clear for MainResponse_SetIrqRouting {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainResponse_SetIrqRouting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainResponse_SetIrqRouting {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainResponse_GetState {
    // message fields
    pub state: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainResponse_GetState {
    fn default() -> &'a MainResponse_GetState {
        <MainResponse_GetState as ::protobuf::Message>::default_instance()
    }
}

impl MainResponse_GetState {
    pub fn new() -> MainResponse_GetState {
        ::std::default::Default::default()
    }

    // bytes state = 1;


    pub fn get_state(&self) -> &[u8] {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::vec::Vec<u8>) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.state, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MainResponse_GetState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.state);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.state.is_empty() {
            os.write_bytes(1, &self.state)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainResponse_GetState {
        MainResponse_GetState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "state",
                |m: &MainResponse_GetState| { &m.state },
                |m: &mut MainResponse_GetState| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainResponse_GetState>(
                "MainResponse.GetState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainResponse_GetState {
        static instance: ::protobuf::rt::LazyV2<MainResponse_GetState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainResponse_GetState::new)
    }
}

impl ::protobuf::Clear for MainResponse_GetState {
    fn clear(&mut self) {
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainResponse_GetState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainResponse_GetState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainResponse_SetState {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainResponse_SetState {
    fn default() -> &'a MainResponse_SetState {
        <MainResponse_SetState as ::protobuf::Message>::default_instance()
    }
}

impl MainResponse_SetState {
    pub fn new() -> MainResponse_SetState {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MainResponse_SetState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainResponse_SetState {
        MainResponse_SetState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainResponse_SetState>(
                "MainResponse.SetState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainResponse_SetState {
        static instance: ::protobuf::rt::LazyV2<MainResponse_SetState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainResponse_SetState::new)
    }
}

impl ::protobuf::Clear for MainResponse_SetState {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainResponse_SetState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainResponse_SetState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainResponse_SetIdentityMapAddr {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainResponse_SetIdentityMapAddr {
    fn default() -> &'a MainResponse_SetIdentityMapAddr {
        <MainResponse_SetIdentityMapAddr as ::protobuf::Message>::default_instance()
    }
}

impl MainResponse_SetIdentityMapAddr {
    pub fn new() -> MainResponse_SetIdentityMapAddr {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MainResponse_SetIdentityMapAddr {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainResponse_SetIdentityMapAddr {
        MainResponse_SetIdentityMapAddr::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainResponse_SetIdentityMapAddr>(
                "MainResponse.SetIdentityMapAddr",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainResponse_SetIdentityMapAddr {
        static instance: ::protobuf::rt::LazyV2<MainResponse_SetIdentityMapAddr> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainResponse_SetIdentityMapAddr::new)
    }
}

impl ::protobuf::Clear for MainResponse_SetIdentityMapAddr {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainResponse_SetIdentityMapAddr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainResponse_SetIdentityMapAddr {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainResponse_PauseVcpus {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainResponse_PauseVcpus {
    fn default() -> &'a MainResponse_PauseVcpus {
        <MainResponse_PauseVcpus as ::protobuf::Message>::default_instance()
    }
}

impl MainResponse_PauseVcpus {
    pub fn new() -> MainResponse_PauseVcpus {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MainResponse_PauseVcpus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainResponse_PauseVcpus {
        MainResponse_PauseVcpus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainResponse_PauseVcpus>(
                "MainResponse.PauseVcpus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainResponse_PauseVcpus {
        static instance: ::protobuf::rt::LazyV2<MainResponse_PauseVcpus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainResponse_PauseVcpus::new)
    }
}

impl ::protobuf::Clear for MainResponse_PauseVcpus {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainResponse_PauseVcpus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainResponse_PauseVcpus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainResponse_GetVcpus {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainResponse_GetVcpus {
    fn default() -> &'a MainResponse_GetVcpus {
        <MainResponse_GetVcpus as ::protobuf::Message>::default_instance()
    }
}

impl MainResponse_GetVcpus {
    pub fn new() -> MainResponse_GetVcpus {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MainResponse_GetVcpus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainResponse_GetVcpus {
        MainResponse_GetVcpus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainResponse_GetVcpus>(
                "MainResponse.GetVcpus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainResponse_GetVcpus {
        static instance: ::protobuf::rt::LazyV2<MainResponse_GetVcpus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainResponse_GetVcpus::new)
    }
}

impl ::protobuf::Clear for MainResponse_GetVcpus {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainResponse_GetVcpus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainResponse_GetVcpus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainResponse_Start {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainResponse_Start {
    fn default() -> &'a MainResponse_Start {
        <MainResponse_Start as ::protobuf::Message>::default_instance()
    }
}

impl MainResponse_Start {
    pub fn new() -> MainResponse_Start {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MainResponse_Start {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainResponse_Start {
        MainResponse_Start::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainResponse_Start>(
                "MainResponse.Start",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainResponse_Start {
        static instance: ::protobuf::rt::LazyV2<MainResponse_Start> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainResponse_Start::new)
    }
}

impl ::protobuf::Clear for MainResponse_Start {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainResponse_Start {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainResponse_Start {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainResponse_SetCallHint {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainResponse_SetCallHint {
    fn default() -> &'a MainResponse_SetCallHint {
        <MainResponse_SetCallHint as ::protobuf::Message>::default_instance()
    }
}

impl MainResponse_SetCallHint {
    pub fn new() -> MainResponse_SetCallHint {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MainResponse_SetCallHint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainResponse_SetCallHint {
        MainResponse_SetCallHint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainResponse_SetCallHint>(
                "MainResponse.SetCallHint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainResponse_SetCallHint {
        static instance: ::protobuf::rt::LazyV2<MainResponse_SetCallHint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainResponse_SetCallHint::new)
    }
}

impl ::protobuf::Clear for MainResponse_SetCallHint {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainResponse_SetCallHint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainResponse_SetCallHint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MainResponse_MemoryDirtyLog {
    // message fields
    pub bitmap: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MainResponse_MemoryDirtyLog {
    fn default() -> &'a MainResponse_MemoryDirtyLog {
        <MainResponse_MemoryDirtyLog as ::protobuf::Message>::default_instance()
    }
}

impl MainResponse_MemoryDirtyLog {
    pub fn new() -> MainResponse_MemoryDirtyLog {
        ::std::default::Default::default()
    }

    // bytes bitmap = 1;


    pub fn get_bitmap(&self) -> &[u8] {
        &self.bitmap
    }
    pub fn clear_bitmap(&mut self) {
        self.bitmap.clear();
    }

    // Param is passed by value, moved
    pub fn set_bitmap(&mut self, v: ::std::vec::Vec<u8>) {
        self.bitmap = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bitmap(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.bitmap
    }

    // Take field
    pub fn take_bitmap(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.bitmap, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MainResponse_MemoryDirtyLog {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.bitmap)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bitmap.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.bitmap);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bitmap.is_empty() {
            os.write_bytes(1, &self.bitmap)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MainResponse_MemoryDirtyLog {
        MainResponse_MemoryDirtyLog::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "bitmap",
                |m: &MainResponse_MemoryDirtyLog| { &m.bitmap },
                |m: &mut MainResponse_MemoryDirtyLog| { &mut m.bitmap },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MainResponse_MemoryDirtyLog>(
                "MainResponse.MemoryDirtyLog",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MainResponse_MemoryDirtyLog {
        static instance: ::protobuf::rt::LazyV2<MainResponse_MemoryDirtyLog> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MainResponse_MemoryDirtyLog::new)
    }
}

impl ::protobuf::Clear for MainResponse_MemoryDirtyLog {
    fn clear(&mut self) {
        self.bitmap.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MainResponse_MemoryDirtyLog {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MainResponse_MemoryDirtyLog {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VcpuRequest {
    // message oneof groups
    pub message: ::std::option::Option<VcpuRequest_oneof_message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VcpuRequest {
    fn default() -> &'a VcpuRequest {
        <VcpuRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum VcpuRequest_oneof_message {
    wait(VcpuRequest_Wait),
    resume(VcpuRequest_Resume),
    get_state(VcpuRequest_GetState),
    set_state(VcpuRequest_SetState),
    get_msrs(VcpuRequest_GetMsrs),
    set_msrs(VcpuRequest_SetMsrs),
    set_cpuid(VcpuRequest_SetCpuid),
    shutdown(VcpuRequest_Shutdown),
    get_hyperv_cpuid(VcpuRequest_CpuidRequest),
    enable_capability(VcpuRequest_EnableCapability),
}

impl VcpuRequest {
    pub fn new() -> VcpuRequest {
        ::std::default::Default::default()
    }

    // .VcpuRequest.Wait wait = 1;


    pub fn get_wait(&self) -> &VcpuRequest_Wait {
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::wait(ref v)) => v,
            _ => <VcpuRequest_Wait as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_wait(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_wait(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::wait(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_wait(&mut self, v: VcpuRequest_Wait) {
        self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::wait(v))
    }

    // Mutable pointer to the field.
    pub fn mut_wait(&mut self) -> &mut VcpuRequest_Wait {
        if let ::std::option::Option::Some(VcpuRequest_oneof_message::wait(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::wait(VcpuRequest_Wait::new()));
        }
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::wait(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_wait(&mut self) -> VcpuRequest_Wait {
        if self.has_wait() {
            match self.message.take() {
                ::std::option::Option::Some(VcpuRequest_oneof_message::wait(v)) => v,
                _ => panic!(),
            }
        } else {
            VcpuRequest_Wait::new()
        }
    }

    // .VcpuRequest.Resume resume = 2;


    pub fn get_resume(&self) -> &VcpuRequest_Resume {
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::resume(ref v)) => v,
            _ => <VcpuRequest_Resume as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_resume(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_resume(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::resume(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_resume(&mut self, v: VcpuRequest_Resume) {
        self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::resume(v))
    }

    // Mutable pointer to the field.
    pub fn mut_resume(&mut self) -> &mut VcpuRequest_Resume {
        if let ::std::option::Option::Some(VcpuRequest_oneof_message::resume(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::resume(VcpuRequest_Resume::new()));
        }
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::resume(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_resume(&mut self) -> VcpuRequest_Resume {
        if self.has_resume() {
            match self.message.take() {
                ::std::option::Option::Some(VcpuRequest_oneof_message::resume(v)) => v,
                _ => panic!(),
            }
        } else {
            VcpuRequest_Resume::new()
        }
    }

    // .VcpuRequest.GetState get_state = 3;


    pub fn get_get_state(&self) -> &VcpuRequest_GetState {
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::get_state(ref v)) => v,
            _ => <VcpuRequest_GetState as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_get_state(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_state(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::get_state(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_state(&mut self, v: VcpuRequest_GetState) {
        self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::get_state(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_state(&mut self) -> &mut VcpuRequest_GetState {
        if let ::std::option::Option::Some(VcpuRequest_oneof_message::get_state(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::get_state(VcpuRequest_GetState::new()));
        }
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::get_state(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_state(&mut self) -> VcpuRequest_GetState {
        if self.has_get_state() {
            match self.message.take() {
                ::std::option::Option::Some(VcpuRequest_oneof_message::get_state(v)) => v,
                _ => panic!(),
            }
        } else {
            VcpuRequest_GetState::new()
        }
    }

    // .VcpuRequest.SetState set_state = 4;


    pub fn get_set_state(&self) -> &VcpuRequest_SetState {
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::set_state(ref v)) => v,
            _ => <VcpuRequest_SetState as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_set_state(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_set_state(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::set_state(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_state(&mut self, v: VcpuRequest_SetState) {
        self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::set_state(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_state(&mut self) -> &mut VcpuRequest_SetState {
        if let ::std::option::Option::Some(VcpuRequest_oneof_message::set_state(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::set_state(VcpuRequest_SetState::new()));
        }
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::set_state(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_state(&mut self) -> VcpuRequest_SetState {
        if self.has_set_state() {
            match self.message.take() {
                ::std::option::Option::Some(VcpuRequest_oneof_message::set_state(v)) => v,
                _ => panic!(),
            }
        } else {
            VcpuRequest_SetState::new()
        }
    }

    // .VcpuRequest.GetMsrs get_msrs = 5;


    pub fn get_get_msrs(&self) -> &VcpuRequest_GetMsrs {
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::get_msrs(ref v)) => v,
            _ => <VcpuRequest_GetMsrs as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_get_msrs(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_msrs(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::get_msrs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_msrs(&mut self, v: VcpuRequest_GetMsrs) {
        self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::get_msrs(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_msrs(&mut self) -> &mut VcpuRequest_GetMsrs {
        if let ::std::option::Option::Some(VcpuRequest_oneof_message::get_msrs(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::get_msrs(VcpuRequest_GetMsrs::new()));
        }
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::get_msrs(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_msrs(&mut self) -> VcpuRequest_GetMsrs {
        if self.has_get_msrs() {
            match self.message.take() {
                ::std::option::Option::Some(VcpuRequest_oneof_message::get_msrs(v)) => v,
                _ => panic!(),
            }
        } else {
            VcpuRequest_GetMsrs::new()
        }
    }

    // .VcpuRequest.SetMsrs set_msrs = 6;


    pub fn get_set_msrs(&self) -> &VcpuRequest_SetMsrs {
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::set_msrs(ref v)) => v,
            _ => <VcpuRequest_SetMsrs as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_set_msrs(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_set_msrs(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::set_msrs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_msrs(&mut self, v: VcpuRequest_SetMsrs) {
        self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::set_msrs(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_msrs(&mut self) -> &mut VcpuRequest_SetMsrs {
        if let ::std::option::Option::Some(VcpuRequest_oneof_message::set_msrs(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::set_msrs(VcpuRequest_SetMsrs::new()));
        }
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::set_msrs(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_msrs(&mut self) -> VcpuRequest_SetMsrs {
        if self.has_set_msrs() {
            match self.message.take() {
                ::std::option::Option::Some(VcpuRequest_oneof_message::set_msrs(v)) => v,
                _ => panic!(),
            }
        } else {
            VcpuRequest_SetMsrs::new()
        }
    }

    // .VcpuRequest.SetCpuid set_cpuid = 7;


    pub fn get_set_cpuid(&self) -> &VcpuRequest_SetCpuid {
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::set_cpuid(ref v)) => v,
            _ => <VcpuRequest_SetCpuid as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_set_cpuid(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_set_cpuid(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::set_cpuid(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_cpuid(&mut self, v: VcpuRequest_SetCpuid) {
        self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::set_cpuid(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_cpuid(&mut self) -> &mut VcpuRequest_SetCpuid {
        if let ::std::option::Option::Some(VcpuRequest_oneof_message::set_cpuid(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::set_cpuid(VcpuRequest_SetCpuid::new()));
        }
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::set_cpuid(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_cpuid(&mut self) -> VcpuRequest_SetCpuid {
        if self.has_set_cpuid() {
            match self.message.take() {
                ::std::option::Option::Some(VcpuRequest_oneof_message::set_cpuid(v)) => v,
                _ => panic!(),
            }
        } else {
            VcpuRequest_SetCpuid::new()
        }
    }

    // .VcpuRequest.Shutdown shutdown = 8;


    pub fn get_shutdown(&self) -> &VcpuRequest_Shutdown {
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::shutdown(ref v)) => v,
            _ => <VcpuRequest_Shutdown as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_shutdown(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_shutdown(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::shutdown(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_shutdown(&mut self, v: VcpuRequest_Shutdown) {
        self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::shutdown(v))
    }

    // Mutable pointer to the field.
    pub fn mut_shutdown(&mut self) -> &mut VcpuRequest_Shutdown {
        if let ::std::option::Option::Some(VcpuRequest_oneof_message::shutdown(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::shutdown(VcpuRequest_Shutdown::new()));
        }
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::shutdown(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_shutdown(&mut self) -> VcpuRequest_Shutdown {
        if self.has_shutdown() {
            match self.message.take() {
                ::std::option::Option::Some(VcpuRequest_oneof_message::shutdown(v)) => v,
                _ => panic!(),
            }
        } else {
            VcpuRequest_Shutdown::new()
        }
    }

    // .VcpuRequest.CpuidRequest get_hyperv_cpuid = 9;


    pub fn get_get_hyperv_cpuid(&self) -> &VcpuRequest_CpuidRequest {
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::get_hyperv_cpuid(ref v)) => v,
            _ => <VcpuRequest_CpuidRequest as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_get_hyperv_cpuid(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_hyperv_cpuid(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::get_hyperv_cpuid(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_hyperv_cpuid(&mut self, v: VcpuRequest_CpuidRequest) {
        self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::get_hyperv_cpuid(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_hyperv_cpuid(&mut self) -> &mut VcpuRequest_CpuidRequest {
        if let ::std::option::Option::Some(VcpuRequest_oneof_message::get_hyperv_cpuid(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::get_hyperv_cpuid(VcpuRequest_CpuidRequest::new()));
        }
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::get_hyperv_cpuid(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_hyperv_cpuid(&mut self) -> VcpuRequest_CpuidRequest {
        if self.has_get_hyperv_cpuid() {
            match self.message.take() {
                ::std::option::Option::Some(VcpuRequest_oneof_message::get_hyperv_cpuid(v)) => v,
                _ => panic!(),
            }
        } else {
            VcpuRequest_CpuidRequest::new()
        }
    }

    // .VcpuRequest.EnableCapability enable_capability = 10;


    pub fn get_enable_capability(&self) -> &VcpuRequest_EnableCapability {
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::enable_capability(ref v)) => v,
            _ => <VcpuRequest_EnableCapability as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_enable_capability(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_enable_capability(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::enable_capability(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_enable_capability(&mut self, v: VcpuRequest_EnableCapability) {
        self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::enable_capability(v))
    }

    // Mutable pointer to the field.
    pub fn mut_enable_capability(&mut self) -> &mut VcpuRequest_EnableCapability {
        if let ::std::option::Option::Some(VcpuRequest_oneof_message::enable_capability(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::enable_capability(VcpuRequest_EnableCapability::new()));
        }
        match self.message {
            ::std::option::Option::Some(VcpuRequest_oneof_message::enable_capability(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_enable_capability(&mut self) -> VcpuRequest_EnableCapability {
        if self.has_enable_capability() {
            match self.message.take() {
                ::std::option::Option::Some(VcpuRequest_oneof_message::enable_capability(v)) => v,
                _ => panic!(),
            }
        } else {
            VcpuRequest_EnableCapability::new()
        }
    }
}

impl ::protobuf::Message for VcpuRequest {
    fn is_initialized(&self) -> bool {
        if let Some(VcpuRequest_oneof_message::wait(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(VcpuRequest_oneof_message::resume(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(VcpuRequest_oneof_message::get_state(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(VcpuRequest_oneof_message::set_state(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(VcpuRequest_oneof_message::get_msrs(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(VcpuRequest_oneof_message::set_msrs(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(VcpuRequest_oneof_message::set_cpuid(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(VcpuRequest_oneof_message::shutdown(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(VcpuRequest_oneof_message::get_hyperv_cpuid(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(VcpuRequest_oneof_message::enable_capability(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::wait(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::resume(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::get_state(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::set_state(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::get_msrs(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::set_msrs(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::set_cpuid(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::shutdown(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::get_hyperv_cpuid(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(VcpuRequest_oneof_message::enable_capability(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &VcpuRequest_oneof_message::wait(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &VcpuRequest_oneof_message::resume(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &VcpuRequest_oneof_message::get_state(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &VcpuRequest_oneof_message::set_state(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &VcpuRequest_oneof_message::get_msrs(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &VcpuRequest_oneof_message::set_msrs(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &VcpuRequest_oneof_message::set_cpuid(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &VcpuRequest_oneof_message::shutdown(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &VcpuRequest_oneof_message::get_hyperv_cpuid(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &VcpuRequest_oneof_message::enable_capability(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &VcpuRequest_oneof_message::wait(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &VcpuRequest_oneof_message::resume(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &VcpuRequest_oneof_message::get_state(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &VcpuRequest_oneof_message::set_state(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &VcpuRequest_oneof_message::get_msrs(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &VcpuRequest_oneof_message::set_msrs(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &VcpuRequest_oneof_message::set_cpuid(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &VcpuRequest_oneof_message::shutdown(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &VcpuRequest_oneof_message::get_hyperv_cpuid(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &VcpuRequest_oneof_message::enable_capability(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VcpuRequest {
        VcpuRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VcpuRequest_Wait>(
                "wait",
                VcpuRequest::has_wait,
                VcpuRequest::get_wait,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VcpuRequest_Resume>(
                "resume",
                VcpuRequest::has_resume,
                VcpuRequest::get_resume,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VcpuRequest_GetState>(
                "get_state",
                VcpuRequest::has_get_state,
                VcpuRequest::get_get_state,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VcpuRequest_SetState>(
                "set_state",
                VcpuRequest::has_set_state,
                VcpuRequest::get_set_state,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VcpuRequest_GetMsrs>(
                "get_msrs",
                VcpuRequest::has_get_msrs,
                VcpuRequest::get_get_msrs,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VcpuRequest_SetMsrs>(
                "set_msrs",
                VcpuRequest::has_set_msrs,
                VcpuRequest::get_set_msrs,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VcpuRequest_SetCpuid>(
                "set_cpuid",
                VcpuRequest::has_set_cpuid,
                VcpuRequest::get_set_cpuid,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VcpuRequest_Shutdown>(
                "shutdown",
                VcpuRequest::has_shutdown,
                VcpuRequest::get_shutdown,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VcpuRequest_CpuidRequest>(
                "get_hyperv_cpuid",
                VcpuRequest::has_get_hyperv_cpuid,
                VcpuRequest::get_get_hyperv_cpuid,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VcpuRequest_EnableCapability>(
                "enable_capability",
                VcpuRequest::has_enable_capability,
                VcpuRequest::get_enable_capability,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VcpuRequest>(
                "VcpuRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VcpuRequest {
        static instance: ::protobuf::rt::LazyV2<VcpuRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VcpuRequest::new)
    }
}

impl ::protobuf::Clear for VcpuRequest {
    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VcpuRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VcpuRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VcpuRequest_Wait {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VcpuRequest_Wait {
    fn default() -> &'a VcpuRequest_Wait {
        <VcpuRequest_Wait as ::protobuf::Message>::default_instance()
    }
}

impl VcpuRequest_Wait {
    pub fn new() -> VcpuRequest_Wait {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VcpuRequest_Wait {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VcpuRequest_Wait {
        VcpuRequest_Wait::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VcpuRequest_Wait>(
                "VcpuRequest.Wait",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VcpuRequest_Wait {
        static instance: ::protobuf::rt::LazyV2<VcpuRequest_Wait> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VcpuRequest_Wait::new)
    }
}

impl ::protobuf::Clear for VcpuRequest_Wait {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VcpuRequest_Wait {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VcpuRequest_Wait {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VcpuRequest_Resume {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub regs: ::std::vec::Vec<u8>,
    pub sregs: ::std::vec::Vec<u8>,
    pub debugregs: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VcpuRequest_Resume {
    fn default() -> &'a VcpuRequest_Resume {
        <VcpuRequest_Resume as ::protobuf::Message>::default_instance()
    }
}

impl VcpuRequest_Resume {
    pub fn new() -> VcpuRequest_Resume {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // bytes regs = 2;


    pub fn get_regs(&self) -> &[u8] {
        &self.regs
    }
    pub fn clear_regs(&mut self) {
        self.regs.clear();
    }

    // Param is passed by value, moved
    pub fn set_regs(&mut self, v: ::std::vec::Vec<u8>) {
        self.regs = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_regs(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.regs
    }

    // Take field
    pub fn take_regs(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.regs, ::std::vec::Vec::new())
    }

    // bytes sregs = 3;


    pub fn get_sregs(&self) -> &[u8] {
        &self.sregs
    }
    pub fn clear_sregs(&mut self) {
        self.sregs.clear();
    }

    // Param is passed by value, moved
    pub fn set_sregs(&mut self, v: ::std::vec::Vec<u8>) {
        self.sregs = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sregs(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.sregs
    }

    // Take field
    pub fn take_sregs(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.sregs, ::std::vec::Vec::new())
    }

    // bytes debugregs = 4;


    pub fn get_debugregs(&self) -> &[u8] {
        &self.debugregs
    }
    pub fn clear_debugregs(&mut self) {
        self.debugregs.clear();
    }

    // Param is passed by value, moved
    pub fn set_debugregs(&mut self, v: ::std::vec::Vec<u8>) {
        self.debugregs = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debugregs(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.debugregs
    }

    // Take field
    pub fn take_debugregs(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.debugregs, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for VcpuRequest_Resume {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.regs)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.sregs)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.debugregs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if !self.regs.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.regs);
        }
        if !self.sregs.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.sregs);
        }
        if !self.debugregs.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.debugregs);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if !self.regs.is_empty() {
            os.write_bytes(2, &self.regs)?;
        }
        if !self.sregs.is_empty() {
            os.write_bytes(3, &self.sregs)?;
        }
        if !self.debugregs.is_empty() {
            os.write_bytes(4, &self.debugregs)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VcpuRequest_Resume {
        VcpuRequest_Resume::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &VcpuRequest_Resume| { &m.data },
                |m: &mut VcpuRequest_Resume| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "regs",
                |m: &VcpuRequest_Resume| { &m.regs },
                |m: &mut VcpuRequest_Resume| { &mut m.regs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sregs",
                |m: &VcpuRequest_Resume| { &m.sregs },
                |m: &mut VcpuRequest_Resume| { &mut m.sregs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "debugregs",
                |m: &VcpuRequest_Resume| { &m.debugregs },
                |m: &mut VcpuRequest_Resume| { &mut m.debugregs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VcpuRequest_Resume>(
                "VcpuRequest.Resume",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VcpuRequest_Resume {
        static instance: ::protobuf::rt::LazyV2<VcpuRequest_Resume> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VcpuRequest_Resume::new)
    }
}

impl ::protobuf::Clear for VcpuRequest_Resume {
    fn clear(&mut self) {
        self.data.clear();
        self.regs.clear();
        self.sregs.clear();
        self.debugregs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VcpuRequest_Resume {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VcpuRequest_Resume {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VcpuRequest_GetState {
    // message fields
    pub set: VcpuRequest_StateSet,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VcpuRequest_GetState {
    fn default() -> &'a VcpuRequest_GetState {
        <VcpuRequest_GetState as ::protobuf::Message>::default_instance()
    }
}

impl VcpuRequest_GetState {
    pub fn new() -> VcpuRequest_GetState {
        ::std::default::Default::default()
    }

    // .VcpuRequest.StateSet set = 1;


    pub fn get_set(&self) -> VcpuRequest_StateSet {
        self.set
    }
    pub fn clear_set(&mut self) {
        self.set = VcpuRequest_StateSet::REGS;
    }

    // Param is passed by value, moved
    pub fn set_set(&mut self, v: VcpuRequest_StateSet) {
        self.set = v;
    }
}

impl ::protobuf::Message for VcpuRequest_GetState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.set, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.set != VcpuRequest_StateSet::REGS {
            my_size += ::protobuf::rt::enum_size(1, self.set);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.set != VcpuRequest_StateSet::REGS {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.set))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VcpuRequest_GetState {
        VcpuRequest_GetState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<VcpuRequest_StateSet>>(
                "set",
                |m: &VcpuRequest_GetState| { &m.set },
                |m: &mut VcpuRequest_GetState| { &mut m.set },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VcpuRequest_GetState>(
                "VcpuRequest.GetState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VcpuRequest_GetState {
        static instance: ::protobuf::rt::LazyV2<VcpuRequest_GetState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VcpuRequest_GetState::new)
    }
}

impl ::protobuf::Clear for VcpuRequest_GetState {
    fn clear(&mut self) {
        self.set = VcpuRequest_StateSet::REGS;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VcpuRequest_GetState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VcpuRequest_GetState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VcpuRequest_SetState {
    // message fields
    pub set: VcpuRequest_StateSet,
    pub state: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VcpuRequest_SetState {
    fn default() -> &'a VcpuRequest_SetState {
        <VcpuRequest_SetState as ::protobuf::Message>::default_instance()
    }
}

impl VcpuRequest_SetState {
    pub fn new() -> VcpuRequest_SetState {
        ::std::default::Default::default()
    }

    // .VcpuRequest.StateSet set = 1;


    pub fn get_set(&self) -> VcpuRequest_StateSet {
        self.set
    }
    pub fn clear_set(&mut self) {
        self.set = VcpuRequest_StateSet::REGS;
    }

    // Param is passed by value, moved
    pub fn set_set(&mut self, v: VcpuRequest_StateSet) {
        self.set = v;
    }

    // bytes state = 2;


    pub fn get_state(&self) -> &[u8] {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::vec::Vec<u8>) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.state, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for VcpuRequest_SetState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.set, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.set != VcpuRequest_StateSet::REGS {
            my_size += ::protobuf::rt::enum_size(1, self.set);
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.state);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.set != VcpuRequest_StateSet::REGS {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.set))?;
        }
        if !self.state.is_empty() {
            os.write_bytes(2, &self.state)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VcpuRequest_SetState {
        VcpuRequest_SetState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<VcpuRequest_StateSet>>(
                "set",
                |m: &VcpuRequest_SetState| { &m.set },
                |m: &mut VcpuRequest_SetState| { &mut m.set },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "state",
                |m: &VcpuRequest_SetState| { &m.state },
                |m: &mut VcpuRequest_SetState| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VcpuRequest_SetState>(
                "VcpuRequest.SetState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VcpuRequest_SetState {
        static instance: ::protobuf::rt::LazyV2<VcpuRequest_SetState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VcpuRequest_SetState::new)
    }
}

impl ::protobuf::Clear for VcpuRequest_SetState {
    fn clear(&mut self) {
        self.set = VcpuRequest_StateSet::REGS;
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VcpuRequest_SetState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VcpuRequest_SetState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VcpuRequest_CpuidRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VcpuRequest_CpuidRequest {
    fn default() -> &'a VcpuRequest_CpuidRequest {
        <VcpuRequest_CpuidRequest as ::protobuf::Message>::default_instance()
    }
}

impl VcpuRequest_CpuidRequest {
    pub fn new() -> VcpuRequest_CpuidRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VcpuRequest_CpuidRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VcpuRequest_CpuidRequest {
        VcpuRequest_CpuidRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VcpuRequest_CpuidRequest>(
                "VcpuRequest.CpuidRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VcpuRequest_CpuidRequest {
        static instance: ::protobuf::rt::LazyV2<VcpuRequest_CpuidRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VcpuRequest_CpuidRequest::new)
    }
}

impl ::protobuf::Clear for VcpuRequest_CpuidRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VcpuRequest_CpuidRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VcpuRequest_CpuidRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VcpuRequest_GetMsrs {
    // message fields
    pub entry_indices: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VcpuRequest_GetMsrs {
    fn default() -> &'a VcpuRequest_GetMsrs {
        <VcpuRequest_GetMsrs as ::protobuf::Message>::default_instance()
    }
}

impl VcpuRequest_GetMsrs {
    pub fn new() -> VcpuRequest_GetMsrs {
        ::std::default::Default::default()
    }

    // repeated uint32 entry_indices = 1;


    pub fn get_entry_indices(&self) -> &[u32] {
        &self.entry_indices
    }
    pub fn clear_entry_indices(&mut self) {
        self.entry_indices.clear();
    }

    // Param is passed by value, moved
    pub fn set_entry_indices(&mut self, v: ::std::vec::Vec<u32>) {
        self.entry_indices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entry_indices(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.entry_indices
    }

    // Take field
    pub fn take_entry_indices(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.entry_indices, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for VcpuRequest_GetMsrs {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.entry_indices)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entry_indices {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entry_indices {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VcpuRequest_GetMsrs {
        VcpuRequest_GetMsrs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "entry_indices",
                |m: &VcpuRequest_GetMsrs| { &m.entry_indices },
                |m: &mut VcpuRequest_GetMsrs| { &mut m.entry_indices },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VcpuRequest_GetMsrs>(
                "VcpuRequest.GetMsrs",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VcpuRequest_GetMsrs {
        static instance: ::protobuf::rt::LazyV2<VcpuRequest_GetMsrs> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VcpuRequest_GetMsrs::new)
    }
}

impl ::protobuf::Clear for VcpuRequest_GetMsrs {
    fn clear(&mut self) {
        self.entry_indices.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VcpuRequest_GetMsrs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VcpuRequest_GetMsrs {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VcpuRequest_MsrEntry {
    // message fields
    pub index: u32,
    pub data: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VcpuRequest_MsrEntry {
    fn default() -> &'a VcpuRequest_MsrEntry {
        <VcpuRequest_MsrEntry as ::protobuf::Message>::default_instance()
    }
}

impl VcpuRequest_MsrEntry {
    pub fn new() -> VcpuRequest_MsrEntry {
        ::std::default::Default::default()
    }

    // uint32 index = 1;


    pub fn get_index(&self) -> u32 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = v;
    }

    // uint64 data = 2;


    pub fn get_data(&self) -> u64 {
        self.data
    }
    pub fn clear_data(&mut self) {
        self.data = 0;
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: u64) {
        self.data = v;
    }
}

impl ::protobuf::Message for VcpuRequest_MsrEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.index = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.data = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.data != 0 {
            my_size += ::protobuf::rt::value_size(2, self.data, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.index != 0 {
            os.write_uint32(1, self.index)?;
        }
        if self.data != 0 {
            os.write_uint64(2, self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VcpuRequest_MsrEntry {
        VcpuRequest_MsrEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "index",
                |m: &VcpuRequest_MsrEntry| { &m.index },
                |m: &mut VcpuRequest_MsrEntry| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "data",
                |m: &VcpuRequest_MsrEntry| { &m.data },
                |m: &mut VcpuRequest_MsrEntry| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VcpuRequest_MsrEntry>(
                "VcpuRequest.MsrEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VcpuRequest_MsrEntry {
        static instance: ::protobuf::rt::LazyV2<VcpuRequest_MsrEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VcpuRequest_MsrEntry::new)
    }
}

impl ::protobuf::Clear for VcpuRequest_MsrEntry {
    fn clear(&mut self) {
        self.index = 0;
        self.data = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VcpuRequest_MsrEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VcpuRequest_MsrEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VcpuRequest_SetMsrs {
    // message fields
    pub entries: ::protobuf::RepeatedField<VcpuRequest_MsrEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VcpuRequest_SetMsrs {
    fn default() -> &'a VcpuRequest_SetMsrs {
        <VcpuRequest_SetMsrs as ::protobuf::Message>::default_instance()
    }
}

impl VcpuRequest_SetMsrs {
    pub fn new() -> VcpuRequest_SetMsrs {
        ::std::default::Default::default()
    }

    // repeated .VcpuRequest.MsrEntry entries = 1;


    pub fn get_entries(&self) -> &[VcpuRequest_MsrEntry] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<VcpuRequest_MsrEntry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<VcpuRequest_MsrEntry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<VcpuRequest_MsrEntry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VcpuRequest_SetMsrs {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VcpuRequest_SetMsrs {
        VcpuRequest_SetMsrs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VcpuRequest_MsrEntry>>(
                "entries",
                |m: &VcpuRequest_SetMsrs| { &m.entries },
                |m: &mut VcpuRequest_SetMsrs| { &mut m.entries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VcpuRequest_SetMsrs>(
                "VcpuRequest.SetMsrs",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VcpuRequest_SetMsrs {
        static instance: ::protobuf::rt::LazyV2<VcpuRequest_SetMsrs> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VcpuRequest_SetMsrs::new)
    }
}

impl ::protobuf::Clear for VcpuRequest_SetMsrs {
    fn clear(&mut self) {
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VcpuRequest_SetMsrs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VcpuRequest_SetMsrs {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VcpuRequest_SetCpuid {
    // message fields
    pub entries: ::protobuf::RepeatedField<CpuidEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VcpuRequest_SetCpuid {
    fn default() -> &'a VcpuRequest_SetCpuid {
        <VcpuRequest_SetCpuid as ::protobuf::Message>::default_instance()
    }
}

impl VcpuRequest_SetCpuid {
    pub fn new() -> VcpuRequest_SetCpuid {
        ::std::default::Default::default()
    }

    // repeated .CpuidEntry entries = 1;


    pub fn get_entries(&self) -> &[CpuidEntry] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<CpuidEntry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<CpuidEntry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<CpuidEntry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VcpuRequest_SetCpuid {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VcpuRequest_SetCpuid {
        VcpuRequest_SetCpuid::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CpuidEntry>>(
                "entries",
                |m: &VcpuRequest_SetCpuid| { &m.entries },
                |m: &mut VcpuRequest_SetCpuid| { &mut m.entries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VcpuRequest_SetCpuid>(
                "VcpuRequest.SetCpuid",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VcpuRequest_SetCpuid {
        static instance: ::protobuf::rt::LazyV2<VcpuRequest_SetCpuid> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VcpuRequest_SetCpuid::new)
    }
}

impl ::protobuf::Clear for VcpuRequest_SetCpuid {
    fn clear(&mut self) {
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VcpuRequest_SetCpuid {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VcpuRequest_SetCpuid {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VcpuRequest_Shutdown {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VcpuRequest_Shutdown {
    fn default() -> &'a VcpuRequest_Shutdown {
        <VcpuRequest_Shutdown as ::protobuf::Message>::default_instance()
    }
}

impl VcpuRequest_Shutdown {
    pub fn new() -> VcpuRequest_Shutdown {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VcpuRequest_Shutdown {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VcpuRequest_Shutdown {
        VcpuRequest_Shutdown::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VcpuRequest_Shutdown>(
                "VcpuRequest.Shutdown",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VcpuRequest_Shutdown {
        static instance: ::protobuf::rt::LazyV2<VcpuRequest_Shutdown> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VcpuRequest_Shutdown::new)
    }
}

impl ::protobuf::Clear for VcpuRequest_Shutdown {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VcpuRequest_Shutdown {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VcpuRequest_Shutdown {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VcpuRequest_EnableCapability {
    // message fields
    pub capability: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VcpuRequest_EnableCapability {
    fn default() -> &'a VcpuRequest_EnableCapability {
        <VcpuRequest_EnableCapability as ::protobuf::Message>::default_instance()
    }
}

impl VcpuRequest_EnableCapability {
    pub fn new() -> VcpuRequest_EnableCapability {
        ::std::default::Default::default()
    }

    // uint32 capability = 1;


    pub fn get_capability(&self) -> u32 {
        self.capability
    }
    pub fn clear_capability(&mut self) {
        self.capability = 0;
    }

    // Param is passed by value, moved
    pub fn set_capability(&mut self, v: u32) {
        self.capability = v;
    }
}

impl ::protobuf::Message for VcpuRequest_EnableCapability {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.capability = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.capability != 0 {
            my_size += ::protobuf::rt::value_size(1, self.capability, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.capability != 0 {
            os.write_uint32(1, self.capability)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VcpuRequest_EnableCapability {
        VcpuRequest_EnableCapability::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "capability",
                |m: &VcpuRequest_EnableCapability| { &m.capability },
                |m: &mut VcpuRequest_EnableCapability| { &mut m.capability },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VcpuRequest_EnableCapability>(
                "VcpuRequest.EnableCapability",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VcpuRequest_EnableCapability {
        static instance: ::protobuf::rt::LazyV2<VcpuRequest_EnableCapability> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VcpuRequest_EnableCapability::new)
    }
}

impl ::protobuf::Clear for VcpuRequest_EnableCapability {
    fn clear(&mut self) {
        self.capability = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VcpuRequest_EnableCapability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VcpuRequest_EnableCapability {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum VcpuRequest_StateSet {
    REGS = 0,
    SREGS = 1,
    FPU = 2,
    DEBUGREGS = 3,
    LAPIC = 4,
    MP = 5,
    XCREGS = 6,
    EVENTS = 7,
}

impl ::protobuf::ProtobufEnum for VcpuRequest_StateSet {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VcpuRequest_StateSet> {
        match value {
            0 => ::std::option::Option::Some(VcpuRequest_StateSet::REGS),
            1 => ::std::option::Option::Some(VcpuRequest_StateSet::SREGS),
            2 => ::std::option::Option::Some(VcpuRequest_StateSet::FPU),
            3 => ::std::option::Option::Some(VcpuRequest_StateSet::DEBUGREGS),
            4 => ::std::option::Option::Some(VcpuRequest_StateSet::LAPIC),
            5 => ::std::option::Option::Some(VcpuRequest_StateSet::MP),
            6 => ::std::option::Option::Some(VcpuRequest_StateSet::XCREGS),
            7 => ::std::option::Option::Some(VcpuRequest_StateSet::EVENTS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [VcpuRequest_StateSet] = &[
            VcpuRequest_StateSet::REGS,
            VcpuRequest_StateSet::SREGS,
            VcpuRequest_StateSet::FPU,
            VcpuRequest_StateSet::DEBUGREGS,
            VcpuRequest_StateSet::LAPIC,
            VcpuRequest_StateSet::MP,
            VcpuRequest_StateSet::XCREGS,
            VcpuRequest_StateSet::EVENTS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<VcpuRequest_StateSet>("VcpuRequest.StateSet", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for VcpuRequest_StateSet {
}

impl ::std::default::Default for VcpuRequest_StateSet {
    fn default() -> Self {
        VcpuRequest_StateSet::REGS
    }
}

impl ::protobuf::reflect::ProtobufValue for VcpuRequest_StateSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VcpuResponse {
    // message fields
    pub errno: i32,
    // message oneof groups
    pub message: ::std::option::Option<VcpuResponse_oneof_message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VcpuResponse {
    fn default() -> &'a VcpuResponse {
        <VcpuResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum VcpuResponse_oneof_message {
    wait(VcpuResponse_Wait),
    get_state(VcpuResponse_GetState),
    set_state(VcpuResponse_SetState),
    get_msrs(VcpuResponse_GetMsrs),
    set_msrs(VcpuResponse_SetMsrs),
    set_cpuid(VcpuResponse_SetCpuid),
    get_hyperv_cpuid(VcpuResponse_CpuidResponse),
    enable_capability(VcpuResponse_EnableCapability),
}

impl VcpuResponse {
    pub fn new() -> VcpuResponse {
        ::std::default::Default::default()
    }

    // sint32 errno = 1;


    pub fn get_errno(&self) -> i32 {
        self.errno
    }
    pub fn clear_errno(&mut self) {
        self.errno = 0;
    }

    // Param is passed by value, moved
    pub fn set_errno(&mut self, v: i32) {
        self.errno = v;
    }

    // .VcpuResponse.Wait wait = 2;


    pub fn get_wait(&self) -> &VcpuResponse_Wait {
        match self.message {
            ::std::option::Option::Some(VcpuResponse_oneof_message::wait(ref v)) => v,
            _ => <VcpuResponse_Wait as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_wait(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_wait(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(VcpuResponse_oneof_message::wait(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_wait(&mut self, v: VcpuResponse_Wait) {
        self.message = ::std::option::Option::Some(VcpuResponse_oneof_message::wait(v))
    }

    // Mutable pointer to the field.
    pub fn mut_wait(&mut self) -> &mut VcpuResponse_Wait {
        if let ::std::option::Option::Some(VcpuResponse_oneof_message::wait(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(VcpuResponse_oneof_message::wait(VcpuResponse_Wait::new()));
        }
        match self.message {
            ::std::option::Option::Some(VcpuResponse_oneof_message::wait(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_wait(&mut self) -> VcpuResponse_Wait {
        if self.has_wait() {
            match self.message.take() {
                ::std::option::Option::Some(VcpuResponse_oneof_message::wait(v)) => v,
                _ => panic!(),
            }
        } else {
            VcpuResponse_Wait::new()
        }
    }

    // .VcpuResponse.GetState get_state = 4;


    pub fn get_get_state(&self) -> &VcpuResponse_GetState {
        match self.message {
            ::std::option::Option::Some(VcpuResponse_oneof_message::get_state(ref v)) => v,
            _ => <VcpuResponse_GetState as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_get_state(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_state(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(VcpuResponse_oneof_message::get_state(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_state(&mut self, v: VcpuResponse_GetState) {
        self.message = ::std::option::Option::Some(VcpuResponse_oneof_message::get_state(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_state(&mut self) -> &mut VcpuResponse_GetState {
        if let ::std::option::Option::Some(VcpuResponse_oneof_message::get_state(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(VcpuResponse_oneof_message::get_state(VcpuResponse_GetState::new()));
        }
        match self.message {
            ::std::option::Option::Some(VcpuResponse_oneof_message::get_state(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_state(&mut self) -> VcpuResponse_GetState {
        if self.has_get_state() {
            match self.message.take() {
                ::std::option::Option::Some(VcpuResponse_oneof_message::get_state(v)) => v,
                _ => panic!(),
            }
        } else {
            VcpuResponse_GetState::new()
        }
    }

    // .VcpuResponse.SetState set_state = 5;


    pub fn get_set_state(&self) -> &VcpuResponse_SetState {
        match self.message {
            ::std::option::Option::Some(VcpuResponse_oneof_message::set_state(ref v)) => v,
            _ => <VcpuResponse_SetState as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_set_state(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_set_state(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(VcpuResponse_oneof_message::set_state(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_state(&mut self, v: VcpuResponse_SetState) {
        self.message = ::std::option::Option::Some(VcpuResponse_oneof_message::set_state(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_state(&mut self) -> &mut VcpuResponse_SetState {
        if let ::std::option::Option::Some(VcpuResponse_oneof_message::set_state(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(VcpuResponse_oneof_message::set_state(VcpuResponse_SetState::new()));
        }
        match self.message {
            ::std::option::Option::Some(VcpuResponse_oneof_message::set_state(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_state(&mut self) -> VcpuResponse_SetState {
        if self.has_set_state() {
            match self.message.take() {
                ::std::option::Option::Some(VcpuResponse_oneof_message::set_state(v)) => v,
                _ => panic!(),
            }
        } else {
            VcpuResponse_SetState::new()
        }
    }

    // .VcpuResponse.GetMsrs get_msrs = 6;


    pub fn get_get_msrs(&self) -> &VcpuResponse_GetMsrs {
        match self.message {
            ::std::option::Option::Some(VcpuResponse_oneof_message::get_msrs(ref v)) => v,
            _ => <VcpuResponse_GetMsrs as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_get_msrs(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_msrs(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(VcpuResponse_oneof_message::get_msrs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_msrs(&mut self, v: VcpuResponse_GetMsrs) {
        self.message = ::std::option::Option::Some(VcpuResponse_oneof_message::get_msrs(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_msrs(&mut self) -> &mut VcpuResponse_GetMsrs {
        if let ::std::option::Option::Some(VcpuResponse_oneof_message::get_msrs(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(VcpuResponse_oneof_message::get_msrs(VcpuResponse_GetMsrs::new()));
        }
        match self.message {
            ::std::option::Option::Some(VcpuResponse_oneof_message::get_msrs(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_msrs(&mut self) -> VcpuResponse_GetMsrs {
        if self.has_get_msrs() {
            match self.message.take() {
                ::std::option::Option::Some(VcpuResponse_oneof_message::get_msrs(v)) => v,
                _ => panic!(),
            }
        } else {
            VcpuResponse_GetMsrs::new()
        }
    }

    // .VcpuResponse.SetMsrs set_msrs = 7;


    pub fn get_set_msrs(&self) -> &VcpuResponse_SetMsrs {
        match self.message {
            ::std::option::Option::Some(VcpuResponse_oneof_message::set_msrs(ref v)) => v,
            _ => <VcpuResponse_SetMsrs as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_set_msrs(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_set_msrs(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(VcpuResponse_oneof_message::set_msrs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_msrs(&mut self, v: VcpuResponse_SetMsrs) {
        self.message = ::std::option::Option::Some(VcpuResponse_oneof_message::set_msrs(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_msrs(&mut self) -> &mut VcpuResponse_SetMsrs {
        if let ::std::option::Option::Some(VcpuResponse_oneof_message::set_msrs(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(VcpuResponse_oneof_message::set_msrs(VcpuResponse_SetMsrs::new()));
        }
        match self.message {
            ::std::option::Option::Some(VcpuResponse_oneof_message::set_msrs(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_msrs(&mut self) -> VcpuResponse_SetMsrs {
        if self.has_set_msrs() {
            match self.message.take() {
                ::std::option::Option::Some(VcpuResponse_oneof_message::set_msrs(v)) => v,
                _ => panic!(),
            }
        } else {
            VcpuResponse_SetMsrs::new()
        }
    }

    // .VcpuResponse.SetCpuid set_cpuid = 8;


    pub fn get_set_cpuid(&self) -> &VcpuResponse_SetCpuid {
        match self.message {
            ::std::option::Option::Some(VcpuResponse_oneof_message::set_cpuid(ref v)) => v,
            _ => <VcpuResponse_SetCpuid as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_set_cpuid(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_set_cpuid(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(VcpuResponse_oneof_message::set_cpuid(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_set_cpuid(&mut self, v: VcpuResponse_SetCpuid) {
        self.message = ::std::option::Option::Some(VcpuResponse_oneof_message::set_cpuid(v))
    }

    // Mutable pointer to the field.
    pub fn mut_set_cpuid(&mut self) -> &mut VcpuResponse_SetCpuid {
        if let ::std::option::Option::Some(VcpuResponse_oneof_message::set_cpuid(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(VcpuResponse_oneof_message::set_cpuid(VcpuResponse_SetCpuid::new()));
        }
        match self.message {
            ::std::option::Option::Some(VcpuResponse_oneof_message::set_cpuid(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_set_cpuid(&mut self) -> VcpuResponse_SetCpuid {
        if self.has_set_cpuid() {
            match self.message.take() {
                ::std::option::Option::Some(VcpuResponse_oneof_message::set_cpuid(v)) => v,
                _ => panic!(),
            }
        } else {
            VcpuResponse_SetCpuid::new()
        }
    }

    // .VcpuResponse.CpuidResponse get_hyperv_cpuid = 9;


    pub fn get_get_hyperv_cpuid(&self) -> &VcpuResponse_CpuidResponse {
        match self.message {
            ::std::option::Option::Some(VcpuResponse_oneof_message::get_hyperv_cpuid(ref v)) => v,
            _ => <VcpuResponse_CpuidResponse as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_get_hyperv_cpuid(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_get_hyperv_cpuid(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(VcpuResponse_oneof_message::get_hyperv_cpuid(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_get_hyperv_cpuid(&mut self, v: VcpuResponse_CpuidResponse) {
        self.message = ::std::option::Option::Some(VcpuResponse_oneof_message::get_hyperv_cpuid(v))
    }

    // Mutable pointer to the field.
    pub fn mut_get_hyperv_cpuid(&mut self) -> &mut VcpuResponse_CpuidResponse {
        if let ::std::option::Option::Some(VcpuResponse_oneof_message::get_hyperv_cpuid(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(VcpuResponse_oneof_message::get_hyperv_cpuid(VcpuResponse_CpuidResponse::new()));
        }
        match self.message {
            ::std::option::Option::Some(VcpuResponse_oneof_message::get_hyperv_cpuid(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_get_hyperv_cpuid(&mut self) -> VcpuResponse_CpuidResponse {
        if self.has_get_hyperv_cpuid() {
            match self.message.take() {
                ::std::option::Option::Some(VcpuResponse_oneof_message::get_hyperv_cpuid(v)) => v,
                _ => panic!(),
            }
        } else {
            VcpuResponse_CpuidResponse::new()
        }
    }

    // .VcpuResponse.EnableCapability enable_capability = 10;


    pub fn get_enable_capability(&self) -> &VcpuResponse_EnableCapability {
        match self.message {
            ::std::option::Option::Some(VcpuResponse_oneof_message::enable_capability(ref v)) => v,
            _ => <VcpuResponse_EnableCapability as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_enable_capability(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_enable_capability(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(VcpuResponse_oneof_message::enable_capability(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_enable_capability(&mut self, v: VcpuResponse_EnableCapability) {
        self.message = ::std::option::Option::Some(VcpuResponse_oneof_message::enable_capability(v))
    }

    // Mutable pointer to the field.
    pub fn mut_enable_capability(&mut self) -> &mut VcpuResponse_EnableCapability {
        if let ::std::option::Option::Some(VcpuResponse_oneof_message::enable_capability(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(VcpuResponse_oneof_message::enable_capability(VcpuResponse_EnableCapability::new()));
        }
        match self.message {
            ::std::option::Option::Some(VcpuResponse_oneof_message::enable_capability(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_enable_capability(&mut self) -> VcpuResponse_EnableCapability {
        if self.has_enable_capability() {
            match self.message.take() {
                ::std::option::Option::Some(VcpuResponse_oneof_message::enable_capability(v)) => v,
                _ => panic!(),
            }
        } else {
            VcpuResponse_EnableCapability::new()
        }
    }
}

impl ::protobuf::Message for VcpuResponse {
    fn is_initialized(&self) -> bool {
        if let Some(VcpuResponse_oneof_message::wait(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(VcpuResponse_oneof_message::get_state(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(VcpuResponse_oneof_message::set_state(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(VcpuResponse_oneof_message::get_msrs(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(VcpuResponse_oneof_message::set_msrs(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(VcpuResponse_oneof_message::set_cpuid(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(VcpuResponse_oneof_message::get_hyperv_cpuid(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(VcpuResponse_oneof_message::enable_capability(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.errno = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(VcpuResponse_oneof_message::wait(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(VcpuResponse_oneof_message::get_state(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(VcpuResponse_oneof_message::set_state(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(VcpuResponse_oneof_message::get_msrs(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(VcpuResponse_oneof_message::set_msrs(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(VcpuResponse_oneof_message::set_cpuid(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(VcpuResponse_oneof_message::get_hyperv_cpuid(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(VcpuResponse_oneof_message::enable_capability(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.errno != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, self.errno);
        }
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &VcpuResponse_oneof_message::wait(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &VcpuResponse_oneof_message::get_state(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &VcpuResponse_oneof_message::set_state(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &VcpuResponse_oneof_message::get_msrs(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &VcpuResponse_oneof_message::set_msrs(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &VcpuResponse_oneof_message::set_cpuid(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &VcpuResponse_oneof_message::get_hyperv_cpuid(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &VcpuResponse_oneof_message::enable_capability(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.errno != 0 {
            os.write_sint32(1, self.errno)?;
        }
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &VcpuResponse_oneof_message::wait(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &VcpuResponse_oneof_message::get_state(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &VcpuResponse_oneof_message::set_state(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &VcpuResponse_oneof_message::get_msrs(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &VcpuResponse_oneof_message::set_msrs(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &VcpuResponse_oneof_message::set_cpuid(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &VcpuResponse_oneof_message::get_hyperv_cpuid(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &VcpuResponse_oneof_message::enable_capability(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VcpuResponse {
        VcpuResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "errno",
                |m: &VcpuResponse| { &m.errno },
                |m: &mut VcpuResponse| { &mut m.errno },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VcpuResponse_Wait>(
                "wait",
                VcpuResponse::has_wait,
                VcpuResponse::get_wait,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VcpuResponse_GetState>(
                "get_state",
                VcpuResponse::has_get_state,
                VcpuResponse::get_get_state,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VcpuResponse_SetState>(
                "set_state",
                VcpuResponse::has_set_state,
                VcpuResponse::get_set_state,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VcpuResponse_GetMsrs>(
                "get_msrs",
                VcpuResponse::has_get_msrs,
                VcpuResponse::get_get_msrs,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VcpuResponse_SetMsrs>(
                "set_msrs",
                VcpuResponse::has_set_msrs,
                VcpuResponse::get_set_msrs,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VcpuResponse_SetCpuid>(
                "set_cpuid",
                VcpuResponse::has_set_cpuid,
                VcpuResponse::get_set_cpuid,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VcpuResponse_CpuidResponse>(
                "get_hyperv_cpuid",
                VcpuResponse::has_get_hyperv_cpuid,
                VcpuResponse::get_get_hyperv_cpuid,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VcpuResponse_EnableCapability>(
                "enable_capability",
                VcpuResponse::has_enable_capability,
                VcpuResponse::get_enable_capability,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VcpuResponse>(
                "VcpuResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VcpuResponse {
        static instance: ::protobuf::rt::LazyV2<VcpuResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VcpuResponse::new)
    }
}

impl ::protobuf::Clear for VcpuResponse {
    fn clear(&mut self) {
        self.errno = 0;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VcpuResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VcpuResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VcpuResponse_Wait {
    // message oneof groups
    pub exit: ::std::option::Option<VcpuResponse_Wait_oneof_exit>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VcpuResponse_Wait {
    fn default() -> &'a VcpuResponse_Wait {
        <VcpuResponse_Wait as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum VcpuResponse_Wait_oneof_exit {
    init(VcpuResponse_Wait_Init),
    io(VcpuResponse_Wait_Io),
    user(VcpuResponse_Wait_User),
    hyperv_call(VcpuResponse_Wait_HypervCall),
    hyperv_synic(VcpuResponse_Wait_HypervSynic),
}

impl VcpuResponse_Wait {
    pub fn new() -> VcpuResponse_Wait {
        ::std::default::Default::default()
    }

    // .VcpuResponse.Wait.Init init = 1;


    pub fn get_init(&self) -> &VcpuResponse_Wait_Init {
        match self.exit {
            ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::init(ref v)) => v,
            _ => <VcpuResponse_Wait_Init as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_init(&mut self) {
        self.exit = ::std::option::Option::None;
    }

    pub fn has_init(&self) -> bool {
        match self.exit {
            ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::init(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_init(&mut self, v: VcpuResponse_Wait_Init) {
        self.exit = ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::init(v))
    }

    // Mutable pointer to the field.
    pub fn mut_init(&mut self) -> &mut VcpuResponse_Wait_Init {
        if let ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::init(_)) = self.exit {
        } else {
            self.exit = ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::init(VcpuResponse_Wait_Init::new()));
        }
        match self.exit {
            ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::init(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_init(&mut self) -> VcpuResponse_Wait_Init {
        if self.has_init() {
            match self.exit.take() {
                ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::init(v)) => v,
                _ => panic!(),
            }
        } else {
            VcpuResponse_Wait_Init::new()
        }
    }

    // .VcpuResponse.Wait.Io io = 2;


    pub fn get_io(&self) -> &VcpuResponse_Wait_Io {
        match self.exit {
            ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::io(ref v)) => v,
            _ => <VcpuResponse_Wait_Io as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_io(&mut self) {
        self.exit = ::std::option::Option::None;
    }

    pub fn has_io(&self) -> bool {
        match self.exit {
            ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::io(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_io(&mut self, v: VcpuResponse_Wait_Io) {
        self.exit = ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::io(v))
    }

    // Mutable pointer to the field.
    pub fn mut_io(&mut self) -> &mut VcpuResponse_Wait_Io {
        if let ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::io(_)) = self.exit {
        } else {
            self.exit = ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::io(VcpuResponse_Wait_Io::new()));
        }
        match self.exit {
            ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::io(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_io(&mut self) -> VcpuResponse_Wait_Io {
        if self.has_io() {
            match self.exit.take() {
                ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::io(v)) => v,
                _ => panic!(),
            }
        } else {
            VcpuResponse_Wait_Io::new()
        }
    }

    // .VcpuResponse.Wait.User user = 3;


    pub fn get_user(&self) -> &VcpuResponse_Wait_User {
        match self.exit {
            ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::user(ref v)) => v,
            _ => <VcpuResponse_Wait_User as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_user(&mut self) {
        self.exit = ::std::option::Option::None;
    }

    pub fn has_user(&self) -> bool {
        match self.exit {
            ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::user(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: VcpuResponse_Wait_User) {
        self.exit = ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::user(v))
    }

    // Mutable pointer to the field.
    pub fn mut_user(&mut self) -> &mut VcpuResponse_Wait_User {
        if let ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::user(_)) = self.exit {
        } else {
            self.exit = ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::user(VcpuResponse_Wait_User::new()));
        }
        match self.exit {
            ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::user(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_user(&mut self) -> VcpuResponse_Wait_User {
        if self.has_user() {
            match self.exit.take() {
                ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::user(v)) => v,
                _ => panic!(),
            }
        } else {
            VcpuResponse_Wait_User::new()
        }
    }

    // .VcpuResponse.Wait.HypervCall hyperv_call = 4;


    pub fn get_hyperv_call(&self) -> &VcpuResponse_Wait_HypervCall {
        match self.exit {
            ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::hyperv_call(ref v)) => v,
            _ => <VcpuResponse_Wait_HypervCall as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_hyperv_call(&mut self) {
        self.exit = ::std::option::Option::None;
    }

    pub fn has_hyperv_call(&self) -> bool {
        match self.exit {
            ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::hyperv_call(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_hyperv_call(&mut self, v: VcpuResponse_Wait_HypervCall) {
        self.exit = ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::hyperv_call(v))
    }

    // Mutable pointer to the field.
    pub fn mut_hyperv_call(&mut self) -> &mut VcpuResponse_Wait_HypervCall {
        if let ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::hyperv_call(_)) = self.exit {
        } else {
            self.exit = ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::hyperv_call(VcpuResponse_Wait_HypervCall::new()));
        }
        match self.exit {
            ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::hyperv_call(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_hyperv_call(&mut self) -> VcpuResponse_Wait_HypervCall {
        if self.has_hyperv_call() {
            match self.exit.take() {
                ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::hyperv_call(v)) => v,
                _ => panic!(),
            }
        } else {
            VcpuResponse_Wait_HypervCall::new()
        }
    }

    // .VcpuResponse.Wait.HypervSynic hyperv_synic = 5;


    pub fn get_hyperv_synic(&self) -> &VcpuResponse_Wait_HypervSynic {
        match self.exit {
            ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::hyperv_synic(ref v)) => v,
            _ => <VcpuResponse_Wait_HypervSynic as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_hyperv_synic(&mut self) {
        self.exit = ::std::option::Option::None;
    }

    pub fn has_hyperv_synic(&self) -> bool {
        match self.exit {
            ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::hyperv_synic(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_hyperv_synic(&mut self, v: VcpuResponse_Wait_HypervSynic) {
        self.exit = ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::hyperv_synic(v))
    }

    // Mutable pointer to the field.
    pub fn mut_hyperv_synic(&mut self) -> &mut VcpuResponse_Wait_HypervSynic {
        if let ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::hyperv_synic(_)) = self.exit {
        } else {
            self.exit = ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::hyperv_synic(VcpuResponse_Wait_HypervSynic::new()));
        }
        match self.exit {
            ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::hyperv_synic(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_hyperv_synic(&mut self) -> VcpuResponse_Wait_HypervSynic {
        if self.has_hyperv_synic() {
            match self.exit.take() {
                ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::hyperv_synic(v)) => v,
                _ => panic!(),
            }
        } else {
            VcpuResponse_Wait_HypervSynic::new()
        }
    }
}

impl ::protobuf::Message for VcpuResponse_Wait {
    fn is_initialized(&self) -> bool {
        if let Some(VcpuResponse_Wait_oneof_exit::init(ref v)) = self.exit {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(VcpuResponse_Wait_oneof_exit::io(ref v)) = self.exit {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(VcpuResponse_Wait_oneof_exit::user(ref v)) = self.exit {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(VcpuResponse_Wait_oneof_exit::hyperv_call(ref v)) = self.exit {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(VcpuResponse_Wait_oneof_exit::hyperv_synic(ref v)) = self.exit {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.exit = ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::init(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.exit = ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::io(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.exit = ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::user(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.exit = ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::hyperv_call(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.exit = ::std::option::Option::Some(VcpuResponse_Wait_oneof_exit::hyperv_synic(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.exit {
            match v {
                &VcpuResponse_Wait_oneof_exit::init(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &VcpuResponse_Wait_oneof_exit::io(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &VcpuResponse_Wait_oneof_exit::user(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &VcpuResponse_Wait_oneof_exit::hyperv_call(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &VcpuResponse_Wait_oneof_exit::hyperv_synic(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.exit {
            match v {
                &VcpuResponse_Wait_oneof_exit::init(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &VcpuResponse_Wait_oneof_exit::io(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &VcpuResponse_Wait_oneof_exit::user(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &VcpuResponse_Wait_oneof_exit::hyperv_call(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &VcpuResponse_Wait_oneof_exit::hyperv_synic(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VcpuResponse_Wait {
        VcpuResponse_Wait::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VcpuResponse_Wait_Init>(
                "init",
                VcpuResponse_Wait::has_init,
                VcpuResponse_Wait::get_init,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VcpuResponse_Wait_Io>(
                "io",
                VcpuResponse_Wait::has_io,
                VcpuResponse_Wait::get_io,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VcpuResponse_Wait_User>(
                "user",
                VcpuResponse_Wait::has_user,
                VcpuResponse_Wait::get_user,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VcpuResponse_Wait_HypervCall>(
                "hyperv_call",
                VcpuResponse_Wait::has_hyperv_call,
                VcpuResponse_Wait::get_hyperv_call,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VcpuResponse_Wait_HypervSynic>(
                "hyperv_synic",
                VcpuResponse_Wait::has_hyperv_synic,
                VcpuResponse_Wait::get_hyperv_synic,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VcpuResponse_Wait>(
                "VcpuResponse.Wait",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VcpuResponse_Wait {
        static instance: ::protobuf::rt::LazyV2<VcpuResponse_Wait> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VcpuResponse_Wait::new)
    }
}

impl ::protobuf::Clear for VcpuResponse_Wait {
    fn clear(&mut self) {
        self.exit = ::std::option::Option::None;
        self.exit = ::std::option::Option::None;
        self.exit = ::std::option::Option::None;
        self.exit = ::std::option::Option::None;
        self.exit = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VcpuResponse_Wait {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VcpuResponse_Wait {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VcpuResponse_Wait_Init {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VcpuResponse_Wait_Init {
    fn default() -> &'a VcpuResponse_Wait_Init {
        <VcpuResponse_Wait_Init as ::protobuf::Message>::default_instance()
    }
}

impl VcpuResponse_Wait_Init {
    pub fn new() -> VcpuResponse_Wait_Init {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VcpuResponse_Wait_Init {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VcpuResponse_Wait_Init {
        VcpuResponse_Wait_Init::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VcpuResponse_Wait_Init>(
                "VcpuResponse.Wait.Init",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VcpuResponse_Wait_Init {
        static instance: ::protobuf::rt::LazyV2<VcpuResponse_Wait_Init> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VcpuResponse_Wait_Init::new)
    }
}

impl ::protobuf::Clear for VcpuResponse_Wait_Init {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VcpuResponse_Wait_Init {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VcpuResponse_Wait_Init {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VcpuResponse_Wait_Io {
    // message fields
    pub space: AddressSpace,
    pub address: u64,
    pub is_write: bool,
    pub no_resume: bool,
    pub data: ::std::vec::Vec<u8>,
    pub regs: ::std::vec::Vec<u8>,
    pub sregs: ::std::vec::Vec<u8>,
    pub debugregs: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VcpuResponse_Wait_Io {
    fn default() -> &'a VcpuResponse_Wait_Io {
        <VcpuResponse_Wait_Io as ::protobuf::Message>::default_instance()
    }
}

impl VcpuResponse_Wait_Io {
    pub fn new() -> VcpuResponse_Wait_Io {
        ::std::default::Default::default()
    }

    // .AddressSpace space = 1;


    pub fn get_space(&self) -> AddressSpace {
        self.space
    }
    pub fn clear_space(&mut self) {
        self.space = AddressSpace::IOPORT;
    }

    // Param is passed by value, moved
    pub fn set_space(&mut self, v: AddressSpace) {
        self.space = v;
    }

    // uint64 address = 2;


    pub fn get_address(&self) -> u64 {
        self.address
    }
    pub fn clear_address(&mut self) {
        self.address = 0;
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: u64) {
        self.address = v;
    }

    // bool is_write = 3;


    pub fn get_is_write(&self) -> bool {
        self.is_write
    }
    pub fn clear_is_write(&mut self) {
        self.is_write = false;
    }

    // Param is passed by value, moved
    pub fn set_is_write(&mut self, v: bool) {
        self.is_write = v;
    }

    // bool no_resume = 4;


    pub fn get_no_resume(&self) -> bool {
        self.no_resume
    }
    pub fn clear_no_resume(&mut self) {
        self.no_resume = false;
    }

    // Param is passed by value, moved
    pub fn set_no_resume(&mut self, v: bool) {
        self.no_resume = v;
    }

    // bytes data = 5;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // bytes regs = 6;


    pub fn get_regs(&self) -> &[u8] {
        &self.regs
    }
    pub fn clear_regs(&mut self) {
        self.regs.clear();
    }

    // Param is passed by value, moved
    pub fn set_regs(&mut self, v: ::std::vec::Vec<u8>) {
        self.regs = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_regs(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.regs
    }

    // Take field
    pub fn take_regs(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.regs, ::std::vec::Vec::new())
    }

    // bytes sregs = 7;


    pub fn get_sregs(&self) -> &[u8] {
        &self.sregs
    }
    pub fn clear_sregs(&mut self) {
        self.sregs.clear();
    }

    // Param is passed by value, moved
    pub fn set_sregs(&mut self, v: ::std::vec::Vec<u8>) {
        self.sregs = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sregs(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.sregs
    }

    // Take field
    pub fn take_sregs(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.sregs, ::std::vec::Vec::new())
    }

    // bytes debugregs = 8;


    pub fn get_debugregs(&self) -> &[u8] {
        &self.debugregs
    }
    pub fn clear_debugregs(&mut self) {
        self.debugregs.clear();
    }

    // Param is passed by value, moved
    pub fn set_debugregs(&mut self, v: ::std::vec::Vec<u8>) {
        self.debugregs = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debugregs(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.debugregs
    }

    // Take field
    pub fn take_debugregs(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.debugregs, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for VcpuResponse_Wait_Io {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.space, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.address = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_write = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.no_resume = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.regs)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.sregs)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.debugregs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.space != AddressSpace::IOPORT {
            my_size += ::protobuf::rt::enum_size(1, self.space);
        }
        if self.address != 0 {
            my_size += ::protobuf::rt::value_size(2, self.address, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_write != false {
            my_size += 2;
        }
        if self.no_resume != false {
            my_size += 2;
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.data);
        }
        if !self.regs.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.regs);
        }
        if !self.sregs.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.sregs);
        }
        if !self.debugregs.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.debugregs);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.space != AddressSpace::IOPORT {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.space))?;
        }
        if self.address != 0 {
            os.write_uint64(2, self.address)?;
        }
        if self.is_write != false {
            os.write_bool(3, self.is_write)?;
        }
        if self.no_resume != false {
            os.write_bool(4, self.no_resume)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(5, &self.data)?;
        }
        if !self.regs.is_empty() {
            os.write_bytes(6, &self.regs)?;
        }
        if !self.sregs.is_empty() {
            os.write_bytes(7, &self.sregs)?;
        }
        if !self.debugregs.is_empty() {
            os.write_bytes(8, &self.debugregs)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VcpuResponse_Wait_Io {
        VcpuResponse_Wait_Io::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AddressSpace>>(
                "space",
                |m: &VcpuResponse_Wait_Io| { &m.space },
                |m: &mut VcpuResponse_Wait_Io| { &mut m.space },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "address",
                |m: &VcpuResponse_Wait_Io| { &m.address },
                |m: &mut VcpuResponse_Wait_Io| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_write",
                |m: &VcpuResponse_Wait_Io| { &m.is_write },
                |m: &mut VcpuResponse_Wait_Io| { &mut m.is_write },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "no_resume",
                |m: &VcpuResponse_Wait_Io| { &m.no_resume },
                |m: &mut VcpuResponse_Wait_Io| { &mut m.no_resume },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &VcpuResponse_Wait_Io| { &m.data },
                |m: &mut VcpuResponse_Wait_Io| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "regs",
                |m: &VcpuResponse_Wait_Io| { &m.regs },
                |m: &mut VcpuResponse_Wait_Io| { &mut m.regs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sregs",
                |m: &VcpuResponse_Wait_Io| { &m.sregs },
                |m: &mut VcpuResponse_Wait_Io| { &mut m.sregs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "debugregs",
                |m: &VcpuResponse_Wait_Io| { &m.debugregs },
                |m: &mut VcpuResponse_Wait_Io| { &mut m.debugregs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VcpuResponse_Wait_Io>(
                "VcpuResponse.Wait.Io",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VcpuResponse_Wait_Io {
        static instance: ::protobuf::rt::LazyV2<VcpuResponse_Wait_Io> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VcpuResponse_Wait_Io::new)
    }
}

impl ::protobuf::Clear for VcpuResponse_Wait_Io {
    fn clear(&mut self) {
        self.space = AddressSpace::IOPORT;
        self.address = 0;
        self.is_write = false;
        self.no_resume = false;
        self.data.clear();
        self.regs.clear();
        self.sregs.clear();
        self.debugregs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VcpuResponse_Wait_Io {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VcpuResponse_Wait_Io {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VcpuResponse_Wait_User {
    // message fields
    pub user: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VcpuResponse_Wait_User {
    fn default() -> &'a VcpuResponse_Wait_User {
        <VcpuResponse_Wait_User as ::protobuf::Message>::default_instance()
    }
}

impl VcpuResponse_Wait_User {
    pub fn new() -> VcpuResponse_Wait_User {
        ::std::default::Default::default()
    }

    // uint64 user = 1;


    pub fn get_user(&self) -> u64 {
        self.user
    }
    pub fn clear_user(&mut self) {
        self.user = 0;
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: u64) {
        self.user = v;
    }
}

impl ::protobuf::Message for VcpuResponse_Wait_User {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.user = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.user != 0 {
            my_size += ::protobuf::rt::value_size(1, self.user, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.user != 0 {
            os.write_uint64(1, self.user)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VcpuResponse_Wait_User {
        VcpuResponse_Wait_User::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "user",
                |m: &VcpuResponse_Wait_User| { &m.user },
                |m: &mut VcpuResponse_Wait_User| { &mut m.user },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VcpuResponse_Wait_User>(
                "VcpuResponse.Wait.User",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VcpuResponse_Wait_User {
        static instance: ::protobuf::rt::LazyV2<VcpuResponse_Wait_User> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VcpuResponse_Wait_User::new)
    }
}

impl ::protobuf::Clear for VcpuResponse_Wait_User {
    fn clear(&mut self) {
        self.user = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VcpuResponse_Wait_User {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VcpuResponse_Wait_User {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VcpuResponse_Wait_HypervCall {
    // message fields
    pub input: u64,
    pub params0: u64,
    pub params1: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VcpuResponse_Wait_HypervCall {
    fn default() -> &'a VcpuResponse_Wait_HypervCall {
        <VcpuResponse_Wait_HypervCall as ::protobuf::Message>::default_instance()
    }
}

impl VcpuResponse_Wait_HypervCall {
    pub fn new() -> VcpuResponse_Wait_HypervCall {
        ::std::default::Default::default()
    }

    // uint64 input = 1;


    pub fn get_input(&self) -> u64 {
        self.input
    }
    pub fn clear_input(&mut self) {
        self.input = 0;
    }

    // Param is passed by value, moved
    pub fn set_input(&mut self, v: u64) {
        self.input = v;
    }

    // uint64 params0 = 2;


    pub fn get_params0(&self) -> u64 {
        self.params0
    }
    pub fn clear_params0(&mut self) {
        self.params0 = 0;
    }

    // Param is passed by value, moved
    pub fn set_params0(&mut self, v: u64) {
        self.params0 = v;
    }

    // uint64 params1 = 3;


    pub fn get_params1(&self) -> u64 {
        self.params1
    }
    pub fn clear_params1(&mut self) {
        self.params1 = 0;
    }

    // Param is passed by value, moved
    pub fn set_params1(&mut self, v: u64) {
        self.params1 = v;
    }
}

impl ::protobuf::Message for VcpuResponse_Wait_HypervCall {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.input = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.params0 = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.params1 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.input != 0 {
            my_size += ::protobuf::rt::value_size(1, self.input, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.params0 != 0 {
            my_size += ::protobuf::rt::value_size(2, self.params0, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.params1 != 0 {
            my_size += ::protobuf::rt::value_size(3, self.params1, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.input != 0 {
            os.write_uint64(1, self.input)?;
        }
        if self.params0 != 0 {
            os.write_uint64(2, self.params0)?;
        }
        if self.params1 != 0 {
            os.write_uint64(3, self.params1)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VcpuResponse_Wait_HypervCall {
        VcpuResponse_Wait_HypervCall::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "input",
                |m: &VcpuResponse_Wait_HypervCall| { &m.input },
                |m: &mut VcpuResponse_Wait_HypervCall| { &mut m.input },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "params0",
                |m: &VcpuResponse_Wait_HypervCall| { &m.params0 },
                |m: &mut VcpuResponse_Wait_HypervCall| { &mut m.params0 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "params1",
                |m: &VcpuResponse_Wait_HypervCall| { &m.params1 },
                |m: &mut VcpuResponse_Wait_HypervCall| { &mut m.params1 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VcpuResponse_Wait_HypervCall>(
                "VcpuResponse.Wait.HypervCall",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VcpuResponse_Wait_HypervCall {
        static instance: ::protobuf::rt::LazyV2<VcpuResponse_Wait_HypervCall> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VcpuResponse_Wait_HypervCall::new)
    }
}

impl ::protobuf::Clear for VcpuResponse_Wait_HypervCall {
    fn clear(&mut self) {
        self.input = 0;
        self.params0 = 0;
        self.params1 = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VcpuResponse_Wait_HypervCall {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VcpuResponse_Wait_HypervCall {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VcpuResponse_Wait_HypervSynic {
    // message fields
    pub msr: u32,
    pub control: u64,
    pub evt_page: u64,
    pub msg_page: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VcpuResponse_Wait_HypervSynic {
    fn default() -> &'a VcpuResponse_Wait_HypervSynic {
        <VcpuResponse_Wait_HypervSynic as ::protobuf::Message>::default_instance()
    }
}

impl VcpuResponse_Wait_HypervSynic {
    pub fn new() -> VcpuResponse_Wait_HypervSynic {
        ::std::default::Default::default()
    }

    // uint32 msr = 1;


    pub fn get_msr(&self) -> u32 {
        self.msr
    }
    pub fn clear_msr(&mut self) {
        self.msr = 0;
    }

    // Param is passed by value, moved
    pub fn set_msr(&mut self, v: u32) {
        self.msr = v;
    }

    // uint64 control = 2;


    pub fn get_control(&self) -> u64 {
        self.control
    }
    pub fn clear_control(&mut self) {
        self.control = 0;
    }

    // Param is passed by value, moved
    pub fn set_control(&mut self, v: u64) {
        self.control = v;
    }

    // uint64 evt_page = 3;


    pub fn get_evt_page(&self) -> u64 {
        self.evt_page
    }
    pub fn clear_evt_page(&mut self) {
        self.evt_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_evt_page(&mut self, v: u64) {
        self.evt_page = v;
    }

    // uint64 msg_page = 4;


    pub fn get_msg_page(&self) -> u64 {
        self.msg_page
    }
    pub fn clear_msg_page(&mut self) {
        self.msg_page = 0;
    }

    // Param is passed by value, moved
    pub fn set_msg_page(&mut self, v: u64) {
        self.msg_page = v;
    }
}

impl ::protobuf::Message for VcpuResponse_Wait_HypervSynic {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.msr = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.control = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.evt_page = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.msg_page = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.msr != 0 {
            my_size += ::protobuf::rt::value_size(1, self.msr, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.control != 0 {
            my_size += ::protobuf::rt::value_size(2, self.control, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.evt_page != 0 {
            my_size += ::protobuf::rt::value_size(3, self.evt_page, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.msg_page != 0 {
            my_size += ::protobuf::rt::value_size(4, self.msg_page, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.msr != 0 {
            os.write_uint32(1, self.msr)?;
        }
        if self.control != 0 {
            os.write_uint64(2, self.control)?;
        }
        if self.evt_page != 0 {
            os.write_uint64(3, self.evt_page)?;
        }
        if self.msg_page != 0 {
            os.write_uint64(4, self.msg_page)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VcpuResponse_Wait_HypervSynic {
        VcpuResponse_Wait_HypervSynic::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "msr",
                |m: &VcpuResponse_Wait_HypervSynic| { &m.msr },
                |m: &mut VcpuResponse_Wait_HypervSynic| { &mut m.msr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "control",
                |m: &VcpuResponse_Wait_HypervSynic| { &m.control },
                |m: &mut VcpuResponse_Wait_HypervSynic| { &mut m.control },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "evt_page",
                |m: &VcpuResponse_Wait_HypervSynic| { &m.evt_page },
                |m: &mut VcpuResponse_Wait_HypervSynic| { &mut m.evt_page },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "msg_page",
                |m: &VcpuResponse_Wait_HypervSynic| { &m.msg_page },
                |m: &mut VcpuResponse_Wait_HypervSynic| { &mut m.msg_page },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VcpuResponse_Wait_HypervSynic>(
                "VcpuResponse.Wait.HypervSynic",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VcpuResponse_Wait_HypervSynic {
        static instance: ::protobuf::rt::LazyV2<VcpuResponse_Wait_HypervSynic> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VcpuResponse_Wait_HypervSynic::new)
    }
}

impl ::protobuf::Clear for VcpuResponse_Wait_HypervSynic {
    fn clear(&mut self) {
        self.msr = 0;
        self.control = 0;
        self.evt_page = 0;
        self.msg_page = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VcpuResponse_Wait_HypervSynic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VcpuResponse_Wait_HypervSynic {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VcpuResponse_GetState {
    // message fields
    pub state: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VcpuResponse_GetState {
    fn default() -> &'a VcpuResponse_GetState {
        <VcpuResponse_GetState as ::protobuf::Message>::default_instance()
    }
}

impl VcpuResponse_GetState {
    pub fn new() -> VcpuResponse_GetState {
        ::std::default::Default::default()
    }

    // bytes state = 1;


    pub fn get_state(&self) -> &[u8] {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::vec::Vec<u8>) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.state, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for VcpuResponse_GetState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.state);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.state.is_empty() {
            os.write_bytes(1, &self.state)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VcpuResponse_GetState {
        VcpuResponse_GetState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "state",
                |m: &VcpuResponse_GetState| { &m.state },
                |m: &mut VcpuResponse_GetState| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VcpuResponse_GetState>(
                "VcpuResponse.GetState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VcpuResponse_GetState {
        static instance: ::protobuf::rt::LazyV2<VcpuResponse_GetState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VcpuResponse_GetState::new)
    }
}

impl ::protobuf::Clear for VcpuResponse_GetState {
    fn clear(&mut self) {
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VcpuResponse_GetState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VcpuResponse_GetState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VcpuResponse_SetState {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VcpuResponse_SetState {
    fn default() -> &'a VcpuResponse_SetState {
        <VcpuResponse_SetState as ::protobuf::Message>::default_instance()
    }
}

impl VcpuResponse_SetState {
    pub fn new() -> VcpuResponse_SetState {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VcpuResponse_SetState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VcpuResponse_SetState {
        VcpuResponse_SetState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VcpuResponse_SetState>(
                "VcpuResponse.SetState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VcpuResponse_SetState {
        static instance: ::protobuf::rt::LazyV2<VcpuResponse_SetState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VcpuResponse_SetState::new)
    }
}

impl ::protobuf::Clear for VcpuResponse_SetState {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VcpuResponse_SetState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VcpuResponse_SetState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VcpuResponse_CpuidResponse {
    // message fields
    pub entries: ::protobuf::RepeatedField<CpuidEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VcpuResponse_CpuidResponse {
    fn default() -> &'a VcpuResponse_CpuidResponse {
        <VcpuResponse_CpuidResponse as ::protobuf::Message>::default_instance()
    }
}

impl VcpuResponse_CpuidResponse {
    pub fn new() -> VcpuResponse_CpuidResponse {
        ::std::default::Default::default()
    }

    // repeated .CpuidEntry entries = 1;


    pub fn get_entries(&self) -> &[CpuidEntry] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<CpuidEntry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<CpuidEntry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<CpuidEntry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VcpuResponse_CpuidResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VcpuResponse_CpuidResponse {
        VcpuResponse_CpuidResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CpuidEntry>>(
                "entries",
                |m: &VcpuResponse_CpuidResponse| { &m.entries },
                |m: &mut VcpuResponse_CpuidResponse| { &mut m.entries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VcpuResponse_CpuidResponse>(
                "VcpuResponse.CpuidResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VcpuResponse_CpuidResponse {
        static instance: ::protobuf::rt::LazyV2<VcpuResponse_CpuidResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VcpuResponse_CpuidResponse::new)
    }
}

impl ::protobuf::Clear for VcpuResponse_CpuidResponse {
    fn clear(&mut self) {
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VcpuResponse_CpuidResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VcpuResponse_CpuidResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VcpuResponse_GetMsrs {
    // message fields
    pub entry_data: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VcpuResponse_GetMsrs {
    fn default() -> &'a VcpuResponse_GetMsrs {
        <VcpuResponse_GetMsrs as ::protobuf::Message>::default_instance()
    }
}

impl VcpuResponse_GetMsrs {
    pub fn new() -> VcpuResponse_GetMsrs {
        ::std::default::Default::default()
    }

    // repeated uint64 entry_data = 1;


    pub fn get_entry_data(&self) -> &[u64] {
        &self.entry_data
    }
    pub fn clear_entry_data(&mut self) {
        self.entry_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_entry_data(&mut self, v: ::std::vec::Vec<u64>) {
        self.entry_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entry_data(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.entry_data
    }

    // Take field
    pub fn take_entry_data(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.entry_data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for VcpuResponse_GetMsrs {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.entry_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entry_data {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entry_data {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VcpuResponse_GetMsrs {
        VcpuResponse_GetMsrs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "entry_data",
                |m: &VcpuResponse_GetMsrs| { &m.entry_data },
                |m: &mut VcpuResponse_GetMsrs| { &mut m.entry_data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VcpuResponse_GetMsrs>(
                "VcpuResponse.GetMsrs",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VcpuResponse_GetMsrs {
        static instance: ::protobuf::rt::LazyV2<VcpuResponse_GetMsrs> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VcpuResponse_GetMsrs::new)
    }
}

impl ::protobuf::Clear for VcpuResponse_GetMsrs {
    fn clear(&mut self) {
        self.entry_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VcpuResponse_GetMsrs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VcpuResponse_GetMsrs {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VcpuResponse_SetMsrs {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VcpuResponse_SetMsrs {
    fn default() -> &'a VcpuResponse_SetMsrs {
        <VcpuResponse_SetMsrs as ::protobuf::Message>::default_instance()
    }
}

impl VcpuResponse_SetMsrs {
    pub fn new() -> VcpuResponse_SetMsrs {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VcpuResponse_SetMsrs {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VcpuResponse_SetMsrs {
        VcpuResponse_SetMsrs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VcpuResponse_SetMsrs>(
                "VcpuResponse.SetMsrs",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VcpuResponse_SetMsrs {
        static instance: ::protobuf::rt::LazyV2<VcpuResponse_SetMsrs> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VcpuResponse_SetMsrs::new)
    }
}

impl ::protobuf::Clear for VcpuResponse_SetMsrs {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VcpuResponse_SetMsrs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VcpuResponse_SetMsrs {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VcpuResponse_SetCpuid {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VcpuResponse_SetCpuid {
    fn default() -> &'a VcpuResponse_SetCpuid {
        <VcpuResponse_SetCpuid as ::protobuf::Message>::default_instance()
    }
}

impl VcpuResponse_SetCpuid {
    pub fn new() -> VcpuResponse_SetCpuid {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VcpuResponse_SetCpuid {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VcpuResponse_SetCpuid {
        VcpuResponse_SetCpuid::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VcpuResponse_SetCpuid>(
                "VcpuResponse.SetCpuid",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VcpuResponse_SetCpuid {
        static instance: ::protobuf::rt::LazyV2<VcpuResponse_SetCpuid> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VcpuResponse_SetCpuid::new)
    }
}

impl ::protobuf::Clear for VcpuResponse_SetCpuid {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VcpuResponse_SetCpuid {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VcpuResponse_SetCpuid {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VcpuResponse_EnableCapability {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VcpuResponse_EnableCapability {
    fn default() -> &'a VcpuResponse_EnableCapability {
        <VcpuResponse_EnableCapability as ::protobuf::Message>::default_instance()
    }
}

impl VcpuResponse_EnableCapability {
    pub fn new() -> VcpuResponse_EnableCapability {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VcpuResponse_EnableCapability {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VcpuResponse_EnableCapability {
        VcpuResponse_EnableCapability::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VcpuResponse_EnableCapability>(
                "VcpuResponse.EnableCapability",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VcpuResponse_EnableCapability {
        static instance: ::protobuf::rt::LazyV2<VcpuResponse_EnableCapability> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VcpuResponse_EnableCapability::new)
    }
}

impl ::protobuf::Clear for VcpuResponse_EnableCapability {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VcpuResponse_EnableCapability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VcpuResponse_EnableCapability {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AddressSpace {
    IOPORT = 0,
    MMIO = 1,
}

impl ::protobuf::ProtobufEnum for AddressSpace {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AddressSpace> {
        match value {
            0 => ::std::option::Option::Some(AddressSpace::IOPORT),
            1 => ::std::option::Option::Some(AddressSpace::MMIO),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AddressSpace] = &[
            AddressSpace::IOPORT,
            AddressSpace::MMIO,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<AddressSpace>("AddressSpace", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for AddressSpace {
}

impl ::std::default::Default for AddressSpace {
    fn default() -> Self {
        AddressSpace::IOPORT
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressSpace {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0cplugin.proto\"\xa3\x01\n\nCpuidEntry\x12\x1a\n\x08function\x18\x01\
    \x20\x01(\rR\x08function\x12\x1b\n\thas_index\x18\x03\x20\x01(\x08R\x08h\
    asIndex\x12\x14\n\x05index\x18\x04\x20\x01(\rR\x05index\x12\x10\n\x03eax\
    \x18\x05\x20\x01(\rR\x03eax\x12\x10\n\x03ebx\x18\x06\x20\x01(\rR\x03ebx\
    \x12\x10\n\x03ecx\x18\x07\x20\x01(\rR\x03ecx\x12\x10\n\x03edx\x18\x08\
    \x20\x01(\rR\x03edx\"\x8f\x1a\n\x0bMainRequest\x12-\n\x06create\x18\x01\
    \x20\x01(\x0b2\x13.MainRequest.CreateH\0R\x06create\x120\n\x07destroy\
    \x18\x02\x20\x01(\x0b2\x14.MainRequest.DestroyH\0R\x07destroy\x12C\n\x0e\
    new_connection\x18\x03\x20\x01(\x0b2\x1a.MainRequest.NewConnectionH\0R\r\
    newConnection\x12S\n\x14get_shutdown_eventfd\x18\x04\x20\x01(\x0b2\x1f.M\
    ainRequest.GetShutdownEventfdH\0R\x12getShutdownEventfd\x12F\n\x0fcheck_\
    extension\x18\x05\x20\x01(\x0b2\x1b.MainRequest.CheckExtensionH\0R\x0ech\
    eckExtension\x12K\n\x13get_supported_cpuid\x18\x06\x20\x01(\x0b2\x19.Mai\
    nRequest.CpuidRequestH\0R\x11getSupportedCpuid\x12I\n\x12get_emulated_cp\
    uid\x18\x07\x20\x01(\x0b2\x19.MainRequest.CpuidRequestH\0R\x10getEmulate\
    dCpuid\x12J\n\x12get_msr_index_list\x18\x08\x20\x01(\x0b2\x1b.MainReques\
    t.MsrListRequestH\0R\x0fgetMsrIndexList\x12A\n\x0eget_net_config\x18\t\
    \x20\x01(\x0b2\x19.MainRequest.GetNetConfigH\0R\x0cgetNetConfig\x12@\n\r\
    reserve_range\x18\n\x20\x01(\x0b2\x19.MainRequest.ReserveRangeH\0R\x0cre\
    serveRange\x12.\n\x07set_irq\x18\x0b\x20\x01(\x0b2\x13.MainRequest.SetIr\
    qH\0R\x06setIrq\x12D\n\x0fset_irq_routing\x18\x0c\x20\x01(\x0b2\x1a.Main\
    Request.SetIrqRoutingH\0R\rsetIrqRouting\x124\n\tget_state\x18\r\x20\x01\
    (\x0b2\x15.MainRequest.GetStateH\0R\x08getState\x124\n\tset_state\x18\
    \x0e\x20\x01(\x0b2\x15.MainRequest.SetStateH\0R\x08setState\x12T\n\x15se\
    t_identity_map_addr\x18\x0f\x20\x01(\x0b2\x1f.MainRequest.SetIdentityMap\
    AddrH\0R\x12setIdentityMapAddr\x12:\n\x0bpause_vcpus\x18\x10\x20\x01(\
    \x0b2\x17.MainRequest.PauseVcpusH\0R\npauseVcpus\x124\n\tget_vcpus\x18\
    \x11\x20\x01(\x0b2\x15.MainRequest.GetVcpusH\0R\x08getVcpus\x12*\n\x05st\
    art\x18\x12\x20\x01(\x0b2\x12.MainRequest.StartH\0R\x05start\x12>\n\rset\
    _call_hint\x18\x13\x20\x01(\x0b2\x18.MainRequest.SetCallHintH\0R\x0bsetC\
    allHint\x12:\n\tdirty_log\x18e\x20\x01(\x0b2\x1b.MainRequest.MemoryDirty\
    LogH\0R\x08dirtyLog\x1a\x9e\x04\n\x06Create\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\rR\x02id\x128\n\x08io_event\x18\x02\x20\x01(\x0b2\x1b.MainRequest.\
    Create.IoEventH\0R\x07ioEvent\x124\n\x06memory\x18\x03\x20\x01(\x0b2\x1a\
    .MainRequest.Create.MemoryH\0R\x06memory\x12;\n\tirq_event\x18\x04\x20\
    \x01(\x0b2\x1c.MainRequest.Create.IrqEventH\0R\x08irqEvent\x1a~\n\x07IoE\
    vent\x12#\n\x05space\x18\x01\x20\x01(\x0e2\r.AddressSpaceR\x05space\x12\
    \x18\n\x07address\x18\x02\x20\x01(\x04R\x07address\x12\x16\n\x06length\
    \x18\x03\x20\x01(\rR\x06length\x12\x1c\n\tdatamatch\x18\x04\x20\x01(\x04\
    R\tdatamatch\x1a\x88\x01\n\x06Memory\x12\x16\n\x06offset\x18\x01\x20\x01\
    (\x04R\x06offset\x12\x14\n\x05start\x18\x02\x20\x01(\x04R\x05start\x12\
    \x16\n\x06length\x18\x03\x20\x01(\x04R\x06length\x12\x1b\n\tread_only\
    \x18\x04\x20\x01(\x08R\x08readOnly\x12\x1b\n\tdirty_log\x18\x05\x20\x01(\
    \x08R\x08dirtyLog\x1a=\n\x08IrqEvent\x12\x15\n\x06irq_id\x18\x01\x20\x01\
    (\rR\x05irqId\x12\x1a\n\x08resample\x18\x02\x20\x01(\x08R\x08resampleB\r\
    \n\x0bconstructor\x1a\x19\n\x07Destroy\x12\x0e\n\x02id\x18\x01\x20\x01(\
    \rR\x02id\x1a\x0f\n\rNewConnection\x1a\x14\n\x12GetShutdownEventfd\x1a.\
    \n\x0eCheckExtension\x12\x1c\n\textension\x18\x01\x20\x01(\rR\textension\
    \x1a\x0e\n\x0cCpuidRequest\x1a\x10\n\x0eMsrListRequest\x1a\x0e\n\x0cGetN\
    etConfig\x1a\x82\x01\n\x0cReserveRange\x12#\n\x05space\x18\x01\x20\x01(\
    \x0e2\r.AddressSpaceR\x05space\x12\x14\n\x05start\x18\x02\x20\x01(\x04R\
    \x05start\x12\x16\n\x06length\x18\x03\x20\x01(\x04R\x06length\x12\x1f\n\
    \x0basync_write\x18\x04\x20\x01(\x08R\nasyncWrite\x1a7\n\x06SetIrq\x12\
    \x15\n\x06irq_id\x18\x01\x20\x01(\rR\x05irqId\x12\x16\n\x06active\x18\
    \x02\x20\x01(\x08R\x06active\x1a\xdf\x02\n\rSetIrqRouting\x128\n\x06rout\
    es\x18\x01\x20\x03(\x0b2\x20.MainRequest.SetIrqRouting.RouteR\x06routes\
    \x1a\x93\x02\n\x05Route\x12\x15\n\x06irq_id\x18\x01\x20\x01(\rR\x05irqId\
    \x12D\n\x07irqchip\x18\x02\x20\x01(\x0b2(.MainRequest.SetIrqRouting.Rout\
    e.IrqchipH\0R\x07irqchip\x128\n\x03msi\x18\x03\x20\x01(\x0b2$.MainReques\
    t.SetIrqRouting.Route.MsiH\0R\x03msi\x1a5\n\x07Irqchip\x12\x18\n\x07irqc\
    hip\x18\x01\x20\x01(\rR\x07irqchip\x12\x10\n\x03pin\x18\x02\x20\x01(\rR\
    \x03pin\x1a3\n\x03Msi\x12\x18\n\x07address\x18\x01\x20\x01(\x04R\x07addr\
    ess\x12\x12\n\x04data\x18\x02\x20\x01(\rR\x04dataB\x07\n\x05route\x1a3\n\
    \x08GetState\x12'\n\x03set\x18\x01\x20\x01(\x0e2\x15.MainRequest.StateSe\
    tR\x03set\x1aI\n\x08SetState\x12'\n\x03set\x18\x01\x20\x01(\x0e2\x15.Mai\
    nRequest.StateSetR\x03set\x12\x14\n\x05state\x18\x02\x20\x01(\x0cR\x05st\
    ate\x1a.\n\x12SetIdentityMapAddr\x12\x18\n\x07address\x18\x01\x20\x01(\r\
    R\x07address\x1a;\n\nPauseVcpus\x12\x19\n\x08cpu_mask\x18\x01\x20\x01(\
    \x04R\x07cpuMask\x12\x12\n\x04user\x18\x02\x20\x01(\x04R\x04user\x1a\n\n\
    \x08GetVcpus\x1a\x07\n\x05Start\x1a\xad\x03\n\x0bSetCallHint\x12#\n\x05s\
    pace\x18\x01\x20\x01(\x0e2\r.AddressSpaceR\x05space\x12\x18\n\x07address\
    \x18\x02\x20\x01(\x04R\x07address\x12\x19\n\x08on_write\x18\x03\x20\x01(\
    \x08R\x07onWrite\x126\n\x05hints\x18\x04\x20\x03(\x0b2\x20.MainRequest.S\
    etCallHint.RegHintR\x05hints\x1a\x8b\x02\n\x07RegHint\x12\x1b\n\tmatch_r\
    ax\x18\x01\x20\x01(\x08R\x08matchRax\x12\x1b\n\tmatch_rbx\x18\x02\x20\
    \x01(\x08R\x08matchRbx\x12\x1b\n\tmatch_rcx\x18\x03\x20\x01(\x08R\x08mat\
    chRcx\x12\x1b\n\tmatch_rdx\x18\x04\x20\x01(\x08R\x08matchRdx\x12\x10\n\
    \x03rax\x18\x05\x20\x01(\x04R\x03rax\x12\x10\n\x03rbx\x18\x06\x20\x01(\
    \x04R\x03rbx\x12\x10\n\x03rcx\x18\x07\x20\x01(\x04R\x03rcx\x12\x10\n\x03\
    rdx\x18\x08\x20\x01(\x04R\x03rdx\x12\x1d\n\nsend_sregs\x18\t\x20\x01(\
    \x08R\tsendSregs\x12%\n\x0esend_debugregs\x18\n\x20\x01(\x08R\rsendDebug\
    regs\x1a\x20\n\x0eMemoryDirtyLog\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02\
    id\">\n\x08StateSet\x12\x08\n\x04PIC0\x10\0\x12\x08\n\x04PIC1\x10\x01\
    \x12\n\n\x06IOAPIC\x10\x02\x12\x07\n\x03PIT\x10\x03\x12\t\n\x05CLOCK\x10\
    \x04B\t\n\x07message\"\xe7\x0e\n\x0cMainResponse\x12\x14\n\x05errno\x18\
    \x01\x20\x01(\x11R\x05errno\x12.\n\x06create\x18\x02\x20\x01(\x0b2\x14.M\
    ainResponse.CreateH\0R\x06create\x121\n\x07destroy\x18\x03\x20\x01(\x0b2\
    \x15.MainResponse.DestroyH\0R\x07destroy\x12D\n\x0enew_connection\x18\
    \x04\x20\x01(\x0b2\x1b.MainResponse.NewConnectionH\0R\rnewConnection\x12\
    T\n\x14get_shutdown_eventfd\x18\x05\x20\x01(\x0b2\x20.MainResponse.GetSh\
    utdownEventfdH\0R\x12getShutdownEventfd\x12G\n\x0fcheck_extension\x18\
    \x06\x20\x01(\x0b2\x1c.MainResponse.CheckExtensionH\0R\x0echeckExtension\
    \x12M\n\x13get_supported_cpuid\x18\x07\x20\x01(\x0b2\x1b.MainResponse.Cp\
    uidResponseH\0R\x11getSupportedCpuid\x12K\n\x12get_emulated_cpuid\x18\
    \x08\x20\x01(\x0b2\x1b.MainResponse.CpuidResponseH\0R\x10getEmulatedCpui\
    d\x12L\n\x12get_msr_index_list\x18\t\x20\x01(\x0b2\x1d.MainResponse.MsrL\
    istResponseH\0R\x0fgetMsrIndexList\x12B\n\x0eget_net_config\x18\n\x20\
    \x01(\x0b2\x1a.MainResponse.GetNetConfigH\0R\x0cgetNetConfig\x12A\n\rres\
    erve_range\x18\x0b\x20\x01(\x0b2\x1a.MainResponse.ReserveRangeH\0R\x0cre\
    serveRange\x12/\n\x07set_irq\x18\x0c\x20\x01(\x0b2\x14.MainResponse.SetI\
    rqH\0R\x06setIrq\x12E\n\x0fset_irq_routing\x18\r\x20\x01(\x0b2\x1b.MainR\
    esponse.SetIrqRoutingH\0R\rsetIrqRouting\x125\n\tget_state\x18\x0e\x20\
    \x01(\x0b2\x16.MainResponse.GetStateH\0R\x08getState\x125\n\tset_state\
    \x18\x0f\x20\x01(\x0b2\x16.MainResponse.SetStateH\0R\x08setState\x12U\n\
    \x15set_identity_map_addr\x18\x10\x20\x01(\x0b2\x20.MainResponse.SetIden\
    tityMapAddrH\0R\x12setIdentityMapAddr\x12;\n\x0bpause_vcpus\x18\x11\x20\
    \x01(\x0b2\x18.MainResponse.PauseVcpusH\0R\npauseVcpus\x125\n\tget_vcpus\
    \x18\x12\x20\x01(\x0b2\x16.MainResponse.GetVcpusH\0R\x08getVcpus\x12+\n\
    \x05start\x18\x13\x20\x01(\x0b2\x13.MainResponse.StartH\0R\x05start\x12?\
    \n\rset_call_hint\x18\x14\x20\x01(\x0b2\x19.MainResponse.SetCallHintH\0R\
    \x0bsetCallHint\x12;\n\tdirty_log\x18e\x20\x01(\x0b2\x1c.MainResponse.Me\
    moryDirtyLogH\0R\x08dirtyLog\x1a\x08\n\x06Create\x1a\t\n\x07Destroy\x1a\
    \x0f\n\rNewConnection\x1a\x14\n\x12GetShutdownEventfd\x1a5\n\x0eCheckExt\
    ension\x12#\n\rhas_extension\x18\x01\x20\x01(\x08R\x0chasExtension\x1a6\
    \n\rCpuidResponse\x12%\n\x07entries\x18\x01\x20\x03(\x0b2\x0b.CpuidEntry\
    R\x07entries\x1a+\n\x0fMsrListResponse\x12\x18\n\x07indices\x18\x01\x20\
    \x03(\rR\x07indices\x1a~\n\x0cGetNetConfig\x12(\n\x10host_mac_address\
    \x18\x01\x20\x01(\x0cR\x0ehostMacAddress\x12*\n\x11host_ipv4_address\x18\
    \x02\x20\x01(\x07R\x0fhostIpv4Address\x12\x18\n\x07netmask\x18\x03\x20\
    \x01(\x07R\x07netmask\x1a\x0e\n\x0cReserveRange\x1a\x08\n\x06SetIrq\x1a\
    \x0f\n\rSetIrqRouting\x1a\x20\n\x08GetState\x12\x14\n\x05state\x18\x01\
    \x20\x01(\x0cR\x05state\x1a\n\n\x08SetState\x1a\x14\n\x12SetIdentityMapA\
    ddr\x1a\x0c\n\nPauseVcpus\x1a\n\n\x08GetVcpus\x1a\x07\n\x05Start\x1a\r\n\
    \x0bSetCallHint\x1a(\n\x0eMemoryDirtyLog\x12\x16\n\x06bitmap\x18\x01\x20\
    \x01(\x0cR\x06bitmapB\t\n\x07message\"\xb9\t\n\x0bVcpuRequest\x12'\n\x04\
    wait\x18\x01\x20\x01(\x0b2\x11.VcpuRequest.WaitH\0R\x04wait\x12-\n\x06re\
    sume\x18\x02\x20\x01(\x0b2\x13.VcpuRequest.ResumeH\0R\x06resume\x124\n\t\
    get_state\x18\x03\x20\x01(\x0b2\x15.VcpuRequest.GetStateH\0R\x08getState\
    \x124\n\tset_state\x18\x04\x20\x01(\x0b2\x15.VcpuRequest.SetStateH\0R\
    \x08setState\x121\n\x08get_msrs\x18\x05\x20\x01(\x0b2\x14.VcpuRequest.Ge\
    tMsrsH\0R\x07getMsrs\x121\n\x08set_msrs\x18\x06\x20\x01(\x0b2\x14.VcpuRe\
    quest.SetMsrsH\0R\x07setMsrs\x124\n\tset_cpuid\x18\x07\x20\x01(\x0b2\x15\
    .VcpuRequest.SetCpuidH\0R\x08setCpuid\x123\n\x08shutdown\x18\x08\x20\x01\
    (\x0b2\x15.VcpuRequest.ShutdownH\0R\x08shutdown\x12E\n\x10get_hyperv_cpu\
    id\x18\t\x20\x01(\x0b2\x19.VcpuRequest.CpuidRequestH\0R\x0egetHypervCpui\
    d\x12L\n\x11enable_capability\x18\n\x20\x01(\x0b2\x1d.VcpuRequest.Enable\
    CapabilityH\0R\x10enableCapability\x1a\x06\n\x04Wait\x1ad\n\x06Resume\
    \x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\x12\x12\n\x04regs\x18\
    \x02\x20\x01(\x0cR\x04regs\x12\x14\n\x05sregs\x18\x03\x20\x01(\x0cR\x05s\
    regs\x12\x1c\n\tdebugregs\x18\x04\x20\x01(\x0cR\tdebugregs\x1a3\n\x08Get\
    State\x12'\n\x03set\x18\x01\x20\x01(\x0e2\x15.VcpuRequest.StateSetR\x03s\
    et\x1aI\n\x08SetState\x12'\n\x03set\x18\x01\x20\x01(\x0e2\x15.VcpuReques\
    t.StateSetR\x03set\x12\x14\n\x05state\x18\x02\x20\x01(\x0cR\x05state\x1a\
    \x0e\n\x0cCpuidRequest\x1a.\n\x07GetMsrs\x12#\n\rentry_indices\x18\x01\
    \x20\x03(\rR\x0centryIndices\x1a4\n\x08MsrEntry\x12\x14\n\x05index\x18\
    \x01\x20\x01(\rR\x05index\x12\x12\n\x04data\x18\x02\x20\x01(\x04R\x04dat\
    a\x1a:\n\x07SetMsrs\x12/\n\x07entries\x18\x01\x20\x03(\x0b2\x15.VcpuRequ\
    est.MsrEntryR\x07entries\x1a1\n\x08SetCpuid\x12%\n\x07entries\x18\x01\
    \x20\x03(\x0b2\x0b.CpuidEntryR\x07entries\x1a\n\n\x08Shutdown\x1a2\n\x10\
    EnableCapability\x12\x1e\n\ncapability\x18\x01\x20\x01(\rR\ncapability\"\
    b\n\x08StateSet\x12\x08\n\x04REGS\x10\0\x12\t\n\x05SREGS\x10\x01\x12\x07\
    \n\x03FPU\x10\x02\x12\r\n\tDEBUGREGS\x10\x03\x12\t\n\x05LAPIC\x10\x04\
    \x12\x06\n\x02MP\x10\x05\x12\n\n\x06XCREGS\x10\x06\x12\n\n\x06EVENTS\x10\
    \x07B\t\n\x07message\"\x9f\x0b\n\x0cVcpuResponse\x12\x14\n\x05errno\x18\
    \x01\x20\x01(\x11R\x05errno\x12(\n\x04wait\x18\x02\x20\x01(\x0b2\x12.Vcp\
    uResponse.WaitH\0R\x04wait\x125\n\tget_state\x18\x04\x20\x01(\x0b2\x16.V\
    cpuResponse.GetStateH\0R\x08getState\x125\n\tset_state\x18\x05\x20\x01(\
    \x0b2\x16.VcpuResponse.SetStateH\0R\x08setState\x122\n\x08get_msrs\x18\
    \x06\x20\x01(\x0b2\x15.VcpuResponse.GetMsrsH\0R\x07getMsrs\x122\n\x08set\
    _msrs\x18\x07\x20\x01(\x0b2\x15.VcpuResponse.SetMsrsH\0R\x07setMsrs\x125\
    \n\tset_cpuid\x18\x08\x20\x01(\x0b2\x16.VcpuResponse.SetCpuidH\0R\x08set\
    Cpuid\x12G\n\x10get_hyperv_cpuid\x18\t\x20\x01(\x0b2\x1b.VcpuResponse.Cp\
    uidResponseH\0R\x0egetHypervCpuid\x12M\n\x11enable_capability\x18\n\x20\
    \x01(\x0b2\x1e.VcpuResponse.EnableCapabilityH\0R\x10enableCapability\x1a\
    \xe3\x05\n\x04Wait\x12-\n\x04init\x18\x01\x20\x01(\x0b2\x17.VcpuResponse\
    .Wait.InitH\0R\x04init\x12'\n\x02io\x18\x02\x20\x01(\x0b2\x15.VcpuRespon\
    se.Wait.IoH\0R\x02io\x12-\n\x04user\x18\x03\x20\x01(\x0b2\x17.VcpuRespon\
    se.Wait.UserH\0R\x04user\x12@\n\x0bhyperv_call\x18\x04\x20\x01(\x0b2\x1d\
    .VcpuResponse.Wait.HypervCallH\0R\nhypervCall\x12C\n\x0chyperv_synic\x18\
    \x05\x20\x01(\x0b2\x1e.VcpuResponse.Wait.HypervSynicH\0R\x0bhypervSynic\
    \x1a\x06\n\x04Init\x1a\xd7\x01\n\x02Io\x12#\n\x05space\x18\x01\x20\x01(\
    \x0e2\r.AddressSpaceR\x05space\x12\x18\n\x07address\x18\x02\x20\x01(\x04\
    R\x07address\x12\x19\n\x08is_write\x18\x03\x20\x01(\x08R\x07isWrite\x12\
    \x1b\n\tno_resume\x18\x04\x20\x01(\x08R\x08noResume\x12\x12\n\x04data\
    \x18\x05\x20\x01(\x0cR\x04data\x12\x12\n\x04regs\x18\x06\x20\x01(\x0cR\
    \x04regs\x12\x14\n\x05sregs\x18\x07\x20\x01(\x0cR\x05sregs\x12\x1c\n\tde\
    bugregs\x18\x08\x20\x01(\x0cR\tdebugregs\x1a\x1a\n\x04User\x12\x12\n\x04\
    user\x18\x01\x20\x01(\x04R\x04user\x1aV\n\nHypervCall\x12\x14\n\x05input\
    \x18\x01\x20\x01(\x04R\x05input\x12\x18\n\x07params0\x18\x02\x20\x01(\
    \x04R\x07params0\x12\x18\n\x07params1\x18\x03\x20\x01(\x04R\x07params1\
    \x1ao\n\x0bHypervSynic\x12\x10\n\x03msr\x18\x01\x20\x01(\rR\x03msr\x12\
    \x18\n\x07control\x18\x02\x20\x01(\x04R\x07control\x12\x19\n\x08evt_page\
    \x18\x03\x20\x01(\x04R\x07evtPage\x12\x19\n\x08msg_page\x18\x04\x20\x01(\
    \x04R\x07msgPageB\x06\n\x04exit\x1a\x20\n\x08GetState\x12\x14\n\x05state\
    \x18\x01\x20\x01(\x0cR\x05state\x1a\n\n\x08SetState\x1a6\n\rCpuidRespons\
    e\x12%\n\x07entries\x18\x01\x20\x03(\x0b2\x0b.CpuidEntryR\x07entries\x1a\
    (\n\x07GetMsrs\x12\x1d\n\nentry_data\x18\x01\x20\x03(\x04R\tentryData\
    \x1a\t\n\x07SetMsrs\x1a\n\n\x08SetCpuid\x1a\x12\n\x10EnableCapabilityB\t\
    \n\x07message*$\n\x0cAddressSpace\x12\n\n\x06IOPORT\x10\0\x12\x08\n\x04M\
    MIO\x10\x01b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
